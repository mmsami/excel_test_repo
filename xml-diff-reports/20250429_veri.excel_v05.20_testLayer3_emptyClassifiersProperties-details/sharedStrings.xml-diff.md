# Changes in 20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/xl/sharedStrings.xml

```diff
diff --git a/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/xl/sharedStrings.xml b/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/xl/sharedStrings.xml
new file mode 100644
index 0000000..09bd5e5
--- /dev/null
+++ b/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/20250429_veri.excel_v05.20_testLayer3_emptyClassifiersProperties/xl/sharedStrings.xml
@@ -0,0 +1,6361 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="8804" uniqueCount="2004"><si><t>ID</t></si><si><t>Name</t></si><si><t>Classifiers</t></si><si><t>Rules</t></si><si><t>Type</t></si><si><t>Kind</t></si><si><t>Class</t></si><si><t>Property</t></si><si><t>Table</t></si><si><t>Rule</t></si><si><t>Classifier</t></si><si><t>Feature</t></si><si><t>Attribute</t></si><si><t>Base</t></si><si><t>Property 1</t></si><si><t>Property 2</t></si><si><t>Cast</t></si><si><t>Property 3</t></si><si><t>Processor</t></si><si><t>Operator</t></si><si><t>Part</t></si><si><t>Line</t></si><si><t>Display</t></si><si><t>src</t></si><si><t>Literal</t></si><si><t>Parent</t></si><si><t>String Value 1</t></si><si><t>String Value 2</t></si><si><t>Literals</t></si><si><t>Manual VBA Code</t></si><si><t>Manual Excel Formula</t></si><si><t>Definition</t></si><si><t>Constraint Is Invariant</t></si><si><t>Part:displayedChoice</t></si><si><t>Package</t></si><si><t>T2 Name</t></si><si><t>T2 Name:q</t></si><si><t>Table 2 Ref</t></si><si><t>Table 1 Rows</t></si><si><t>Table 2 Rows</t></si><si><t>[c Table 1 Row]</t></si><si><t>[c Table 2 Row]</t></si><si><t>Table 1 Row</t></si><si><t>Part:src</t></si><si><t>Part:q</t></si><si><t>Property, Function, Parameter</t></si><si><t>Display:q</t></si><si><t>Generation</t></si><si><t>Indent</t></si><si><t>Line-1</t></si><si><t>Class:src</t></si><si><t>Rule Biz ID Without Line</t></si><si><t>Rule Biz ID</t></si><si><t>Part:src At Line - 1</t></si><si><t>Description</t></si><si><t>_Class</t></si><si><t>_Attribute</t></si><si><t>_Table</t></si><si><t>_Classifier</t></si><si><t>_Literal</t></si><si><t>_Rule</t></si><si><t>Kind:src</t></si><si><t>Tables</t></si><si><t>Parent:src</t></si><si><t>Super Class 1</t></si><si><t>Super Class 2</t></si><si><t>Super Class 4</t></si><si><t>Super Class 3</t></si><si><t>Super Class 5</t></si><si><t>Super Class 6</t></si><si><t>Name or Type</t></si><si><t>meta::Object.iD</t></si><si><t>meta::Object.kind</t></si><si><t>meta::Object.package</t></si><si><t>meta::NamedElement.name</t></si><si><t>meta::Class.abstract</t></si><si><t>belowred::Table1Row.stringValue1</t></si><si><t>belowred::Table1Row.table2Ref</t></si><si><t>Super Class 1:display:q.</t></si><si><t>Super Class 2:display:q.</t></si><si><t>Class:display:q.</t></si><si><t>Super Class 6:display:q.</t></si><si><t>Super Class 5:display:q.</t></si><si><t>Super Class 4:display:q.</t></si><si><t>Super Class 3:display:q.</t></si><si><t>Base Super Class 6:display:q.</t></si><si><t>Base Super Class 6</t></si><si><t>Base Super Class 5:display:q.</t></si><si><t>Base Super Class 5</t></si><si><t>Base Super Class 4:display:q.</t></si><si><t>Base Super Class 4</t></si><si><t>Base Super Class 3:display:q.</t></si><si><t>Base Super Class 3</t></si><si><t>Base Super Class 2:display:q.</t></si><si><t>Base Super Class 2</t></si><si><t>Base Super Class 1:display:q.</t></si><si><t>Base Super Class 1</t></si><si><t>Base Class:display:q.</t></si><si><t>Property 1:src</t></si><si><t>Test stringToBusiness</t></si><si><t>Test CamelCaseUpper</t></si><si><t>Test camelCaseToBusiness</t></si><si><t>camelCaseUpper(s)  = businessToCamelCaseUpper(stringToBusiness(s)), </t></si><si><t xml:space="preserve">camelCaseToBusiness(
+businessToCamelCaseUpper(
+stringToBusiness(X))) = 
+stringToBusiness(X) </t></si><si><t>camelCaseLower(s)  = businessToCamelCaseLower(stringToBusiness(s))</t></si><si><t>Function - Owning Property</t></si><si><t>Parameter - Owning Function</t></si><si><t>Property - Owning Class</t></si><si><t>Branch of Table</t></si><si><t>Branch of Table:src</t></si><si><t>Create Branch</t></si><si><t>File Name</t></si><si><t>Version</t></si><si><t>veri.excel</t></si><si><t>v1.41</t></si><si><t>Date Tag</t></si><si><t>Change Log</t></si><si><t>Merge Branch</t></si><si><t>Branch of Document</t></si><si><t>Freeze Version</t></si><si><t>o We where able to use the transfer code to do a "branch" of a table, and have ideas how to automate it.
+o The transfer code is VERY slow.
+o As well we found another error in camelCaseUpper, for which we entered a test case.
+o We introduced Document Management with a table of DocumentVersions, where we have
+  o standardized filenames 
+  o Branches of document
+  o Freezed Version</t></si><si><t>Update LHS - Mode</t></si><si><t>Update LHS - Feature:src</t></si><si><t>Cast:src</t></si><si><t>Property 2:src</t></si><si><t>Property 1 Super Class 6:display:q.</t></si><si><t>Property 1 Super Class 6</t></si><si><t>Property 1 Super Class 5:display:q.</t></si><si><t>Property 1 Super Class 5</t></si><si><t>Property 1 Super Class 4:display:q.</t></si><si><t>Property 1 Super Class 4</t></si><si><t>Property 1 Super Class 3:display:q.</t></si><si><t>Property 1 Super Class 3</t></si><si><t>Property 1 Super Class 2:display:q.</t></si><si><t>Property 1 Super Class 2</t></si><si><t>Property 1 Super Class 1:display:q.</t></si><si><t>Property 1 Super Class 1</t></si><si><t>Property 1 Class:display:q.</t></si><si><t>sfasdfsdfsa1</t></si><si><t>sfasdfsdfsa2</t></si><si><t>v1.42</t></si><si><t>o added some more rules logic</t></si><si><t>Parameter - Business Key</t></si><si><t>Property - Using Property</t></si><si><t>v1.43</t></si><si><t>o got rid of default parameters</t></si><si><t>Function - Parameters Display</t></si><si><t>meta::Table.branchofTable</t></si><si><t>meta::Table.createBranch</t></si><si><t>Containing Class</t></si><si><t>Test Number</t></si><si><t>Property 3:src</t></si><si><t>Property 2 Super Class 6:display:q.</t></si><si><t>Property 2 Super Class 6</t></si><si><t>Property 2 Super Class 5:display:q.</t></si><si><t>Property 2 Super Class 5</t></si><si><t>Property 2 Super Class 4:display:q.</t></si><si><t>Property 2 Super Class 4</t></si><si><t>Property 2 Super Class 3:display:q.</t></si><si><t>Property 2 Super Class 3</t></si><si><t>Property 2 Super Class 2:display:q.</t></si><si><t>Property 2 Super Class 2</t></si><si><t>Property 2 Super Class 1:display:q.</t></si><si><t>Property 2 Super Class 1</t></si><si><t>Property 2 Class:display:q.</t></si><si><t>Line As Text</t></si><si><t>Reference - Excel Formula for Display</t></si><si><t>Reference - Referenced Excel Table</t></si><si><t>Type Super Type 1</t></si><si><t>Type Super Type 4</t></si><si><t>Type Super Type 3</t></si><si><t>Type Super Type 2</t></si><si><t>Type Super Type 7</t></si><si><t>Type Super Type 6</t></si><si><t>Type Super Type 5</t></si><si><t>Reference - Refering Column in Excel</t></si><si><t>Feature:src</t></si><si><t>Type Derived</t></si><si><t>Base Type</t></si><si><t>Feature Type</t></si><si><t>Base as Parameter</t></si><si><t>Base Type Kind</t></si><si><t>Feature Base Type Kind</t></si><si><t>Property 1 Type</t></si><si><t>Property 1 Type Kind</t></si><si><t>Property 2 or Cast Type</t></si><si><t>Property 2 or Cast Type Kind</t></si><si><t>Referencce - VBA for Id Change in Subtype</t></si><si><t>Reference - VBA for Id Change in Supertype</t></si><si><t>Class - Generalization</t></si><si><t>Reference - Code</t></si><si><t>Feature - VBA</t></si><si><t>Feature - VBA Header</t></si><si><t>Feature - VBA Type</t></si><si><t>Containing Class:display</t></si><si><t>Name or Type Camel Case Lower</t></si><si><t>Display without Class</t></si><si><t>Function - Parameters in VBA Header</t></si><si><t>Type Derived:display</t></si><si><t>Rule Code</t></si><si><t>VBA Code</t></si><si><t>Excel Formula</t></si><si><t>Columns</t></si><si><t>_Column</t></si><si><t>Column</t></si><si><t>meta::Object.subPackage</t></si><si><t>Sub Package</t></si><si><t>Owning Table</t></si><si><t>Position</t></si><si><t>Parameter - Position</t></si><si><t>Label:backup:previous</t></si><si><t>Owning Table Excel Name</t></si><si><t>Property Owning Class</t></si><si><t>Owning Table Instances Class</t></si><si><t>Instances Class</t></si><si><t>Property Owning Class is Specialization of Instance Class</t></si><si><t>Property Owning Class is Instance Class or Generalization</t></si><si><t>Semantics Case</t></si><si><t>Property Changeable</t></si><si><t>Word</t></si><si><t>display</t></si><si><t>derive</t></si><si><t>meta::Object.display</t></si><si><t>Property Name</t></si><si><t>Changeable</t></si><si><t>Property Kind</t></si><si><t>Generalization 1</t></si><si><t>Generalization 4</t></si><si><t>Generalization 3</t></si><si><t>Generalization 2</t></si><si><t>Generalization 6</t></si><si><t>Generalization 5</t></si><si><t>Is From Specialization 1</t></si><si><t>Is From Specialization 2</t></si><si><t>Is From Specialization 3</t></si><si><t>Is From Specialization 4</t></si><si><t>Is From Specialization 5</t></si><si><t>Is From Specialization 6</t></si><si><t>Property Owning Class Name</t></si><si><t>Class - Abstract</t></si><si><t>Feature - Arity</t></si><si><t>Property - Changeable</t></si><si><t>meta::Table.instancesClass</t></si><si><t>Excel Formula - Target Property</t></si><si><t>VBA Code - Target Module</t></si><si><t>Matched Patern 1:src</t></si><si><t>Matched Pattern 1</t></si><si><t>Template Begin</t></si><si><t>Template Middle</t></si><si><t>Template End</t></si><si><t>Update LHS - Feature</t></si><si><t>Source Table</t></si><si><t>Match Key Column 1</t></si><si><t>Match Key Column 2</t></si><si><t>Match Key Column 3</t></si><si><t>Match Key Column 4</t></si><si><t>Match Key Column 5</t></si><si><t>Order Column</t></si><si><t>Template Parameter Column 1</t></si><si><t>Template Parameter Column 2</t></si><si><t>Template Parameter Column 3</t></si><si><t>Matched Pattern 2:src</t></si><si><t>Matched Pattern2</t></si><si><t>Matched Pattern 2 Template Column</t></si><si><t>Matched Pattern 1 Template Column</t></si><si><t>Match Filter Column 1</t></si><si><t>Match Filter Column 2</t></si><si><t>Where Clause</t></si><si><t>Matched Pattern 1 Filter Value 1</t></si><si><t>Matched Pattern 1 Filter Value 2</t></si><si><t>Matched Pattern 2 Filter Value 1</t></si><si><t>Matched Pattern 2 Filter Value 2</t></si><si><t>_ExcelTable</t></si><si><t>Excel Table - Excel Name</t></si><si><t>Excel Table - Sheet Name</t></si><si><t>_ExcelColumn</t></si><si><t>Excel Column - Label Overwrite</t></si><si><t>Excel Column - Label</t></si><si><t>Excel Column - Label Actual</t></si><si><t>Stored Column Position</t></si><si><t>Excel Column - Excel Formula</t></si><si><t>Feature - VBA Code</t></si><si><t>Feature - Manual VBA Header</t></si><si><t>Feature - Manual VBA Body</t></si><si><t>Feature - VBA Body</t></si><si><t>meta::Parameter.owningFunction</t></si><si><t>CORRECTION camelCaseUpper</t></si><si><t>CORRECTIOON camelCaseToBusiness</t></si><si><t>_Snippet</t></si><si><t>_ModuleSnippet</t></si><si><t>_ClassSnippet</t></si><si><t>_FormSnippet</t></si><si><t>Snippet</t></si><si><t>meta::Snippet.snippet</t></si><si><t>_Snippets</t></si><si><t>Snippets</t></si><si><t>util</t></si><si><t>_DocumentVersionsRowTemplate</t></si><si><t>_ClassifiersRowTemplate</t></si><si><t>_TypedElementsRowTemplate</t></si><si><t>_ExcelTabSnippet</t></si><si><t>43f63047-22d9-429c-8b1c-d622f54b29ba</t></si><si><t>67c33697-15b1-4752-aeee-0b9b588defc4</t></si><si><t>972cd4cd-25b0-4b80-96f9-eab4bfd32907</t></si><si><t>1038d403-a822-4c34-93d0-0f18ac6a9ef1</t></si><si><t>3aec7239-2376-415d-b58c-5a4b1925383a</t></si><si><t>Table 2 Ref STORED</t></si><si><t>Test stringToBusiness STORED</t></si><si><t>Test CamelCaseUpper STORED</t></si><si><t>Test camelCaseToBusiness STORED</t></si><si><t>camelCaseLower(s)  = businessToCamelCaseLower(stringToBusiness(s)) STORED</t></si><si><t>camelCaseUpper(s)  = businessToCamelCaseUpper(stringToBusiness(s)),  STORED</t></si><si><t>camelCaseToBusiness(
+businessToCamelCaseUpper(
+stringToBusiness(X))) = 
+stringToBusiness(X)  STORED</t></si><si><t>Test FunctionToBeGenerated STORED</t></si><si><t>_PackageDocumentation</t></si><si><t>Package Documentation</t></si><si><t>Excel Formula for Column "Excel Column - Label Actual" of Table Columns</t></si><si><t xml:space="preserve">ExceFormula Previous Line </t></si><si><t>Property ID from Column Label</t></si><si><t>Package Display</t></si><si><t>Topic Order</t></si><si><t>Topic</t></si><si><t>_PackgeDocumentation</t></si><si><t>Titel and Subtitle</t></si><si><t>Layer 0: Snippets
+Basic functionality to move macros to data, and to delete data rows.</t></si><si><t>Introduction</t></si><si><t xml:space="preserve">With "Layer 0: Snippets", VBA code is moved into the data, or from that data, in the form of Snippets, the code is generated. Further one can automatically delete all data rows of an excel, just keeping one empty template row, to maintain the Excel formulas and formatting, both static and conditional.
+
+With layer 0 functionality, one can send into an organisation any Excel with macros as a version without macros. There is functionality that automates extraction of macros in a table of snippets and generation of macros from such a table. In some organization, this code, accessing the "VBA Project Object Model"  is not allowed, and thus one may have to do the copy of snippets to modules, classes, forms, and the excel-tab VBA code by hand. 
+
+For Layer 0, we introduced a new class Snippet, and a new table Snippets, which holds instances of class Snippet, which has the minimal columns to allow to consider their package and subpackages column to be a matched pattern, with their Line column the sorting column, and their Snippet column being the instantiated code template. Further, Layer 0 provides two simple functions, Data From Code and Code from Data, as well as code for deleting the data. The details are in the definition of class Snippet, its subclasses for different kind of VBA code, and the defintions of the main and sub functionality of functions of package layer 0 in the TypedElements table, in the corresponding Functions entries.
+
+
+
+
+
+</t></si><si><t>Background</t></si><si><t>Wiki Definition of Snippet:
+In programming practice, "snippet" refers narrowly to a portion of source code that is literally included by an editor program into a file, and is a form of copy and paste programming.[2] This concrete inclusion is in contrast to abstraction methods, such as functions or macros, which are abstraction within the language. Snippets are thus primarily used when these abstractions are not available or not desired, such as in languages that lack abstraction, or for clarity and absence of overhead.
+
+Snippets are similar to having static preprocessing included in the editor, and do not require support by a compiler. On the flip side, this means that snippets cannot be invariably modified after the fact, and thus is vulnerable to all of the problems of copy and paste programming. For this reason snippets are primarily used for simple sections of code (with little logic), or for boilerplate, such as copyright notices, function prototypes, common control structures, or standard library imports.</t></si><si><t>Details</t></si><si><t>The other layers dealing with code generation, "Layer2: VBA Code", and "Layer 4: Patterns and Templates", will generate the code not only directly, but as well into snippets of layer 0, to allow such hand copy past, in situations where both macros cannot be sent into an organization, and the automation of layer 0, using the excel VBA Object model cannot be triggered. Therfore, one has to carefully balance splitting of code in various packages, resulting in various modules, classes, and other VBA artifacts, and having the code in as few VBA artifacts as possible, in order to allow copy-paste by hand of code from snipptes to the places where Excel stored macros. A technical limitation, is that per snippet, only 32k long string of macro code is allowed.</t></si><si><t>Data From Code</t></si><si><t>Layer0.dataFromCode
+This creates the Snippets table, if it does not yet exist, takes all VBA modules and classes (and ...) of an excel sheet, splits the modules in chunks of less then 256 chars (making sure to split ahead of every newly starting function...), and creates entries in the Snippets table, for each of these chunks, using the package and subpackage column to indicate from which VBA module it came:
+- if the VBA module was "main", then the package and subpackage are empty
+- if the VBA module was "util", then package is util, and subpackage is empty
+- if the VBA module was "first_second_third", the package is first, and subpackage is ::second::third
+- otherwise, the package is "util" and the subpackage is exactly the name of the VBA module, without starting ::
+TEMPORARY if the VBA was not a module but a class, then, split the module name by the first underscore, set the first element of the name as package, then for the second, start with ::, and then the rest of the class name, with _ replaced with :: 
+Then for the Kind column, set it to _ModuleSnippet if it was a VBA module, and to _ClassSnippet if it was a VBA Class.
+
+Then do this for all chunks created from the same class or module, and set their Line property to 1, 2, 3,....</t></si><si><t>Code from Data.</t></si><si><t>Layer0.codeFromData
+Here we turn it around. The idea is, that for ANY Excel sheet with macro (.xlsm), you can apply Layer0.dataFromCode, and it moves all VBA into the Snippet column of Snippet entries of kind _ModuleSnippet or _ClassSnippet, in chunks smaller 256, numbered by Line.
+Then you store the sheet as Excel WITHOUT macro (.xlsx), including this new Snippetstable, and send it into any company. Then inside the company you store it as .xlsm. Then you manually use the Snippets for codeToData and dataToCode to create module "util_layer0_snippets" manually, and then you  trigger Layer0.codeFromData, and it recreates exactly the same VBA Code as before.
+
+Thus what is the specification of Layer0.codeFromData?
+
+1 It looks for a table called Snippets, or if it does not find one, a table including the word Snippets in its name.
+2 It sorts this table by columns Package, Subpackage, and Line alphabetically
+3 then it iterates over all the rows, and appends the content of column Snippet into a VBA module or class defined as follows:
+- if the Kind:src column of the row is "_ModuleSnippet" it appends to a VBA module, if the Kind:src column of the row is "_ClassSnippet" it appends to a VBA Class.
+- if package and subpackage are empty, it appends to VBA module/class named "main"
+- if package is "util", and subpackage is empty, it appends to VBA module/class named "util"
+- if  the package is "first", and subpackage is "::second::third", it appends to VBA module/class named "first_second_third"
+- if the package is "util" and subpackage starts not with ::, but is ANYSTRING, then it appends to VBA module/class named "ANYSTRING"</t></si><si><t>finance</t></si><si><t>_PD01</t></si><si><t>_PD04</t></si><si><t>_PD05</t></si><si><t>_PD06</t></si><si><t>_PD02</t></si><si><t>_PD03</t></si><si><t>_PD07</t></si><si><t>Overview</t></si><si><t>This is the finance example, minimal, consisting of Porfolio, Position, Security, and showing two rules for calculating the value of a postion and a porfolio.</t></si><si><t>Order</t></si><si><t>Security</t></si><si><t>Owner</t></si><si><t>Value</t></si><si><t>Amount</t></si><si><t>Valuation</t></si><si><t>Trading Symbol</t></si><si><t>Price</t></si><si><t>finance::Porfolio.value</t></si><si><t>finance::Position.amount</t></si><si><t>finance::Position.valuation</t></si><si><t>finance::Security.tradingSymbol</t></si><si><t>finance::Security.price</t></si><si><t>Portfolio</t></si><si><t>Reference - Opposite</t></si><si><t>finance::Portfolio</t></si><si><t>finance::Position</t></si><si><t>finance::Security</t></si><si><t>Positions</t></si><si><t>Securities</t></si><si><t>Portfolios</t></si><si><t>_PorfoliosRowTemplate</t></si><si><t>_PositionsRowTemplate</t></si><si><t>_SecuritiesRowTemplate</t></si><si><t>Update - Name</t></si><si><t>My XYZ Column</t></si><si><t>myxyzpackage</t></si><si><t>myxyzpackage::MyXYZ_Object</t></si><si><t>Excel Table - Explicit Sheet Name</t></si><si><t>layer0</t></si><si><t>functions</t></si><si><t>relationtootherlayers</t></si><si><t>background</t></si><si><t>_PD08</t></si><si><t>In the myxyzpackage we introduce a minimal usage of our methodology. All new things are marked with "my XYZ" and we do:
+- a new sheet "My XYZ Sheet", with a new table, having the columns of the Object class, plus one column "My XYZ Column"
+- an entry in table Table for that new table, named "My XYZ Objects", indicating, that the objects in that new table are inteded to by of type My XYZ Object
+- an entry in table Column, for the new column "My XYZ Column"
+- an entry in table Classifiers, for the new class "My XYZ Object"
+- an entry in the table Properties, adding a property "My XYZ Property" to the new class, as definiton for the new column.
+To see the Excel table, you need to open the name manager with ctrl-f3, and to actually create a table like this, you need to select it and then home/format as table.
+
+In Layer 3, there is functionality to create all of this for you, for a new table and new columns, and functionality to reflect full tables with columns in the Classifier/Properties, respectively to generate new tables from models in Classifiers/Columns.</t></si><si><t>Filter1</t></si><si><t>Filter2</t></si><si><t>Template</t></si><si><t>Other</t></si><si><t>My XYZ Table</t></si><si><t>tabletransfer</t></si><si><t>Table Transfer
+Basic performance optimized functionality to transfer the stored columns of one table into the equally named columns of another table.</t></si><si><t>This package contains the VBA code which does basic performance optimized functionality to transfer the stored columns of one table into the equally named columns of another table. In order to make this work smoothly, it as well enforces basic desired properties of an Excel sheet:
+o Every Row (Object) has an ID column, defining its identity.
+o every Row either has a stored value, or an Excel formula, that is the same for the whole column.
+The algorithms are storing transfer and fixing of these properties on a row level, in additional columns.</t></si><si><t>This function, takes as input a table name (e.g. the name of an Excel table, as you see it with ctrl. F3), and then creates a copy of it, only copying the stored columns. TOBECONTINUED</t></si><si><t>Copy Table</t></si><si><t>_TypedModelElement</t></si><si><t>_PD00</t></si><si><t>layer*</t></si><si><t>Epic</t></si><si><t>Testing of Busines to Camel to Business</t></si><si><t>As a veri.excel user, I want to have an easy to use means, to do references from one table to the other, in form of a column that storeds the UUID of the referenced row of the referenced tables, but as well in form of a column, that displays a name-like, easy to recognize identifier of that referenced row (remark: that name-like identifiers is declared by so called "display" rules in the Rules sheet of veri.excel, or as simple variant, just declaring a Display property of the referenced rows.) In order to allow changes of the properties used in the name of the referenced rows, without loosing that references, we shall only store the UUID, but allow changing the reference by overwriting the name-like identifier.
+
+Therefore, as a veri.excel user, I want to add a property to a class, and declare its type to be another class (e.g. create a reference property), such that in all tables containing instances of this class two columns are added, one where I can store the ID of an object reference by this new property, and one which displays a name-like easy to read identifier of this referenced object (e.g. the identifier calculated with the display rule, or as a simple variant the identifier given by the property of the referenced class denoted as "Display property") and the behavior of the two columns is, that if I change that name-like identifier, my veri.excel sheet automatically searches for the ID of the object identified by this new name-like identifier, and stores it in the column storing the ID.
+
+Technically, the column with the name-like identifier has a formula calculating this from the column with the UUID, and if we overwrite this formula with the name of a different to be referenced row, then VBA code registered in the Excel Tab (see as well Excel Tab Snippet) will calculate the new UUID, then overwrite the UUID storing column with this, and rewrite the same formula in this name-like identifier column. In the Columns table, both of these columns are refering to the newly introduced reference, but their "Semantic Case" is different, src for the column storing the UUID, and "display" for the one displaying the name-like identifier.
+
+As a result, in Layer 3, we enter a reference, and generate the columns and snippet. Then Layer 2 will create from the colums the new actual columns, and layer 0 will create from the snippets the actual code. Then we go from simple adding to synchronization on all layers: so the columns are synchronized and the properties are synchronized with each other, and the columns in the Columns sheet are two-way synchronized with the actual existing columns in the sheet.</t></si><si><t>Class - Display Property</t></si><si><t>Class - Business ID Property</t></si><si><t>Class - Business ID Property:src</t></si><si><t>Display Qualified</t></si><si><t>Do Action Rule Details</t></si><si><t>VBA Function Step 1</t></si><si><t>VBA Function Step 2</t></si><si><t>VBA Function Step 3</t></si><si><t>PackageDocumentation</t></si><si><t>layer1</t></si><si><t>repopulateTablesAndColumsMetadata</t></si><si><t>createAndComplementTablesAndColumns</t></si><si><t xml:space="preserve">"repopulateTablesAndColumnsMetadata" simply makes sure, that we have a table Tables, and a table Columns, in which is reflected what tables and columns the Excel sheet has. It can be applied to any excel sheet, or one already having content and behavior managed with Classifiers, TypedElements, and Rules tables, or one having generation of behavior managed with TablePatterns and CodeTemplates.
+This VBA function synchronizes an Excel sheet with the Tables and Columns tables, ensuring they reflect the current structure of the sheet. It follows these key steps:
+
+1. Backup Existing Data: If Tables or Columns already exist, they are backed up as Tables_BackupYYYYMMDDHHMMSS.
+2. Create Base Tables: If the tables do not exist, they are initialized from a Tables/Columns_TemplateVERSION to ensure formula consistency.
+3. Extract Current Structure: The function generates Tables_ExtractYYYYMMDDHHMMSS and Columns_ExtractYYYYMMDDHHMMSS, capturing metadata from all tables except those containing _Backup, _Extract, _Branch, _Template, or _Nonmanaged in their names.
+4. Validate Table Structure: Ensures that the Tables and Columns tables contain at least the columns found in the extracted versions.
+5. Populate Extract Tables: The function iterates through each Excel table and column, mapping them into the extract tables while applying naming conventions and handling formulas carefully.
+6. Merge Updates: The new extracted data is merged into the main Tables and Columns tables.
+7. Remove Obsolete Rows: Any rows in Tables and Columns that do not exist in the extract tables are deleted, ensuring only current data remains.
+</t></si><si><t>"createAndComplementTablesAndColumns" takes the information in the Tables and Columns tables, and creates or complements all tables with what is written in these tables. An exception are the rows and stored columns in the tables Tables and Columns, which are only created/set by the first function of Layer 1. Again, it can be applied to any excel sheet, or one already having content and behavior managed with Classifiers, TypedElements, and Rules tables, or one having generation of behavior managed with TablePatterns and CodeTemplates.
+
+This function takes the content of Table and Columns tables, and reflects it in the excel. It can only be used if Tables and Columns tables are existing, and it is recommended to use the first algorithm first. HOWEVER, if later we generate new columns and tables from Classfiers and Properties, we will NOT use the first algorithm first, or rather we will use it first, then generate/rename new Tables/Columns from Classifiers/Properties (including generation of Excel Formula in Excel Column - Excel Formula), and then directly apply this second algorithm!
+
+Key steps:
+
+1. Validate Table Existence:
+Checks whether each entry in Tables has a corresponding Excel tab and table.
+If the table exists but the tab does not, the tab is renamed.
+If the tab exists but the table name differs, the table is renamed.
+
+2. Create or Update Tables and Columns:
+If a table does not exist on its expected tab, it is created with standard formatting.
+For each column in Columns, the function:
+Tries to locate the column in the table using Excel Column - Label (not Excel Column - Label Overwrite).
+If the column does not exist, it inserts a new column at the correct position based on Position metadata.
+If the column has an associated formula (Excel Column - Excel Formula), a backup is created if the existing column contains different formulas or values. The formula is then standardized and applied.
+
+3. Maintain Order and Formatting:
+Ensures column order and formatting are preserved while inserting new columns where necessary.
+Updates Position and Stored Position metadata in Tables and Columns.
+Runs the first algorithm again (repopulateTablesAndColumnsMetadata) to ensure consistency.</t></si><si><t xml:space="preserve">Layer 1: Tables and Columns
+Basic functionalities to synchronize between the actual structure of a sheet consisting of tables and their columns (as visible in the name manager, called with ctrl F3) in two specific tables called "meta_Tables" and "meta_Columns". Those two tables can be created from scratch, or the whole Excel sheet can be recreated, just from the content of these two tables. The layer takes into account the pre-existence of entries on both sides, and applies a sophisticated synchronization strategy, to integrate, and not loose information changed or added on either side. </t></si><si><t>In this layer, we synchronize between the actually existing tables and columns in an Excel sheet, and the content of two specific tables meta_Tables and meta_Columns, which hold the meta-data of all existing tables and columns. The corresponding VBA functions are created in package Layer one, and result in their source code in VBA module Layer1 (via Snippets as introduced in Layer0. The layer is established by two functions "repopulateTablesAndColumnsMetadata" and "createAndComplementTablesAndColumns". Both functions will not destroy any existing tables, columns and formulas in it, and can be applied to any version of our veri.excel. The way how newest functonality of a veri.excel is injected in applying these two functions to a user defined sheet is simply by copying the Tables and Columns tables of our newest version of veri.excel and renaming them to Tables/Columns_ExtractYYYYMMDDHHMMSS. For such a user defined sheet, the first function must be used first, to create useful Tables and Columns tables.</t></si><si><t>Reference - Display and Select Property</t></si><si><t>ModuleSnippet</t></si><si><t>ClassSnippet</t></si><si><t>FormSnippet</t></si><si><t>ExcelTabSnippet</t></si><si><t>belowred_Table1Rows</t></si><si><t>belowred_Table2Rows</t></si><si><t>meta_Classifiers</t></si><si><t>meta_TypedModelElements</t></si><si><t>meta_Tables</t></si><si><t>meta_Snippets</t></si><si><t>meta_PackageDocumentation</t></si><si><t>meta_Columns</t></si><si><t>finance_Portfolios</t></si><si><t>finance_Positions</t></si><si><t>finance_Securities</t></si><si><t>meta_Rules</t></si><si><t>meta_Literals</t></si><si><t>myxyzpackage_MyXYZ_Objects</t></si><si><t xml:space="preserve">Private </t></si><si><t xml:space="preserve">       referedColumnName = "Display"
+        'check if the change is in the actual table and column to avoid bugs
+        
+        'START OF PARAMETRIZATION'
+        If referingTableName = "meta_Classifiers" Then
+            If referingColumnName = "Kind" </t></si><si><t>Then
+                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            E</t></si><si><t>nd If
+            If referingColumnName = "Class - Generalization" Then
+                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, ref</t></si><si><t xml:space="preserve">eringColumnName, referedTableName, referedColumnName)
+            End If
+            If referingColumnName = "Class - Display Property" Then
+                referedTableName = "meta_TypedModelElements"
+                referedColumnName = "Display"
+        </t></si><si><t xml:space="preserve">        Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+            If referingColumnName = "Class - Business ID Property" Then
+                referedTableName = </t></si><si><t>"meta_TypedModelElements"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+
+        End If
+        'EN</t></si><si><t xml:space="preserve">DO OF PARAMETRIZATION'
+    End If
+End Sub
+
+</t></si><si><t xml:space="preserve">       referedColumnName = "Display"
+        'check if the change is in the actual table and column to avoid bugs
+        
+        'START OF PARAMETRIZATION'
+        If referingTableName = "meta_TypedModelElements" Then
+            If referingColumnName = </t></si><si><t xml:space="preserve">"Kind" Then
+                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+      </t></si><si><t xml:space="preserve">      End If
+            If referingColumnName = "Property - Owning Class" Then
+                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableN</t></si><si><t>ame, referingColumnName, referedTableName, referedColumnName)
+            End If
+            If referingColumnName = "Type" Then
+                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call Static</t></si><si><t xml:space="preserve">Code.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+            If referingColumnName = "Property - Default Parameters" Then
+                referedTableName = "meta_Literals"
+  </t></si><si><t xml:space="preserve">              referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+            If referingColumnName = "Property - Using P</t></si><si><t>roperty" Then
+                referedTableName = "meta_TypedModelElements"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnNam</t></si><si><t>e)
+            End If
+            If referingColumnName = "Reference - Opposite" Then
+                referedTableName = "meta_TypedModelElements"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, r</t></si><si><t>eferingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+            If referingColumnName = "Parameter - Owning Function" Then
+                referedTableName = "meta_TypedModelElements"
+                referedColumnN</t></si><si><t xml:space="preserve">ame = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+        End If
+        'ENDO OF PARAMETRIZATION'
+    End If
+End Sub
+</t></si><si><t xml:space="preserve">       referedColumnName = "Display"
+        'check if the change is in the actual table and column to avoid bugs
+        
+        'START OF PARAMETRIZATION'
+        If referingTableName = "meta_Tables" Then
+            If referingColumnName = "Kind" Then
+</t></si><si><t xml:space="preserve">                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+            End If
+            If referingColumnName = "Instances Class" Then
+                referedTableName = "meta_Classifiers"
+                referedC</t></si><si><t>olumnName = "Display"
+            End If
+            'If referingColumnName = "Generalization" Then'
+                'referedTableName = "Property"'
+                'referedColumnName = "Property Name"'
+            'End If '
+        End If
+        'ENDO OF</t></si><si><t xml:space="preserve"> PARAMETRIZATION'
+        
+        If referedTableName [<][>] "" Then
+            Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+        End If
+    End If
+End Sub
+</t></si><si><t xml:space="preserve">       referedColumnName = "Display"
+        'check if the change is in the actual table and column to avoid bugs
+        
+        'START OF PARAMETRIZATION'
+        If referingTableName = "meta_Columns" Then
+            If referingColumnName = "Kind" Then</t></si><si><t xml:space="preserve">
+                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End I</t></si><si><t>f
+            If referingColumnName = "Owning Table" Then
+                referedTableName = "meta_Tables"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, re</t></si><si><t>feredTableName, referedColumnName)
+            End If
+        End If
+        'ENDO OF PARAMETRIZATION'
+    End If
+End Sub</t></si><si><t xml:space="preserve">       referedColumnName = "Display"
+        'check if the change is in the actual table and column to avoid bugs
+        
+        'START OF PARAMETRIZATION'
+        If referingTableName = "meta_Rules" Then
+            If referingColumnName = "Kind" Then
+ </t></si><si><t xml:space="preserve">               referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+</t></si><si><t xml:space="preserve">            If referingColumnName = "Class" Then
+                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, refere</t></si><si><t>dTableName, referedColumnName)
+            End If
+            If referingColumnName = "Feature" Then
+              referingColumnNameForBaseTypeKind = "Feature Base Type Kind"
+              referedTableName = "meta_TypedModelElements"
+              refered</t></si><si><t>ColumnName = "Display"
+              referingColumnNameForQualifier1 = "Class:display:q."
+              referingColumnNameForQualifier2 = "Super Class 1:display:q."
+              referingColumnNameForQualifier3 = "Super Class 2:display:q."
+              re</t></si><si><t>feringColumnNameForQualifier4 = "Super Class 3:display:q."
+              referingColumnNameForQualifier5 = "Super Class 4:display:q."
+              referingColumnNameForQualifier6 = "Super Class 5:display:q."
+              referingColumnNameForQualifier7 =</t></si><si><t xml:space="preserve"> "Super Class 6:display:q."
+              'TODO Create variant,accepting global functions (from package util), if referingColumnNameForQualifier1(Class:display:q.) starts with util.
+              Call StaticCode.updateIdOnNameChangeTrySevenLevels(referingC</t></si><si><t>olumnNameForBaseTypeKind, cellRef, referingTableName, referingColumnName, referingColumnNameForQualifier1, referingColumnNameForQualifier2, referingColumnNameForQualifier3, referingColumnNameForQualifier4, referingColumnNameForQualifier5, referingColumnNam</t></si><si><t>eForQualifier6, referingColumnNameForQualifier7, referedTableName, referedColumnName)
+            End If
+            If referingColumnName = "Property 1" Then
+              referingColumnNameForBaseTypeKind = "Base Type Kind"
+              referedTableName</t></si><si><t xml:space="preserve"> = "meta_TypedModelElements"
+              referedColumnName = "Display"
+              referingColumnNameForQualifier1 = "Base Class:display:q."
+              referingColumnNameForQualifier2 = "Base Super Class 1:display:q."
+              referingColumnNam</t></si><si><t>eForQualifier3 = "Base Super Class 2:display:q."
+              referingColumnNameForQualifier4 = "Base Super Class 3:display:q."
+              referingColumnNameForQualifier5 = "Base Super Class 4:display:q."
+              referingColumnNameForQualifier6 =</t></si><si><t xml:space="preserve"> "Base Super Class 5:display:q."
+              referingColumnNameForQualifier7 = "Super Class 6:display:q."
+              'TODO Create variant,accepting global functions (from package util), if referingColumnNameForQualifier1(Base Class:display:q.) starts </t></si><si><t>with util.
+              Call StaticCode.updateIdOnNameChangeTrySevenLevels(referingColumnNameForBaseTypeKind, cellRef, referingTableName, referingColumnName, referingColumnNameForQualifier1, referingColumnNameForQualifier2, referingColumnNameForQualifier3</t></si><si><t xml:space="preserve">, referingColumnNameForQualifier4, referingColumnNameForQualifier5, referingColumnNameForQualifier6, referingColumnNameForQualifier7, referedTableName, referedColumnName)
+            End If
+            If referingColumnName = "Property 2" Then
+            </t></si><si><t xml:space="preserve">  referingColumnNameForBaseTypeKind = "Property 1 Type Kind"
+              referedTableName = "meta_TypedModelElements"
+              referedColumnName = "Display"
+              referingColumnNameForQualifier1 = "Property 1 Class:display:q."
+              </t></si><si><t xml:space="preserve">referingColumnNameForQualifier2 = "Property 1 Super Class 1:display:q."
+              referingColumnNameForQualifier3 = "Property 1 Super Class 2:display:q."
+              referingColumnNameForQualifier4 = "Property 1 Super Class 3:display:q."
+            </t></si><si><t xml:space="preserve">  referingColumnNameForQualifier5 = "Property 1 Super Class 4:display:q."
+              referingColumnNameForQualifier6 = "Property 1 Super Class 5:display:q."
+              referingColumnNameForQualifier7 = "Property 1 Class 6:display:q."
+              
+ </t></si><si><t xml:space="preserve">             Call StaticCode.updateIdOnNameChangeTrySevenLevels(referingColumnNameForBaseTypeKind, cellRef, referingTableName, referingColumnName, referingColumnNameForQualifier1, referingColumnNameForQualifier2, referingColumnNameForQualifier3, referingCo</t></si><si><t>lumnNameForQualifier4, referingColumnNameForQualifier5, referingColumnNameForQualifier6, referingColumnNameForQualifier7, referedTableName, referedColumnName)
+            End If
+
+            If referingColumnName = "Cast" Then
+                referedTableN</t></si><si><t>ame = "meta_Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+            If referingColum</t></si><si><t xml:space="preserve">nName = "Property 3" Then
+              referingColumnNameForBaseTypeKind = "Property 2 or Cast Type Kind"
+              referedTableName = "meta_TypedModelElements"
+              referedColumnName = "Display"
+              referingColumnNameForQualifier1 </t></si><si><t>= "Property 2 Class:display:q."
+              referingColumnNameForQualifier2 = "Property 2 Super Class 1:display:q."
+              referingColumnNameForQualifier3 = "Property 2 Super Class 2:display:q."
+              referingColumnNameForQualifier4 = "Pro</t></si><si><t>perty 2 Super Class 3:display:q."
+              referingColumnNameForQualifier5 = "Property 2 Super Class 4:display:q."
+              referingColumnNameForQualifier6 = "Property 2 Super Class 5:display:q."
+              referingColumnNameForQualifier7 = "P</t></si><si><t>roperty 2 Class 6:display:q."
+              
+              Call StaticCode.updateIdOnNameChangeTrySevenLevels(referingColumnNameForBaseTypeKind, cellRef, referingTableName, referingColumnName, referingColumnNameForQualifier1, referingColumnNameForQualifier</t></si><si><t xml:space="preserve">2, referingColumnNameForQualifier3, referingColumnNameForQualifier4, referingColumnNameForQualifier5, referingColumnNameForQualifier6, referingColumnNameForQualifier7, referedTableName, referedColumnName)
+            End If
+
+       End If
+        'ENDO OF </t></si><si><t>PARAMETRIZATION'
+        
+    End If
+End Sub</t></si><si><t>meta_TablePatterns</t></si><si><t xml:space="preserve">       referedColumnName = "Display"
+        'check if the change is in the actual table and column to avoid bugs
+        
+        'START OF PARAMETRIZATION'
+        If referingTableName = "Classifiers" Then
+            If referingColumnName = "Kind" Then
+</t></si><si><t xml:space="preserve">                referedTableName = "Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+            End If
+    </t></si><si><t xml:space="preserve">        If referingColumnName = "Class - Generalization" Then
+                referedTableName = "Classifiers"
+                referedColumnName = "Display"
+                Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName</t></si><si><t>, referedTableName, referedColumnName)
+            End If
+            'If referingColumnName = "Generalization" Then'
+                'referedTableName = "Property"'
+                'referedColumnName = "Property Name"'
+            'End If '
+        End If</t></si><si><t xml:space="preserve">
+        'ENDO OF PARAMETRIZATION'
+    End If
+End Sub
+
+</t></si><si><t>meta_CodeTemplates</t></si><si><t xml:space="preserve">       referedColumnName = "Display"
+        'check if the change is in the actual table and column to avoid bugs
+        
+        'START OF PARAMETRIZATION'
+        If referingTableName = "meta_Literals" Then
+            If referingColumnName = "Kind" The</t></si><si><t xml:space="preserve">n
+                referedTableName = "meta_Classifiers"
+                referedColumnName = "Display"
+            End If
+            If referingColumnName = "Parent" Then
+                referedTableName = "meta_Literals"
+                referedColumnName </t></si><si><t>= "Display"
+            End If
+            'If referingColumnName = "Generalization" Then'
+                'referedTableName = "Property"'
+                'referedColumnName = "Property Name"'
+            'End If '
+        End If
+        'ENDO OF PARAMETRI</t></si><si><t xml:space="preserve">ZATION'
+        
+        If referedTableName [<][>] "" Then
+            Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+        End If
+    End If
+End Sub
+
+
+</t></si><si><t xml:space="preserve">       referedColumnName = "TName"
+        'check if the change is in the actual table and column to avoid bugs
+        
+        'START OF PARAMETRIZATION'
+        If referingTableName = "belowred_Table1Rows" Then
+            If referingColumnName = "Table</t></si><si><t xml:space="preserve"> 2 Ref" Then
+                referedTableName = "belowred_Table2Rows"
+                referedColumnName = "T2 Name"
+            End If
+            'If referingColumnName = "Generalization" Then'
+                'referedTableName = "Property"'
+             </t></si><si><t xml:space="preserve">   'referedColumnName = "Property Name"'
+            'End If '
+        End If
+        'ENDO OF PARAMETRIZATION'
+        
+        If referedTableName [<][>] "" Then
+            Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName,</t></si><si><t xml:space="preserve"> referedTableName, referedColumnName)
+        End If
+    End If
+End Sub</t></si><si><t>Class1</t></si><si><t xml:space="preserve">' Class1
+Option Explicit
+
+
+' </t></si><si><t xml:space="preserve">Function implementations
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Derive(selfId As String, src As Variant) As String
+    
+    resultAttribute_Derive = "Derived String"
+End Function
+
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Display(selfId As String, src As Variant) As String
+
+    resultAttribute_Display = "Displayed String"
+End Function
+
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Group(selfId As String, src As Variant) As String
+
+    resultAttribute_Group = "Grouped String"
+End Function
+
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Choices(selfId As String, src As Variant) As Variant
+
+    resultAttribute_Choices = Array("Choice1", "Choice2", "Choice3")
+End Function
+
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Constraint(selfId As String, src As Variant, trg As String) As Boolean
+
+    resultAttribute_Constraint = True
+End Function
+</t></si><si><t>Class2</t></si><si><t xml:space="preserve">' Class2
+Option Explicit
+
+
+' </t></si><si><t xml:space="preserve">Function resultAttribute_Derive(selfId As String, src As Variant) As String
+
+    resultAttribute_Derive = "Derived String from Class2"
+End Function
+
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Display(selfId As String, src As Variant) As String
+
+    resultAttribute_Display = "Displayed String from Class2"
+End Function
+
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Group(selfId As String, src As Variant) As String
+
+    resultAttribute_Group = "Grouped String from Class2"
+End Function
+
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Choices(selfId As String, src As Variant) As Variant
+
+    resultAttribute_Choices = Array("ChoiceA", "ChoiceB", "ChoiceC")
+End Function
+
+Public </t></si><si><t xml:space="preserve">Function resultAttribute_Constraint(selfId As String, src As Variant, trg As String) As Boolean
+
+    resultAttribute_Constraint = False
+End Function
+</t></si><si><t>::CreateForms</t></si><si><t xml:space="preserve">Sub CommandButton1_Click()"
+        .InsertLines .CountOfLines + 1, "    transferMode = ""normal"""
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "End Sub"
+        
+        ' Handle close button (X)
+       </t></si><si><t xml:space="preserve"> .InsertLines .CountOfLines + 1, "Private </t></si><si><t>Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)"
+        .InsertLines .CountOfLines + 1, "    If CloseMode = vbFormControlMenu Then"
+        .InsertLines .CountOfLines + 1, "        MsgBox ""Operation canceled. Program terminates."", vbCri</t></si><si><t>Sub CommandButton1_Click()"
+        .InsertLines .CountOfLines + 1, "    fulltransfer = True"
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "End Sub"
+        
+        ' ListBox1 Double Click event
+        .</t></si><si><t xml:space="preserve">InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)"
+        .InsertLines .CountOfLines + 1, "    sourceTable = Me.ListBox1.Text"
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "End Sub"
+        
+  </t></si><si><t xml:space="preserve">      ' UserForm Initialize event
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t>Sub UserForm_Initialize()"
+        .InsertLines .CountOfLines + 1, "    Dim sh As Worksheet"
+        .InsertLines .CountOfLines + 1, "    Dim tbl As ListObject"
+        .InsertLines .CountOfLines + 1, "    For Each sh In ThisWorkbook.Worksheets"
+        .I</t></si><si><t xml:space="preserve">nsertLines .CountOfLines + 1, "        For Each tbl In sh.ListObjects"
+        .InsertLines .CountOfLines + 1, "            Me.ListBox1.AddItem tbl.Name"
+        .InsertLines .CountOfLines + 1, "        Next tbl"
+        .InsertLines .CountOfLines + 1, "  </t></si><si><t xml:space="preserve">  Next sh"
+        .InsertLines .CountOfLines + 1, "End Sub"
+        
+        ' Handle close button (X)
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t>Sub CommandButton1_Click()"
+        .InsertLines .CountOfLines + 1, "    targetTable = ""no selection"""
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "End Sub"
+        
+        ' ListBox1 Double Click even</t></si><si><t xml:space="preserve">t
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)"
+        .InsertLines .CountOfLines + 1, "    targetTable = Me.ListBox1.Text"
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "End Sub"
+        
+  </t></si><si><t xml:space="preserve">Sub CommandButton1_Click()"
+        .InsertLines .CountOfLines + 1, "    source_fix = True"
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "End Sub"
+
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t>Sub CommandButton2_Click()"
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "    MsgBox ""Program terminates"""
+        .InsertLines .CountOfLines + 1, "    End"
+        .InsertLines .CountOfLines + 1, "End S</t></si><si><t xml:space="preserve">ub"
+        
+        ' Handle close button (X)
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">Sub CommandButton1_Click()"
+        .InsertLines .CountOfLines + 1, "    target_fix = True"
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "End Sub"
+
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t>::Test</t></si><si><t xml:space="preserve">
+</t></si><si><t>FastLookup</t></si><si><t xml:space="preserve">Option Explicit
+
+Private Type KeyValue
+    key As String
+    Value As Long
+End Type
+
+Private Keys() As KeyValue
+Private keyCount As Long
+
+Private </t></si><si><t xml:space="preserve">Sub Class_Initialize()
+    ReDim Keys(1 To 10) ' Start with an initial size of 10
+    keyCount = 0
+End Sub
+
+Public </t></si><si><t>Sub Add(key As String, Value As Long)
+    ' Check if key already exists
+    Dim i As Long
+    For i = 1 To keyCount
+        If Keys(i).key = key Then Exit Sub
+    Next i
+    
+    ' Add new key-value pair
+    keyCount = keyCount + 1
+    ' Resize array if ne</t></si><si><t xml:space="preserve">eded
+    If keyCount [>] UBound(Keys) Then
+        ReDim Preserve Keys(1 To keyCount + 10) ' Increase size by 10
+    End If
+    Keys(keyCount).key = key
+    Keys(keyCount).Value = Value
+End Sub
+
+Public </t></si><si><t>Function Exists(key As String) As Boolean
+    Dim i As Long
+    For i = 1 To keyCount
+        If Keys(i).key = key Then
+            Exists = True
+            Exit Function
+        End If
+    Next i
+    Exists = False
+End Function
+
+Public Property Get item(</t></si><si><t>key As String) As Long
+    Dim i As Long
+    For i = 1 To keyCount
+        If Keys(i).key = key Then
+            item = Keys(i).Value
+            Exit Property
+        End If
+    Next i
+    item = 0 ' Return 0 if key not found
+End Property
+
+Public Property</t></si><si><t xml:space="preserve"> Get AllKeys() As Variant
+    Dim result() As String
+    If keyCount [>] 0 Then
+        ReDim result(1 To keyCount)
+        Dim i As Long
+        For i = 1 To keyCount
+            result(i) = Keys(i).key
+        Next i
+    Else
+        ReDim result(0 To 0) '</t></si><si><t>CheckChange</t></si><si><t>Sub updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+Dim refTbl As ListObject
+    Application.EnableEvents = False
+    Application.Undo
+    OldFormula = cellRef.formula
+    Application.Undo
+    Appli</t></si><si><t>cation.EnableEvents = True
+    
+    Set referingTable = ActiveSheet.ListObjects(referingTableName)
+    'Set referingTableRefIdColumn = referingTable.ListColumns("Generalization ID")
+    Set referingTableRefIdColumn = referingTable.ListColumns(referingColum</t></si><si><t>nName [&] " ID")
+    referingRowIndex = getReferingRowIndex(cellRef, referingTable) 'to find out which row of the table changed
+
+    If cellRef.Value = "" Then
+        Application.EnableEvents = False
+        cellRef.formula = OldFormula
+        referingTabl</t></si><si><t>eRefIdColumn.DataBodyRange(referingRowIndex) = ""
+        Application.EnableEvents = True
+    Else
+         'Set referingTableRefNameColumn = referingTable.ListColumns("Generalization")
+         'Set referingTableRefNameQColumn = referingTable.ListColumns(</t></si><si><t>"Generalization Q")
+         Set referingTableFullPackageColumn = referingTable.ListColumns("Full Package")
+         Set referingTableRefNameColumn = referingTable.ListColumns(referingColumnName)
+         '
+         'Set referingTableRefNameQColumn = refer</t></si><si><t xml:space="preserve"> If
+              Next tbl
+         Next sht
+         Set referedTable = refTbl
+         Set referedTableIdColumn = referedTable.ListColumns("ID")
+         Set referedTableNameColumn = referedTable.ListColumns(referedColumnName)
+         Set referedTableNa</t></si><si><t xml:space="preserve">meQColumn = referedTable.ListColumns(referedColumnName [&] " Q")
+         
+         'Call </t></si><si><t>Sub to handle the change; provide cellRef (changed cell), tabel (in which sheet did the change happend
+         'id Ref (in which column the uuid is in the sheet)
+         
+         'Call first(cellRef, referingTable, referedTable, referedTableIdColumn, re</t></si><si><t>feredTableNameColumn, referedTableNameQColumn, referingTableRefIdColumn, referingTableRefNameColumn, referingTableRefNameQColumn)
+             'this module gets the changed cell, the sheet, and the location of the uuid in the sheet
+         
+         refer</t></si><si><t>ingRowNameValue = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableRefNameColumn.Index)
+         referingRowFullPackageValue = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableFullPackageColumn.Index)
+         referingRowNam</t></si><si><t>eValue = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableRefNameColumn.Index)
+         referingRowNameQValue = referingRowNameValue
+         If InStr(referingRowNameValue, "::") = 0 Then
+             referingRowNameQValue = referingRowFull</t></si><si><t>PackageValue [&] "::" [&] referingRowNameValue
+         End If
+         referingRowNameQValue = Replace(referingRowNameQValue, " ", "")
+         
+         'referingRowNameQValue = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableRefNameQColumn.</t></si><si><t>Index)
+         referedRowIndex = getMatchingRowIndex(referingRowNameQValue, referedTableNameQColumn)
+         
+         If referedRowIndex [<][>] -1 Then
+             'if yes: leave the cell in it's current status, update the ID value, replace cell value by f</t></si><si><t xml:space="preserve">ormular
+             'for that we need the changedSheet so we know which sheet the change was happening
+             referingTableRefIdColumn.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+  </t></si><si><t xml:space="preserve">       End If
+         Application.EnableEvents = False
+        cellRef.formula = OldFormula
+        Application.EnableEvents = True
+   End If
+   'ElseIf cellRef = "" Then
+    '    Application.EnableEvents = False
+    '    cellRef.Value = ""
+    '    Appli</t></si><si><t>cation.EnableEvents = True
+    '    referingTableRefIdColumn.DataBodyRange(referingRowIndex) = ""
+    'Else
+     '   'new value is not in range
+      '  'if no: reject the change
+       ' 'to reject the change and maintain a valid excel we have to reset th</t></si><si><t xml:space="preserve">e cell to the value it had before
+        ''review with LEVEND, simply do undo programmatically.
+         '
+        'oldIdValue = referingTableRefIdColumn.DataBodyRange(referingRowIndex)
+        'Set idValues = referedTableIdColumn.DataBodyRange
+        '
+</t></si><si><t xml:space="preserve">        'If oldIdValue [<][>] "" Then
+        '    idRowIndex = 0
+        '    isIdValid = False
+        '
+        '    For Each idValue In idValues
+        '        idRowIndex = idRowIndex + 1
+        '        If idValue = oldIdValue Then
+        '           </t></si><si><t xml:space="preserve"> isIdValid = True
+        '            Exit For
+        '        End If
+        '    Next idValue
+        '
+         '   If isIdValid = True Then
+         '       nameRowValue = referingTable.DataBodyRange.Cells(idRowIndex, referedTableNameColumn.Index)
+  </t></si><si><t xml:space="preserve">       '       Application.EnableEvents = False
+         '       cellRef.Value = nameRowValue
+         '       Application.EnableEvents = True
+         '   Else
+         '       Application.EnableEvents = False
+         '       cellRef.Value = ""
+         </t></si><si><t xml:space="preserve">'       Application.EnableEvents = True
+         '       referingTableRefIdColumn.DataBodyRange(referingRowIndex) = ""
+         '   End If
+        
+        'End If
+        
+   ' End If
+
+End Sub
+
+</t></si><si><t>Sub second(cellRef, referingTable, referedTableIdColumn, referedTableNameColumn, referingTableRefIdColumn, referingTableRefNameColumn)
+    referingRowIndex = getReferingRowIndex(cellRef, referingTable)
+    actionIdValue = referingTable.DataBodyRange.Cells(</t></si><si><t>referingRowIndex, referedTableIdColumn.Index)
+    
+    Set genIdValues = referingTableRefIdColumn.DataBodyRange
+    
+    
+    For Each genIdValue In genIdValues    ' go through all possible values
+        cellRowIndex = cellRowIndex + 1
+        If genIdVal</t></si><si><t xml:space="preserve">ue = actionIdValue Then
+            
+            referingTableRefNameColumn.DataBodyRange(cellRowIndex) = cellRef
+        End If
+    Next genIdValue
+    
+End Sub
+
+
+
+Public </t></si><si><t xml:space="preserve">Function getReferingRowIndex(cellRef, referingTable)
+    getReferingRowIndex = cellRef.row - referingTable.HeaderRowRange.row
+End Function
+
+
+
+Public </t></si><si><t>Function getMatchingRowIndex(queryValue, listCol)
+    Set colValues = listCol.DataBodyRange
+    cellRowIndex = 0
+    For Each colValue In colValues    ' go through all possible values
+        cellRowIndex = cellRowIndex + 1
+        If colValue = queryValue</t></si><si><t xml:space="preserve"> Then
+            ' return the matching row
+            getMatchingRowIndex = cellRowIndex
+            Exit Function
+        End If
+    Next colValue
+    ' return -1 if not found
+    getMatchingRowIndex = -1
+End Function
+
+</t></si><si><t>CheckChange1</t></si><si><t>Sub validateSource()
+    MsgBox (sourceTable [&] " was selected as source table.")
+    
+    Dim source_id_count As Integer
+    Dim source_id_col As String
+    Dim source_id_duplicate As Boolean
+    Dim source_table_invalid_value As Boolean
+    Dim source_tab</t></si><si><t>count = 0
+    
+    ' Get headers as array for faster processing
+    Dim headers As Variant
+    headers = stbl.HeaderRowRange.Value2
+    
+    Dim i As Long
+    For i = 1 To UBound(headers, 2)
+        If UCase$(CStr(headers(1, i))) = "ID" Then
+            so</t></si><si><t xml:space="preserve">urce_id_col = headers(1, i)
+            source_id_count = 1
+            Exit For
+        End If
+    Next i
+    
+    'check for uniqueness of IDs and existence of ID in every row
+    Dim id_range As Range
+    Dim id_range_add As String
+    Dim cel As Range
+</t></si><si><t xml:space="preserve">    
+    If source_id_count = 1 Then
+        Set id_range = stbl.ListColumns(source_id_col).DataBodyRange
+        id_range_add = stbl.ListColumns(source_id_col).DataBodyRange.Address
+        
+        If Not IsArray(id_range) Then id_range = Array(id_range)</t></si><si><t>ElseIf IsEmpty(cel) Then
+                source_id_duplicate = True
+                Exit For
+            End If
+        Next
+    End If
+    
+    'check if columns are consistent (either only values or only same formula)
+    Dim colHeader As Range
+    Dim s</t></si><si><t>trFormula As String
+    
+    For Each colHeader In stbl.HeaderRowRange
+        If stbl.ListColumns(colHeader.Value).DataBodyRange(1).HasFormula Then
+            'first row is a formula -[>] check if all rows in the column have same formula
+            strFor</t></si><si><t xml:space="preserve">mula = stbl.ListColumns(colHeader.Value).DataBodyRange(1).formula
+            
+            For Each cel In stbl.ListColumns(colHeader.Value).DataBodyRange
+                If Not cel.HasFormula Then
+                    source_table_invalid_formula = True
+  </t></si><si><t xml:space="preserve">                  Exit For
+                ElseIf cel.formula [<][>] strFormula Then
+                    source_table_invalid_formula = True
+                    Exit For
+                End If
+            Next
+            
+            If source_table_invalid_f</t></si><si><t xml:space="preserve">ormula Then Exit For
+        Else
+            'first row is a value -[>] check if all rows have a value
+            For Each cel In stbl.ListColumns(colHeader.Value).DataBodyRange
+                If cel.HasFormula Then
+                    'if one cell has a </t></si><si><t>formula -[>] invalid
+                    source_table_invalid_value = True
+                    Exit For
+                End If
+            Next
+            
+            If source_table_invalid_value Then Exit For
+        End If
+    Next
+    
+    Application.</t></si><si><t>Calculation = xlCalculationAutomatic
+    Application.ScreenUpdating = True
+    
+    If source_id_count = 1 And source_id_duplicate = False And source_table_invalid_formula = False And source_table_invalid_value = False Then
+        'valid
+        sourceval</t></si><si><t>id = True
+        'MsgBox ("The selected source table is valid.")
+    Else
+        'invalid
+        Dim sourceInvalid As UserForm_SourceInvalid
+        Set sourceInvalid = New UserForm_SourceInvalid
+        sourceInvalid.Show
+        
+        If source_fix</t></si><si><t>StaticCode</t></si><si><t>Sub updateIdOnNameChangeTrySevenLevels(referingColumnNameForTypeKind, cellRef, referingTableName, referingColumnName, referingColumnNameForQualifier1, referingColumnNameForQualifier2, referingColumnNameForQualifier3, referingColumnNameForQualifier4, referi</t></si><si><t>ngColumnNameForQualifier5, referingColumnNameForQualifier6, referingColumnNameForQualifier7, referedTableName, referedColumnName)
+Dim refTbl As ListObject
+    Application.EnableEvents = False
+    Application.Undo
+    OldFormula = cellRef.formula
+    'TODO:</t></si><si><t xml:space="preserve"> if old formula was empty, copy formula of upper line into OldFormula
+    'create cellRefOneLineUp
+    'OldFormula = cellRefOneLineUp.Formula
+    
+    Application.Undo
+    Application.EnableEvents = True
+    
+    Set referingTable = ActiveSheet.ListObjects</t></si><si><t>(referingTableName)
+    'NON GENERIC: Set referingTableRefIdColumn = referingTable.ListColumns("Generalization:src")
+    Set referingTableRefIdColumn = referingTable.ListColumns(referingColumnName [&] ":src")
+    referingRowIndex = getReferingRowIndex(cellRe</t></si><si><t>f, referingTable) 'to find out which row of the table changed
+
+    'THIS REPLACES LATER refNameValue = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableRefNameColumn.Index)'
+    
+    refNameValue = cellRef.Value
+    'TODO here apply CamelCa</t></si><si><t>seUpper instead of just replacing the spaces.
+    refNameValue = Replace(refNameValue, " ", "")
+    If refNameValue = "" Then
+        Application.EnableEvents = False
+        cellRef.formula = OldFormula
+        referingTableRefIdColumn.DataBodyRange(refer</t></si><si><t>ingRowIndex) = ""
+        Application.EnableEvents = True
+    Else
+         'NON GENERIC: Set referingTableRefNameColumn = referingTable.ListColumns("Generalization")
+         'No refering PackageColumn used here: Set referingTablePackageColumn = referingT</t></si><si><t>feredTableName Then
+                      Set refTbl = tbl
+                 End If
+              Next tbl
+         Next sht
+         Set referedTable = refTbl
+         Set referedTableIdColumn = referedTable.ListColumns("ID")
+         Set referedTableNameC</t></si><si><t>olumn = referedTable.ListColumns(referedColumnName)
+         Set referedTableNameQColumn = referedTable.ListColumns(referedColumnName [&] ":q")
+         
+         'Cover Case where BaseTypeKind is "_Datatype": in that case, global functions from util are loo</t></si><si><t>ked up:
+         Set referingTableTypeKindColumn = referingTable.ListColumns(referingColumnNameForTypeKind)
+         referingRowTypeKindValue = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableTypeKindColumn.Index)
+         If referingRowTy</t></si><si><t>peKindValue = "_Datatype" Then
+            refNameQValue = "util::" [&] refNameValue
+            referedRowIndex = getMatchingRowIndex(refNameQValue, referedTableNameQColumn)
+            If referedRowIndex [<][>] -1 Then
+                referingTableRefIdColumn.</t></si><si><t>DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+            End If
+         Else
+         'Apply Qualifier 1:
+         Set referingTableQualifier1Column = referingTable.ListColumns(referingCol</t></si><si><t>umnNameForQualifier1)
+         referingRowQualifier1Value = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableQualifier1Column.Index)
+         refNameQValue = referingRowQualifier1Value [&] refNameValue
+         referedRowIndex = getMatchingRo</t></si><si><t>wIndex(refNameQValue, referedTableNameQColumn)
+         If referedRowIndex [<][>] -1 Then
+                referingTableRefIdColumn.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+             Else</t></si><si><t xml:space="preserve">
+                'Apply Qualifier 2:
+                Set referingTableQualifier2Column = referingTable.ListColumns(referingColumnNameForQualifier2)
+                referingRowQualifier2Value = referingTable.DataBodyRange.Cells(referingRowIndex, referingTab</t></si><si><t xml:space="preserve">leQualifier2Column.Index)
+                refNameQValue = referingRowQualifier2Value [&] refNameValue
+                referedRowIndex = getMatchingRowIndex(refNameQValue, referedTableNameQColumn)
+                If referedRowIndex [<][>] -1 Then
+                </t></si><si><t xml:space="preserve">        referingTableRefIdColumn.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+                    Else
+                        'Apply Qualifier 3:
+                        Set referingTableQ</t></si><si><t>ualifier3Column = referingTable.ListColumns(referingColumnNameForQualifier3)
+                        referingRowQualifier3Value = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableQualifier3Column.Index)
+                        refNameQValue</t></si><si><t xml:space="preserve"> = referingRowQualifier3Value [&] refNameValue
+                        referedRowIndex = getMatchingRowIndex(refNameQValue, referedTableNameQColumn)
+                        If referedRowIndex [<][>] -1 Then
+                                referingTableRefIdColum</t></si><si><t>n.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+                            Else
+                                'Apply Qualifier 4:
+                                Set referingTableQualifie</t></si><si><t>r4Column = referingTable.ListColumns(referingColumnNameForQualifier4)
+                                referingRowQualifier4Value = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableQualifier4Column.Index)
+                                refN</t></si><si><t xml:space="preserve">ameQValue = referingRowQualifier4Value [&] refNameValue
+                                referedRowIndex = getMatchingRowIndex(refNameQValue, referedTableNameQColumn)
+                                If referedRowIndex [<][>] -1 Then
+                              </t></si><si><t xml:space="preserve">          referingTableRefIdColumn.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+                                    Else
+                                        'Apply Qualifier 5:
+        </t></si><si><t xml:space="preserve">                                Set referingTableQualifier5Column = referingTable.ListColumns(referingColumnNameForQualifier5)
+                                        referingRowQualifier5Value = referingTable.DataBodyRange.Cells(referingRowIndex, refering</t></si><si><t xml:space="preserve">TableQualifier5Column.Index)
+                                        refNameQValue = referingRowQualifier5Value [&] refNameValue
+                                        referedRowIndex = getMatchingRowIndex(refNameQValue, referedTableNameQColumn)
+           </t></si><si><t xml:space="preserve">                             If referedRowIndex [<][>] -1 Then
+                                                referingTableRefIdColumn.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+            </t></si><si><t xml:space="preserve">                                Else
+                                                'Apply Qualifier 6:
+                                                Set referingTableQualifier6Column = referingTable.ListColumns(referingColumnNameForQualifier6)
+        </t></si><si><t xml:space="preserve">                                        referingRowQualifier6Value = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableQualifier6Column.Index)
+                                                refNameQValue = referingRowQualifier6Value [&] refNa</t></si><si><t xml:space="preserve">meValue
+                                                referedRowIndex = getMatchingRowIndex(refNameQValue, referedTableNameQColumn)
+                                                If referedRowIndex [<][>] -1 Then
+                                            </t></si><si><t xml:space="preserve">            referingTableRefIdColumn.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+                                                    Else
+                                                  </t></si><si><t xml:space="preserve">      'Apply Qualifier 7:
+                                                        Set referingTableQualifier7Column = referingTable.ListColumns(referingColumnNameForQualifier7)
+                                                        referingRowQualifier7Va</t></si><si><t xml:space="preserve">lue = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableQualifier7Column.Index)
+                                                        refNameQValue = referingRowQualifier17Value [&] refNameValue
+                                              </t></si><si><t xml:space="preserve">          referedRowIndex = getMatchingRowIndex(refNameQValue, referedTableNameQColumn)
+                                                        If referedRowIndex [<][>] -1 Then
+                                                                referingTableRefId</t></si><si><t>Column.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+                                                            Else
+                                                                'try whe</t></si><si><t>ther _ ID object exists:
+                                                                'TODO here apply CamelCaseUpper instead of just replacing the spaces.
+                                                                refNameValue = Replace(refNameVal</t></si><si><t xml:space="preserve">ue, " ", "")
+                                                                refIDValue = "_" [&] refNameValue
+                                                                Set referedTableIdColumn = referedTable.ListColumns("ID")
+                         </t></si><si><t xml:space="preserve">                                       referedRowIndex = getMatchingRowIndex(refIDValue, referedTableIdColumn)
+                                                                If referedRowIndex [<][>] -1 Then
+                                                   </t></si><si><t xml:space="preserve">                 referingTableRefIdColumn.DataBodyRange(referingRowIndex) = refIDValue
+                                                                    End If
+                                                            End If
+                           </t></si><si><t xml:space="preserve">                         End If
+                                            End If
+                                    End If
+                            End If
+                    End If
+            End If
+            End If
+         Application.EnableEve</t></si><si><t xml:space="preserve">nts = False
+        cellRef.formula = OldFormula
+        Application.EnableEvents = True
+   End If
+End Sub
+
+
+</t></si><si><t>cation.EnableEvents = True
+    
+    Set referingTable = ActiveSheet.ListObjects(referingTableName)
+    'NON GENERIC: Set referingTableRefIdColumn = referingTable.ListColumns("Generalization:src")
+    Set referingTableRefIdColumn = referingTable.ListColumns</t></si><si><t>(referingColumnName [&] ":src")
+    referingRowIndex = getReferingRowIndex(cellRef, referingTable) 'to find out which row of the table changed
+
+    'THIS REPLACES LATER refNameValue = referingTable.DataBodyRange.Cells(referingRowIndex, referingTableRefNameCo</t></si><si><t>lumn.Index)'
+    
+    refNameValue = cellRef.Value
+    'TODO here apply CamelCaseUpper instead of just replacing the spaces.
+    refNameValue = Replace(refNameValue, " ", "")
+    If refNameValue = "" Then
+        Application.EnableEvents = False
+        ce</t></si><si><t>llRef.formula = OldFormula
+        referingTableRefIdColumn.DataBodyRange(referingRowIndex) = ""
+        Application.EnableEvents = True
+    Else
+         'NON GENERIC: Set referingTableRefNameColumn = referingTable.ListColumns("Generalization")
+         S</t></si><si><t>et referingTablePackageColumn = referingTable.ListColumns("Package")
+         Set referingTableRefNameColumn = referingTable.ListColumns(referingColumnName)
+         '
+         For Each sht In ActiveWorkbook.Worksheets
+             For Each tbl In sht.List</t></si><si><t>umns("ID")
+         Set referedTableNameColumn = referedTable.ListColumns(referedColumnName)
+         Set referedTableNameQColumn = referedTable.ListColumns(referedColumnName [&] ":q")
+         
+         referingRowPackageValue = referingTable.DataBodyRange.</t></si><si><t>Cells(referingRowIndex, referingTablePackageColumn.Index)
+         'TODO: here make the packkage all lower case, accepting only letters and ::
+         referingRowPackageValue = Replace(referingRowPackageValue, " ", "")
+         refNameQValue = refNameValu</t></si><si><t>e
+         If InStr(refNameValue, "::") = 0 Then
+            If referingRowPackageValue [<][>] "" Then
+                  refNameQValue = referingRowPackageValue [&] "::" [&] refNameValue
+            End If
+         End If
+         referedRowIndex = getMatchingRowI</t></si><si><t>ndex(refNameQValue, referedTableNameQColumn)
+         
+         If referedRowIndex [<][>] -1 Then
+             'if yes: leave the cell in it's current status, update the ID value, replace cell value by formular
+             'for that we need the changedSheet s</t></si><si><t xml:space="preserve">o we know which sheet the change was happening
+             referingTableRefIdColumn.DataBodyRange(referingRowIndex) = referedTable.DataBodyRange.Cells(referedRowIndex, referedTableIdColumn.Index)
+             Else
+                'try whether _ ID object </t></si><si><t>exists:
+                'TODO here apply CamelCaseUpper instead of just replacing the spaces.
+                refNameValue = Replace(refNameValue, " ", "")
+                refIDValue = "_" [&] refNameValue
+                Set referedTableIdColumn = referedTa</t></si><si><t xml:space="preserve">ble.ListColumns("ID")
+                referedRowIndex = getMatchingRowIndex(refIDValue, referedTableIdColumn)
+                If referedRowIndex [<][>] -1 Then
+                    referingTableRefIdColumn.DataBodyRange(referingRowIndex) = refIDValue
+          </t></si><si><t xml:space="preserve">      End If
+         End If
+         Application.EnableEvents = False
+        cellRef.formula = OldFormula
+        Application.EnableEvents = True
+   End If
+End Sub
+
+</t></si><si><t xml:space="preserve"> Then
+            ' return the matching row
+            getMatchingRowIndex = cellRowIndex
+            Exit Function
+        End If
+    Next colValue
+    ' return -1 if not found
+    getMatchingRowIndex = -1
+End Function
+</t></si><si><t>Sub fixingtable(tbl, strTable As String, id_count As Integer, id_col As String, id_duplicate As Boolean, table_invalid_value As Boolean, table_invalid_formula As Boolean, party As Boolean)
+    'tbl - is the listobject (source or target table)
+    'strTable</t></si><si><t xml:space="preserve"> - name of the table as string (source or target)
+    'id_count - number of ID columns found in validation
+    'id_col - which column is the ID column in case there is one (name of column as string)
+    'id_duplicate - were duplicate IDs found while valida</t></si><si><t>ting (as boolean)
+    'table_invalid_value - are there violations of the value rule (as boolean)
+    'table_invalid_formula - are there violations of the formula rule (as boolean)
+    'party - 0 -[>] source, 1 -[>] target
+
+    MsgBox ("Fix process is starting.</t></si><si><t>")
+    
+    'add new tracking columns
+    
+'    tbl.ListColumns.Add.Name = "fix transfer ts " [&] Format(transferTime, "YYYYMMDDHHMM")
+'    tbl.ListColumns("fix transfer ts " [&] Format(transferTime, "YYYYMMDDHHMM")).DataBodyRange = Format(transferTime, "YYYYM</t></si><si><t xml:space="preserve">(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange = ""
+    
+    
+    'ID fixing
+    
+    If id_count [>] 1 Then
+        
+        MsgBox ("There are multiple ID columns in the table. Automatic fix is not possible. Program terminates")
+        
+        End
+    
+</t></si><si><t>D"
+        
+        id_range = tbl.ListColumns("ID").DataBodyRange
+        If Not IsArray(id_range) Then id_range = Array(id_range)
+
+
+        'Error: Range of object _Global failed
+        
+        'id_range_add = tbl.ListColumns("ID").DataBodyRange.Addres</t></si><si><t>.Range.column).Validation.Delete
+
+
+        i = 1
+        For Each cel In id_range
+            tbl.ListColumns("ID").DataBodyRange(i) = GUID(1)
+            tbl.ListColumns("fix kind " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange(i) = tbl.ListColu</t></si><si><t>mns("fix kind " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange(i) [&] "[ID created]"
+            i = i + 1
+        Next
+    
+    End If
+    
+    'handle duplicate IDs
+    
+    If id_duplicate = True Then
+    
+        id_range = tbl.ListColumns(id_co</t></si><si><t>l).DataBodyRange
+        id_range_add = tbl.ListColumns(id_col).DataBodyRange.Address
+        
+        If Not IsArray(id_range) Then id_range = Array(id_range)
+        
+        j = 1
+        For Each cel In id_range
+            If (Application.WorksheetFun</t></si><si><t xml:space="preserve">     'find the duplicates of cel
+                
+                    If cel1 = cel Then
+                        counter = counter + 1
+                        If counter [>] 0 Then
+                            tbl.ListColumns(id_col).DataBodyRange(i) = _
+    </t></si><si><t xml:space="preserve">                        tbl.ListColumns(id_col).DataBodyRange(i) [&] "_DUPLICATE_" [&] Format(counter, "00000")
+                            tbl.ListColumns("fix kind " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange(i) = tbl.ListColumns("fix kind " [&] F</t></si><si><t>ormat(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange(i) [&] "[ID duplicate]"
+                        End If
+                    End If
+                    i = i + 1
+                Next
+                
+            ElseIf IsEmpty(cel) Then
+            'row h</t></si><si><t>as no ID -[>] create ID
+            
+                tbl.ListColumns(id_col).DataBodyRange(j) = GUID(1)
+                tbl.ListColumns("fix kind " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange(j) = tbl.ListColumns("fix kind " [&] Format(transferTime</t></si><si><t>, "YYYYMMDDHHMMSS")).DataBodyRange(j) [&] "[ID created]"
+                
+            End If
+            j = j + 1
+        Next
+    End If
+    
+    
+    'fix formulas within value column
+    'fix values within formula column -[>] repeat formula
+    
+    If tab</t></si><si><t>le_invalid_value = True Or table_invalid_formula = True Then
+    
+        For Each colHeader In tbl.HeaderRowRange
+        
+        If tbl.ListColumns(colHeader.Value).DataBodyRange(1).HasFormula And table_invalid_formula = True Then
+            'first row</t></si><si><t xml:space="preserve"> is a formula -[>] check if all rows in the column have same formula
+            
+            strFormula = tbl.ListColumns(colHeader.Value).DataBodyRange(1).formula
+            
+            i = 1
+            For Each cel In tbl.ListColumns(colHeader.Value).D</t></si><si><t>ataBodyRange
+                If cel.HasFormula = False Or cel.formula [<][>] strFormula Then
+                    
+                    tbl.ListColumns(colHeader.Value).DataBodyRange(i) = strFormula
+                    tbl.ListColumns("fix kind " [&] Format(transf</t></si><si><t xml:space="preserve">erTime, "YYYYMMDDHHMMSS")).DataBodyRange(i) = tbl.ListColumns("fix kind " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange(i) [&] "[formula overwritten in column " [&] colHeader.Value [&] "]"
+        
+                End If
+                i = i + 1
+     </t></si><si><t xml:space="preserve">       Next
+            
+        Else
+            'first row is a value -[>] check if all rows have a value
+            
+            If table_invalid_value = True Then
+                i = 1
+                For Each cel In tbl.ListColumns(colHeader.Value).Dat</t></si><si><t>aBodyRange
+                    If cel.HasFormula Then
+                    
+                        strFormula = tbl.ListColumns(colHeader.Value).DataBodyRange(i).formula
+                    
+                        tbl.ListColumns(colHeader.Value).DataBody</t></si><si><t>Range(i) = "REMOVED_" [&] strFormula
+                        tbl.ListColumns("fix kind " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange(i) = tbl.ListColumns("fix kind " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange(i) [&] "[formula removed i</t></si><si><t>n column " [&] colHeader.Value [&] "]"
+                                
+                    End If
+                    
+                    i = i + 1
+                Next
+            End If
+        End If
+        Next
+    End If
+        
+    'if formula is rel</t></si><si><t xml:space="preserve">ative -[>] exclude from fix
+    'not done so far
+    
+    
+    
+    'set fixed flags to true
+    If party = False Then
+        sourcevalid = True
+    Else
+        targetvalid = True
+    End If
+    
+    
+    
+    
+    
+
+End Sub
+
+</t></si><si><t xml:space="preserve">Function GUID$(Optional lowercase As Boolean, Optional parens As Boolean)
+'function generates a GUID
+
+    Dim k[&], h$
+    GUID = Space(36)
+    For k = 1 To Len(GUID)
+        Randomize
+        Select Case k
+            Case 9, 14, 19, 24: h = "-"
+           </t></si><si><t xml:space="preserve"> Case 15:            h = "4"
+            Case 20:            h = Hex(Rnd * 3 + 8)
+            Case Else:          h = Hex(Rnd * 15)
+        End Select
+        Mid$(GUID, k, 1) = h
+    Next
+    
+    If lowercase Then GUID = LCase$(GUID)
+    If parens Then G</t></si><si><t>Sub createTargetTable()
+    'create the new sheet
+    
+    Dim sheetName As String
+    Dim i As Integer
+    i = 2
+    
+    ' Store formatted time strings to avoid repeated calculations
+    Dim timeFormat As String
+    Dim timeFormatLong As String
+    timeF</t></si><si><t>ormat = Format(transferTime, "DDHHMM")
+    timeFormatLong = Format(transferTime, "YYYYMMDDHHMMSS")
+    
+    'ADDED: trim sheetName due to MS tab name restriction
+    sheetName = Right(sourceTable [&] timeFormat, 31)
+    
+    Application.ScreenUpdating = Fals</t></si><si><t xml:space="preserve">olHeader.Value, "transfer ") [>] 0 Or _
+                InStr(colHeader.Value, "fix kind") [>] 0) Then
+            
+            If i [>] 2 Then
+                ttbl.ListColumns.Add
+            End If
+            
+            ' Copy entire range including header
+</t></si><si><t xml:space="preserve"> = i + 1
+            
+        End If
+    Next colHeader
+    
+    targetTable = sheetName
+    
+    ' Add tracking columns for source using bulk operations
+    Dim sourcePartyCol As ListColumn
+    Dim sourceKindCol As ListColumn
+    
+    ' Add columns
+    Se</t></si><si><t xml:space="preserve">    For j = 1 To rowCount
+        partyValues(j, 1) = "source"
+        kindValues(j, 1) = "create target"
+    Next j
+    
+    ' Bulk update source columns
+    sourcePartyCol.DataBodyRange.Value = partyValues
+    sourceKindCol.DataBodyRange.Value = kindValu</t></si><si><t xml:space="preserve"> 1 To 1)
+    ReDim kindValues(1 To rowCount, 1 To 1)
+    
+    ' Fill arrays
+    For j = 1 To rowCount
+        partyValues(j, 1) = "target"
+        kindValues(j, 1) = "create target"
+    Next j
+    
+    ' Bulk update target columns
+    targetPartyCol.DataBo</t></si><si><t>Sub validateTarget()
+    MsgBox (targetTable [&] " was selected as target table.")
+    
+    Dim target_id_count As Integer
+    Dim target_id_col As String
+    Dim target_id_duplicate As Boolean
+    Dim target_table_invalid_value As Boolean
+    Dim target_tab</t></si><si><t>count = 0
+    
+    ' Get headers as array for faster processing
+    Dim headers As Variant
+    headers = ttbl.HeaderRowRange.Value2
+    
+    Dim i As Long
+    For i = 1 To UBound(headers, 2)
+        If UCase$(CStr(headers(1, i))) = "ID" Then
+            ta</t></si><si><t xml:space="preserve">rget_id_col = headers(1, i)
+            target_id_count = 1
+            Exit For
+        End If
+    Next i
+    
+    'check for uniqueness of IDs and existence of ID in every row
+    Dim id_range As Range
+    Dim id_range_add As String
+    Dim cel As Range
+</t></si><si><t xml:space="preserve">    
+    If target_id_count = 1 Then
+        Set id_range = ttbl.ListColumns(target_id_col).DataBodyRange
+        id_range_add = ttbl.ListColumns(target_id_col).DataBodyRange.Address
+        
+        If Not IsArray(id_range) Then id_range = Array(id_range)</t></si><si><t>ElseIf IsEmpty(cel) Then
+                target_id_duplicate = True
+                Exit For
+            End If
+        Next
+    End If
+    
+    'check if columns are consistent (either only values or only same formula)
+    Dim colHeader As Range
+    Dim s</t></si><si><t>trFormula As String
+    
+    For Each colHeader In ttbl.HeaderRowRange
+        If ttbl.ListColumns(colHeader.Value).DataBodyRange(1).HasFormula Then
+            'first row is a formula -[>] check if all rows in the column have same formula
+            strFor</t></si><si><t xml:space="preserve">mula = ttbl.ListColumns(colHeader.Value).DataBodyRange(1).formula
+            
+            For Each cel In ttbl.ListColumns(colHeader.Value).DataBodyRange
+                If Not cel.HasFormula Then
+                    target_table_invalid_formula = True
+  </t></si><si><t xml:space="preserve">                  Exit For
+                ElseIf cel.formula [<][>] strFormula Then
+                    target_table_invalid_formula = True
+                    Exit For
+                End If
+            Next
+            
+            If target_table_invalid_f</t></si><si><t>ormula Then Exit For
+        Else
+            'first row is a value -[>] check if all rows have a value
+            For Each cel In ttbl.ListColumns(colHeader.Value).DataBodyRange
+                If cel.HasFormula Then
+                    target_table_invali</t></si><si><t>d_value = True
+                    Exit For
+                End If
+            Next
+            
+            If target_table_invalid_value Then Exit For
+        End If
+    Next
+    
+    Application.Calculation = xlCalculationAutomatic
+    Application.Scree</t></si><si><t>nUpdating = True
+    
+    If target_id_count = 1 And target_id_duplicate = False And target_table_invalid_value = False And target_table_invalid_formula = False Then
+        targetvalid = True
+        'MsgBox ("The selected target table is valid.")
+    Els</t></si><si><t>UserForm_TransferMode</t></si><si><t xml:space="preserve">Sub CommandButton1_Click()
+    transferMode = "normal"
+    Unload Me
+End Sub
+Private </t></si><si><t>Sub UserForm_QueryClose(Cancel As Integer, CloseMode As Integer)
+    If CloseMode = vbFormControlMenu Then
+        MsgBox "Operation canceled. Program terminates.", vbCritical
+        End
+    End If
+End Sub</t></si><si><t>UserForm_SourceTable</t></si><si><t xml:space="preserve">Sub CommandButton1_Click()
+    fulltransfer = True
+    Unload Me
+End Sub
+Private </t></si><si><t xml:space="preserve">Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
+    sourceTable = Me.ListBox1.Text
+    Unload Me
+End Sub
+Private </t></si><si><t>UserForm_TargetTable</t></si><si><t xml:space="preserve">Sub CommandButton1_Click()
+    targetTable = "no selection"
+    Unload Me
+End Sub
+Private </t></si><si><t xml:space="preserve">Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
+    targetTable = Me.ListBox1.Text
+    Unload Me
+End Sub
+Private </t></si><si><t>UserForm_SourceInvalid</t></si><si><t xml:space="preserve">Sub CommandButton1_Click()
+    source_fix = True
+    Unload Me
+End Sub
+Private </t></si><si><t xml:space="preserve">Sub CommandButton2_Click()
+    Unload Me
+    MsgBox "Program terminates"
+    End
+End Sub
+Private </t></si><si><t>UserForm_TargetInvalid</t></si><si><t xml:space="preserve">Sub CommandButton1_Click()
+    target_fix = True
+    Unload Me
+End Sub
+Private </t></si><si><t>::Layer1</t></si><si><t>Function instantiatedSimpleCodePattern(patternSourceTable As String, patternMatchFilterColumnNames As Variant, patternMatchFilterColumnValues As Variant, patternOrderColumnName As String, instantiatedTemplateColumnFromPatternSourceTable As String) As Strin</t></si><si><t>g
+
+    Dim ws As Worksheet
+    Dim tbl As ListObject
+    Dim wsFound As Boolean
+    Dim sheet As Worksheet
+    Dim filterCriteria As Collection
+    Dim matchedRows As Collection
+    Dim orderColumnIndex As Long
+    Dim instantiatedColumnIndex As Long
+    D</t></si><si><t>im rowIndex As Long
+    Dim colIndex As Long
+    Dim filterMatched As Boolean
+    Dim output As String
+    Dim tempArray() As Variant
+    Dim i As Long
+
+    ' Search for the table across all worksheets
+    wsFound = False
+    For Each sheet In ThisWorkbook</t></si><si><t>.Worksheets
+        On Error Resume Next
+        Set tbl = sheet.ListObjects(patternSourceTable)
+        On Error GoTo 0
+        If Not tbl Is Nothing Then
+            Set ws = sheet
+            wsFound = True
+            Exit For
+        End If
+    Next s</t></si><si><t xml:space="preserve">heet
+    
+    ' Validate if the table was found
+    If Not wsFound Or tbl Is Nothing Then
+        MsgBox "Error: Pattern source table '" [&] patternSourceTable [&] "' not found in any worksheet.", vbCritical
+        Exit Function
+    End If
+    
+     ' Ensure </t></si><si><t xml:space="preserve">the number of filter columns matches the number of filter values
+    If UBound(patternMatchFilterColumnNames) [<][>] UBound(patternMatchFilterColumnValues) Then
+        MsgBox "Error: Mismatch between filter column names and filter column values.", vbCritical
+</t></si><si><t xml:space="preserve">    If orderColumnIndex = 0 Or instantiatedColumnIndex = 0 Then
+        MsgBox "Error: Order column or instantiated template column not found in table.", vbCritical
+        Exit Function
+    End If
+
+    ' Find matching rows
+    Set matchedRows = New Collec</t></si><si><t>tion
+    tempArray = tbl.DataBodyRange.Value
+    For rowIndex = 1 To UBound(tempArray, 1)
+        filterMatched = True
+        For i = LBound(patternMatchFilterColumnNames) To UBound(patternMatchFilterColumnNames)
+            Dim columnName As String, colu</t></si><si><t xml:space="preserve">mnValue As String
+            columnName = patternMatchFilterColumnNames(i)
+            columnValue = patternMatchFilterColumnValues(i)
+            Dim columnIndex As Long
+            columnIndex = 0
+
+            ' Find the column index for the filter
+    </t></si><si><t>olumnIndex = 0 Then
+                MsgBox "Error: Filter column '" [&] columnName [&] "' not found in table.", vbCritical
+                Exit Function
+            End If
+
+            ' Check if the value matches
+            If tempArray(rowIndex, columnIndex</t></si><si><t>) [<][>] columnValue Then
+                filterMatched = False
+                Exit For
+            End If
+        Next i
+
+        ' If all criteria match, add to the collection
+        If filterMatched Then
+            matchedRows.Add Array(tempArray(rowInde</t></si><si><t xml:space="preserve">t [&] vbNewLine
+        End If
+    Next i
+
+    instantiatedSimpleCodePattern = output
+
+End Function
+
+</t></si><si><t xml:space="preserve">Sub repopulateTablesAndColumnsMetadata()
+    Dim wsTables As Worksheet, wsColumns As Worksheet
+    Dim tblTables As ListObject, tblColumns As ListObject
+    Dim extractTables As ListObject, extractColumns As ListObject
+    Dim currentDateTime As String
+   </t></si><si><t>Function createExtract(tableType As String, currentDateTime As String) As ListObject
+    
+    If tableType = "Tables" Then
+    
+        ' Create 'Tables_Extract' sheet with specific columns
+        Set NewSheet = ThisWorkbook.Sheets.Add(After:=ThisWorkbook</t></si><si><t xml:space="preserve">   .Cells(1, 3).Value = "Excel Table - Excel Name"
+            .Cells(1, 4).Value = "Name"
+            .Cells(1, 5).Value = "Excel Table - Sheet Name"
+        End With
+        
+        ' Create the 'Tables_Extract' table object
+        Set newTable = NewSh</t></si><si><t>Function compareExtract(Target As String, DateTime As String) As ListObject
+    Dim wsMain As Worksheet
+    Dim wsExtract As Worksheet
+    Dim tblMain As ListObject
+    Dim tblExtract As ListObject
+    Dim tblMainHeaders As Collection
+    Dim tblExtractHea</t></si><si><t>ders As Collection
+    Dim cell As Range
+    Dim columnFound As Boolean
+    Dim missingColumns As String
+    Dim formulaColumns As String
+    Dim mainSheetName As String
+    Dim extractSheetName As String
+    Dim mainTableName As String
+    Dim extractTabl</t></si><si><t xml:space="preserve">eName As String
+
+    ' Determine sheet and table names based on the Target
+    If Target = "Tables" Then
+        mainSheetName = "Tables"
+        extractSheetName = "Tables_Extract" [&] DateTime
+        mainTableName = "meta_Tables"
+        extractTableName </t></si><si><t>= "meta_Tables_Extract" [&] DateTime
+    ElseIf Target = "Columns" Then
+        mainSheetName = "Columns"
+        extractSheetName = "Columns_Extract" [&] DateTime
+        mainTableName = "meta_Columns"
+        extractTableName = "meta_Columns_Extract" [&] DateT</t></si><si><t>ime
+    End If
+
+    On Error Resume Next
+    ' Get the main worksheet and table
+    Set wsMain = ThisWorkbook.Worksheets(mainSheetName)
+    Set tblMain = wsMain.ListObjects(mainTableName)
+
+    ' Get the extract worksheet and table
+    Set wsExtract = ThisW</t></si><si><t xml:space="preserve">orkbook.Worksheets(extractSheetName)
+    Set tblExtract = wsExtract.ListObjects(extractTableName)
+    On Error GoTo 0
+
+    ' Validate tables
+    If tblMain Is Nothing Then
+        MsgBox "Table '" [&] mainTableName [&] "' not found in sheet '" [&] mainSheetName </t></si><si><t>alue = "_rowTemplate_" [&] mainTableName
+        End With
+
+    End If
+
+
+
+    ' Create collections for column headers
+    Set tblMainHeaders = New Collection
+    Set tblExtractHeaders = New Collection
+
+    ' Collect main table headers
+    For Each cell In tbl</t></si><si><t>Main.HeaderRowRange
+        tblMainHeaders.Add cell.Value, cell.Value
+    Next cell
+
+    ' Collect extract table headers
+    For Each cell In tblExtract.HeaderRowRange
+        tblExtractHeaders.Add cell.Value, cell.Value
+    Next cell
+
+    ' Check for miss</t></si><si><t>ing columns in tblMain
+    missingColumns = ""
+
+    For Each colName In tblExtractHeaders
+        On Error Resume Next
+        columnFound = False
+        columnFound = Not IsError(tblMainHeaders(colName))
+        On Error GoTo 0
+
+        If Not columnFoun</t></si><si><t xml:space="preserve">ext i
+    FindColumnIndex = 0 ' Return 0 if not found
+End Function
+
+</t></si><si><t xml:space="preserve">Function ExtractIDs(tbl As ListObject) As Collection
+    Dim colIDs As New Collection
+    Dim idRange As Range
+    Dim idArray As Variant
+    Dim i As Long
+    Dim idColumn As Integer
+
+    ' Find the "ID" column index
+    On Error Resume Next
+    idColumn </t></si><si><t xml:space="preserve">= Application.Match("ID", tbl.HeaderRowRange, 0)
+    On Error GoTo 0
+    
+    If idColumn = 0 Then Exit </t></si><si><t xml:space="preserve">Function ' Exit if "ID" column is not found
+
+    ' Define the range containing IDs (excluding the header)
+    Set idRange = tbl.ListColumns(idColumn).DataBodyRange
+    If idRange Is Nothing Then Exit </t></si><si><t xml:space="preserve">Function ' Exit if there is no data
+
+    ' Load range into an array for performance
+    idArray = idRange.Value
+
+    ' Add items to collection (handle both single and multi-row cases)
+    If IsArray(idArray) Then
+        For i = 1 To UBound(idArray, 1)
+   </t></si><si><t xml:space="preserve">         colIDs.Add idArray(i, 1)
+        Next i
+    Else
+        colIDs.Add idArray
+    End If
+
+    ' Return the collection
+    Set ExtractIDs = colIDs
+End Function
+
+
+
+</t></si><si><t xml:space="preserve">Function CollectionContains(col As Collection, key As Variant) As Boolean
+    Dim item As Variant
+    On Error Resume Next
+    For Each item In col
+        If item = key Then
+            CollectionContains = True
+            Exit Function
+        End If
+  </t></si><si><t xml:space="preserve">  Next item
+    CollectionContains = False
+End Function
+
+</t></si><si><t>Sub ' Exit if the user cancels or enters an invalid value
+    End Select
+
+    ' Optimize performance
+    Application.Calculation = xlCalculationManual
+    Application.ScreenUpdating = False
+    Application.EnableEvents = False
+
+    ' Create "Framework_Temp</t></si><si><t>Sub Package")
+        Set snippetCol = snippetTable.ListColumns("Snippet")
+        On Error GoTo 0
+        
+        ' Ensure both columns exist before proceeding
+        If Not subPackageCol Is Nothing And Not snippetCol Is Nothing Then
+            foundSn</t></si><si><t>ippet = False
+            
+            ' Loop through each row in the table
+            For Each snippetRow In snippetTable.ListRows
+                ' Check if the "</t></si><si><t>Sub Package" column contains "::Layer0"
+                If snippetRow.Range.Cells(1, subPackageCol.Index).Value = "::Layer0" Then
+                    ' Retrieve the corresponding "Snippet" column value
+                    snippetText = snippetRow.Range.Cel</t></si><si><t xml:space="preserve">Exit Function
+        End If
+    Next i
+    FindRow = 0
+End Function
+
+' Gets the column index of a column name in the first row
+</t></si><si><t xml:space="preserve">n
+        End If
+    Next i
+    GetColumnIndex = 0
+End Function
+
+' Checks if a sheet exists
+</t></si><si><t xml:space="preserve">Sub transferObject()
+    ' Turn off Excel's automatic processes for speed
+    Application.ScreenUpdating = False
+    Application.EnableEvents = False
+    Application.Calculation = xlCalculationManual
+    
+    ' Create our custom fast lookup object
+    Dim </t></si><si><t>tObjects(targetTable)
+    
+    ' Load all data at once
+    Dim sourceData As Variant, targetData As Variant
+    
+    sourceHeaders = stbl.HeaderRowRange.Value2
+    targetHeaders = ttbl.HeaderRowRange.Value2
+    
+    ' Load source data
+    With stbl.DataBod</t></si><si><t xml:space="preserve">yRange
+        sourceData = .Value2
+        If Not IsArray(sourceData) Then
+            Dim tempArray(1 To 1, 1 To 1) As Variant
+            tempArray(1, 1) = sourceData
+            sourceData = tempArray
+        End If
+    End With
+    
+    ' Load target </t></si><si><t xml:space="preserve">data
+    With ttbl.DataBodyRange
+        targetData = .Value2
+        If Not IsArray(targetData) Then
+            Dim tempTargetArray(1 To 1, 1 To 1) As Variant
+            tempTargetArray(1, 1) = targetData
+            targetData = tempTargetArray
+       </t></si><si><t xml:space="preserve"> End If
+    End With
+    
+    ' Find ID columns
+    Dim sourceIdCol As Long, targetIdCol As Long
+    sourceIdCol = GetIdColumnIndex(sourceHeaders)
+    targetIdCol = GetIdColumnIndex(targetHeaders)
+    
+    ' Build column mapping once
+    Dim columnMapping </t></si><si><t>As Collection
+    Set columnMapping = BuildColumnMapping(sourceHeaders, targetHeaders, stbl, ttbl)
+    
+    ' Preserve formulas
+    Dim targetValues As Variant, targetFormulas As Variant
+    targetValues = ttbl.DataBodyRange.Value2
+    targetFormulas = ttb</t></si><si><t>l.DataBodyRange.formula
+    
+    ' Build lookup of target IDs
+    Dim i As Long
+    For i = 1 To UBound(targetData, 1)
+        targetLookup.Add CStr(targetData(i, targetIdCol)), i
+    Next i
+    
+    ' Prepare arrays for new and updated data
+    Dim newRow</t></si><si><t xml:space="preserve">s As Collection, updatedRows As Collection
+    Set newRows = New Collection
+    Set updatedRows = New Collection
+    
+    ' Categorize rows
+    For i = 1 To UBound(sourceData, 1)
+        If targetLookup.Exists(CStr(sourceData(i, sourceIdCol))) Then
+       </t></si><si><t xml:space="preserve">     updatedRows.Add Array(i, targetLookup.item(CStr(sourceData(i, sourceIdCol))))
+        Else
+            newRows.Add i
+        End If
+    Next i
+    
+    ' Process updates while preserving formulas
+    Dim rowIdx As Long, colIdx As Long
+    If updatedRo</t></si><si><t>mula(ttbl, CStr(targetHeaders(1, colIdx))) Then
+                    targetValues(targetRowIdx, colIdx) = sourceData(sourceRowIdx, mapping(0))
+                End If
+            Next j
+        Next i
+        
+        ttbl.DataBodyRange.Value2 = targetValues</t></si><si><t xml:space="preserve">Application.ScreenUpdating = True
+    Exit Sub
+End Sub
+
+Private </t></si><si><t xml:space="preserve">Function BuildColumnMapping(sourceHeaders As Variant, targetHeaders As Variant, _
+                                 stbl As ListObject, ttbl As ListObject) As Collection
+    Dim mapping As Collection
+    Set mapping = New Collection
+    
+    Dim i As Long, </t></si><si><t>j As Long
+    Dim sourceCol As String, targetCol As String
+    
+    For i = 1 To UBound(sourceHeaders, 2)
+        sourceCol = CStr(sourceHeaders(1, i))
+        
+        If Not (HasFormula(stbl, sourceCol)) Or _
+                InStr(sourceCol, "transfer ")</t></si><si><t xml:space="preserve"> [>] 0 Or _
+                InStr(sourceCol, "fix kind") [>] 0 Then
+                'InStr(sourceCol, "Column") [>] 0)
+                
+            
+            For j = 1 To UBound(targetHeaders, 2)
+                targetCol = CStr(targetHeaders(1, j))
+         </t></si><si><t xml:space="preserve">       If targetCol = sourceCol Then
+                    mapping.Add Array(i, j, HasFormula(ttbl, targetCol))
+                    Exit For
+                End If
+            Next j
+        End If
+    Next i
+    
+    Set BuildColumnMapping = mapping
+End Fun</t></si><si><t xml:space="preserve">ction
+
+Private </t></si><si><t>Sub CopyRowToArray(sourceData As Variant, destArray As Variant, _
+                         sourceRowIndex As Long, destRowIndex As Long, _
+                         columnMapping As Collection)
+    Dim mapping As Variant
+    Dim i As Long
+    
+    For i = 1</t></si><si><t xml:space="preserve">  CStr(sourceHeaders(1, mapping(0))), CStr(targetHeaders(1, mapping(1)))
+        Else
+            ' Direct copy for non-formula columns
+            destArray(destRowIndex, mapping(1)) = sourceData(sourceRowIndex, mapping(0))
+        End If
+    Next i
+End S</t></si><si><t xml:space="preserve">ub
+
+Private </t></si><si><t xml:space="preserve">ount [>] 0 Then
+            HasFormula = col.DataBodyRange(1).HasFormula
+        End If
+    End If
+End Function
+
+Private </t></si><si><t>Sub HandleStoredValue(ByVal sourceTbl As ListObject, ByVal targetTbl As ListObject, _
+                            ByVal sourceRow As Long, ByVal targetRow As Long, _
+                            ByVal sourceCol As String, ByVal targetCol As String)
+    ' Cr</t></si><si><t>eate name for stored value column
+    Dim storedColName As String
+    storedColName = targetCol [&] " STORED"
+    
+    ' Check if stored column exists, if not create it
+    On Error Resume Next
+    Dim storedCol As ListColumn
+    Set storedCol = targetTbl.Li</t></si><si><t xml:space="preserve">= sourceTbl.ListColumns(sourceCol).DataBodyRange(sourceRow).Value2
+End Sub
+
+Private </t></si><si><t>Sub UpdateTransferStatus(sourcePartyCol As ListColumn, sourceKindCol As ListColumn, _
+                               targetPartyCol As ListColumn, targetKindCol As ListColumn, _
+                               updatedRows As Collection, newRows As Collectio</t></si><si><t>n, _
+                               sourceCount As Long, targetCount As Long)
+    ' Create arrays for bulk status updates
+    Dim sourceStatus() As Variant
+    ReDim sourceStatus(1 To sourceCount, 1 To 2)
+    
+    Dim targetStatus() As Variant
+    ReDim ta</t></si><si><t>"update target"
+    Next i
+    
+    ' Write status arrays in bulk
+    sourcePartyCol.DataBodyRange.Value2 = Application.Transpose(Application.Transpose(GetColumn(sourceStatus, 1)))
+    sourceKindCol.DataBodyRange.Value2 = Application.Transpose(Application.</t></si><si><t>Transpose(GetColumn(sourceStatus, 2)))
+    targetPartyCol.DataBodyRange.Value2 = Application.Transpose(Application.Transpose(GetColumn(targetStatus, 1)))
+    targetKindCol.DataBodyRange.Value2 = Application.Transpose(Application.Transpose(GetColumn(targetS</t></si><si><t xml:space="preserve">tatus, 2)))
+End Sub
+
+Private </t></si><si><t>Function GetColumn(arr As Variant, colIndex As Long) As Variant
+    Dim result() As Variant
+    Dim i As Long
+    
+    ReDim result(1 To UBound(arr, 1))
+    For i = 1 To UBound(arr, 1)
+        result(i) = arr(i, colIndex)
+    Next i
+    
+    GetColumn = re</t></si><si><t xml:space="preserve">sult
+End Function
+
+Private </t></si><si><t>Function GetIdColumnIndex(headers As Variant) As Long
+    Dim i As Long
+    For i = 1 To UBound(headers, 2)
+        If UCase(CStr(headers(1, i))) = "ID" Then
+            GetIdColumnIndex = i
+            Exit Function
+        End If
+    Next i
+    GetIdColu</t></si><si><t xml:space="preserve">Function to check if a column contains formulas
+</t></si><si><t>Function ColumnHasFormula(colRange As Range) As Boolean
+    Dim cell As Range
+    For Each cell In colRange.Cells
+        If cell.HasFormula Then
+            ColumnHasFormula = True
+            Exit Function
+        End If
+    Next cell
+    ColumnHasFormul</t></si><si><t xml:space="preserve">a = False
+End Function
+
+' </t></si><si><t xml:space="preserve">Function to check if a column is in the matched list
+</t></si><si><t>Function IsColumnMatched(colIndex As Long, matchedCols As Collection) As Boolean
+    Dim item As Variant
+    For Each item In matchedCols
+        If item = colIndex Then
+            IsColumnMatched = True
+            Exit Function
+        End If
+    Next i</t></si><si><t xml:space="preserve">tem
+    IsColumnMatched = False
+End Function
+
+Private </t></si><si><t>Function MatchID(targetLookup As Variant, searchID As String) As Long
+    Dim i As Long
+    For i = 1 To UBound(targetLookup)
+        If targetLookup(i) = searchID Then
+            MatchID = i
+            Exit Function
+        End If
+    Next i
+    MatchID</t></si><si><t>::Layer0</t></si><si><t>::CamelCaseAll</t></si><si><t xml:space="preserve">
+
+Public </t></si><si><t xml:space="preserve">Function evaluateExcelFormula(formula As String)
+Application.Volatile
+evaluateExcelFormula = Application.Caller.Parent.Evaluate(formula)
+End Function
+
+
+' MAIN </t></si><si><t xml:space="preserve">Function 1: Converts string to CamelUpper
+Public </t></si><si><t>Function camelCaseUpper(ByVal inputString As String) As String
+    On Error GoTo ErrorHandler ' Enable error handling
+    
+    inputString = checkAndReplaceFaultyCharacters(inputString)
+    
+    camelCaseUpper = businessToCamelCaseUpper(stringToBusiness(in</t></si><si><t xml:space="preserve">putString))
+    
+    Exit Function
+ErrorHandler:
+    ' Error handling logic
+    camelCaseUpper = "" ' Return an empty string in case of an error
+End Function
+
+' MAIN </t></si><si><t xml:space="preserve">Function 2: Converts string to CamelLower
+Public </t></si><si><t>Function camelCaseLower(ByVal inputString As String) As String
+    On Error GoTo ErrorHandler ' Enable error handling
+    
+    inputString = checkAndReplaceFaultyCharacters(inputString)
+    
+    camelCaseLower = businessToCamelCaseLower(stringToBusiness(in</t></si><si><t xml:space="preserve">putString))
+    
+    Exit Function
+ErrorHandler:
+    ' Error handling logic
+    camelCaseLower = "" ' Return an empty string in case of an error
+End Function
+
+' MAIN </t></si><si><t xml:space="preserve">Function 3: Converts Camel case string to Business
+Public </t></si><si><t>Function camelCaseToBusiness(ByVal inputString As String) As String
+    On Error GoTo ErrorHandler ' Enable error handling
+    
+    inputString = checkAndReplaceFaultyCharacters(inputString)
+    
+    Application.Volatile True
+    Dim segments As Collection</t></si><si><t xml:space="preserve">   
+    inputString = Join(segmentsArray, "")
+    inputString = standardizeWhiteSpaceAndCapatilization(inputString)
+    camelCaseToBusiness = handleLists(inputString)
+    
+    Exit Function
+
+ErrorHandler:
+    ' Error handling logic
+    camelCaseToBusiness </t></si><si><t xml:space="preserve">= "" ' Return an empty string in case of an error
+End Function
+
+
+
+' MAIN </t></si><si><t xml:space="preserve">Function 4: Converts a regular string to Business
+Public </t></si><si><t xml:space="preserve">Function stringToBusiness(ByVal inputString As String) As String
+    On Error GoTo ErrorHandler ' Enable error handling
+    
+    inputString = checkAndReplaceFaultyCharacters(inputString)
+    
+    Application.Volatile True
+    Dim segments As Collection
+  </t></si><si><t xml:space="preserve">
+    
+    stringToBusiness = Join(segmentsArray, "")
+    
+        
+    Exit Function
+
+ErrorHandler:
+    ' Error handling logic
+    stringToBusiness = "" ' Return an empty string in case of an error
+End Function
+
+' MAIN </t></si><si><t xml:space="preserve">Function 5: Converts Business string to CamelUpper
+Public </t></si><si><t>Function businessToCamelCaseUpper(ByVal inputString As String) As String
+
+    inputString = checkAndReplaceFaultyCharacters(inputString)
+
+    Dim segments As Collection
+    Dim resultString As String
+    Dim segment As Variant
+    
+    Set segments = busin</t></si><si><t xml:space="preserve">essToCamelSegments(inputString)
+    
+    resultString = ""
+    For Each segment In segments
+        'Debug.Print segment
+        resultString = resultString [&] segment
+    Next segment
+    
+    'handle additional underscores for visibility
+    resultString </t></si><si><t xml:space="preserve">= Replace(resultString, "____", "__")
+    
+    businessToCamelCaseUpper = resultString
+
+End Function
+
+' MAIN </t></si><si><t xml:space="preserve">Function 6: Converts Business string to CamelLower, uses businessToCamelCaseUpper
+Public </t></si><si><t>Function businessToCamelCaseLower(ByVal inputString As String) As String
+
+    inputString = checkAndReplaceFaultyCharacters(inputString)
+    
+    Dim temp As String
+    temp = businessToCamelCaseUpper(inputString)
+    businessToCamelCaseLower = LCase(Left(</t></si><si><t>Function stringToBusinessSegments(ByVal inputString As String) As Collection
+    Dim segments As New Collection
+    Dim temp As String
+    Dim i As Integer
+    Dim segmentArray() As String
+    Dim currentSegment As String
+    
+    ' Process the string as p</t></si><si><t>er the original function
+    temp = separateCamelCaseWords(inputString)
+    'Debug.Print temp
+    temp = standardizeWhiteSpaceAndCapatilization(temp)
+    'Debug.Print temp
+    
+    temp = handleLists(temp)
+    'Debug.Print temp
+    'temp = checkAndReplaceF</t></si><si><t xml:space="preserve"> ' If a space is encountered
+            If Len(currentSegment) [>] 0 Then
+                ' Add the current segment (before space) to the collection
+                segments.Add currentSegment
+                'Debug.Print "Segment " [&] segments.Count [&] ": ("</t></si><si><t xml:space="preserve"> [&] currentSegment [&] ")"
+                currentSegment = "" ' Reset currentSegment
+            End If
+            ' Add the space itself as a segment
+            segments.Add " "
+            'Debug.Print "Segment " [&] segments.Count [&] ": ( )"
+        Else
+ </t></si><si><t xml:space="preserve">s.Add currentSegment
+        'Debug.Print "Segment " [&] segments.Count [&] ": (" [&] currentSegment [&] ")"
+    End If
+    
+    ' Return the Collection
+    Set stringToBusinessSegments = segments
+End Function
+
+
+' Entry from Utils
+Public </t></si><si><t xml:space="preserve">Function businessToCamelSegments(ByVal inputString As String) As Collection
+    Dim segments As New Collection
+    Dim i As Integer
+    Dim isFirstLine As Boolean
+    Dim lineArray() As String
+    Dim currentLine As String
+    Dim encodedLine As String
+   </t></si><si><t xml:space="preserve"> Dim leadingSpaces As Integer
+    Dim linePrefix As String
+
+    ' Step 1: Split the input string by lines first
+    lineArray = Split(inputString, Chr(10))
+    
+    ' Initialize a flag for the first line
+    isFirstLine = True
+    
+    ' Step 2: Process ea</t></si><si><t>ch line separately
+    For i = LBound(lineArray) To UBound(lineArray)
+        ' Preserve leading spaces in each line
+        leadingSpaces = getLeadingSpaces(lineArray(i))
+        linePrefix = ""
+        
+        
+        ' Apply "N_" prefix only for the f</t></si><si><t xml:space="preserve">irst line if it starts with a number
+        If isFirstLine And Len(Trim(lineArray(i))) [>] 0 And IsNumeric(Left(Trim(lineArray(i)), 1)) Then
+            lineArray(i) = "N" [&] Trim(lineArray(i))
+        ElseIf Not isFirstLine And leadingSpaces [>] 0 Then
+      </t></si><si><t xml:space="preserve">      linePrefix = "_" [&] leadingSpaces [&] "s__"
+            lineArray(i) = Trim(lineArray(i))
+        End If
+        
+
+        currentLine = lineArray(i)
+        
+        camelSegment = businessSegmentToCamelSegment(currentLine)
+    
+        camelSegment = </t></si><si><t>Replace(camelSegment, " ", "")
+        
+        camelSegment = linePrefix [&] camelSegment
+        
+            
+        
+        ' Add the processed line to the collection
+        segments.Add camelSegment
+        
+        ' Add a new-line-encoding after ea</t></si><si><t xml:space="preserve">ch line except the last one
+        If i [<] UBound(lineArray) Then
+            segments.Add "_n__"
+        End If
+        isFirstLine = False ' Set flag to False after processing the first line
+    Next i
+
+    ' Return the collection of camel-case segments
+</t></si><si><t xml:space="preserve">    Set businessToCamelSegments = segments
+    
+End Function
+
+
+' </t></si><si><t xml:space="preserve">Function to retrieve the number of leading spaces from a string
+Public </t></si><si><t xml:space="preserve">Function businessSegmentToCamelSegment(ByVal inputString As String) As String
+    Dim wordArray() As String
+    Dim encodedStr As String
+    Dim result As String
+    Dim word As String
+    Dim i As Integer
+
+    wordArray = Split(inputString, " ")
+    
+    </t></si><si><t>= encodedStr
+        End If
+    Next i
+    
+    inputString = ""
+    For i = LBound(wordArray) To UBound(wordArray)
+        inputString = inputString + wordArray(i)
+        If i [<] UBound(wordArray) Then
+            inputString = inputString + " "
+        E</t></si><si><t>nd If
+    Next i
+    
+    'Debug.Print inputString
+    
+    'encodedStr = replaceUnderscores(encodedStr)
+    
+    encodedStr = Replace(inputString, "_", "_u__")
+    
+    encodedStr = addUnderscore(encodedStr)
+
+    
+    
+    ' Encode special characters in t</t></si><si><t xml:space="preserve">he segment
+    encodedStr = camelEncodeSpecialCharacters(encodedStr)
+    
+    ' Return the result
+    businessSegmentToCamelSegment = encodedStr
+End Function
+
+
+
+Public </t></si><si><t xml:space="preserve">Function stringToCamelSegments(ByVal inputString As String) As Collection
+'TODO
+End Function
+
+
+Public </t></si><si><t xml:space="preserve">Function camelToBusinessSegments(ByVal inputString As String) As Collection
+    Dim segments As New Collection
+    Dim lineArray() As String
+    Dim i As Integer
+    Dim reconstructedLine As String
+    Dim line As String
+
+
+    If Left(inputString, 2) Like </t></si><si><t xml:space="preserve">    ' Step 2: Process each line separately
+    For i = LBound(lineArray) To UBound(lineArray)
+        line = lineArray(i)
+        'Debug.Print line
+
+        
+        ' Check if the string starts with "_" and contains "s__",
+        ' and the part between t</t></si><si><t xml:space="preserve">     End If
+        
+        
+        
+        ' Decode special characters in each line
+        reconstructedLine = camelDecodeSpecialCharacters(line)
+
+        
+        ' Convert each segment in the line
+        segments.Add camelSegmentToBusinessSegment(r</t></si><si><t>econstructedLine)
+        'Debug.Print camelSegmentToBusinessSegment(reconstructedLine)
+        
+        
+        
+        ' Add a vbCrLf after each line except the last one
+        If i [<] UBound(lineArray) Then
+            segments.Add Chr(10)
+        End</t></si><si><t>ng)
+    lineArray = Split(inputString, Chr(10))
+    For i = LBound(lineArray) To UBound(lineArray)
+        segments.Add lineArray(i)
+        If i [<] UBound(lineArray) Then
+            segments.Add Chr(10)
+        End If
+        Next i
+
+    ' Return the coll</t></si><si><t xml:space="preserve">ection of business-case segments
+    Set camelToBusinessSegments = segments
+End Function
+
+
+
+Public </t></si><si><t>Function camelSegmentToBusinessSegment(ByVal inputString As String) As String
+    Dim result As String
+    Dim i As Integer
+    Dim currentChar As String
+    Dim previousChar As String
+    
+    ' Initialize result with the first character
+    result = Left</t></si><si><t>er indicates a new segment
+        If (currentChar Like "[A-Z]" And (previousChar Like "[a-z]" Or previousChar Like "[0-9]")) Or _
+           (currentChar Like "[a-z]" And previousChar Like "[0-9]") Or _
+           (currentChar Like "[0-9]" And previousCha</t></si><si><t xml:space="preserve">r Like "[A-Za-z]") Then
+           'Or _ (Len(result) [>] 0 And Len(Mid(result, InStrRev(result, " ") + 1)) = 1 And previousChar Like "[A-Z]" And currentChar Like "[A-Z]" And (i = Len(inputString) Or Mid(inputString, i + 1, 1) Like "[a-z]")) Then
+        
+  </t></si><si><t xml:space="preserve">          result = result [&] " "
+        End If
+        
+        ' Append the current character to the result
+        result = result [&] currentChar
+        previousChar = currentChar
+    Next i
+    
+    
+    'after splitting, handle small words
+    result =</t></si><si><t xml:space="preserve"> handleCapitalization(result)
+    result = separateCamelCaseWords(result)
+    
+    ' Step 2: Return the reconstructed segment
+    camelSegmentToBusinessSegment = result
+End Function
+
+
+Public </t></si><si><t xml:space="preserve">Function camelToCamelSegments(ByVal inputString As String) As Collection
+'just split Camel segments
+End Function
+
+' HELPER FUNCTIONS'
+
+
+
+' Helper function: Remove double white spaces and clean up lines
+Public </t></si><si><t xml:space="preserve">Function standardizeWhiteSpaceAndCapatilization(ByVal str As String) As String
+    Dim lines() As String
+    Dim i As Integer
+    Dim result As String
+    Dim lineContent As String
+    Dim firstNonWhitespaceFound As Boolean
+    Dim temp As String
+    
+    </t></si><si><t xml:space="preserve">n Chr(10)
+    lines = Split(str, Chr(10))
+    
+    result = ""
+    
+    
+    ' per line...
+    ' Step 3: remove trailing whitespaces and
+    ' Step 4: replace multiple spaces with one
+    ' Step 5: add spaces between numbers and words
+    ' Step 6: handle </t></si><si><t xml:space="preserve">capitalization with small words list
+
+    For i = LBound(lines) To UBound(lines)
+        
+        ' Preserve leading spaces by capturing the leading part of the string
+        Dim leadingSpaces As String
+        leadingSpaces = ""
+        temp = ""
+       </t></si><si><t xml:space="preserve">         End If
+        Next j
+        
+        ' Trim trailing spaces but preserve internal spaces carefully
+        lineContent = Trim(lines(i))
+        
+        ' Replace multiple spaces within the content (after leading spaces) with a single space
+    </t></si><si><t xml:space="preserve">    Do While InStr(lineContent, "  ") [>] 0
+            lineContent = Replace(lineContent, "  ", " ")
+        Loop
+        
+                
+        ' Iterate through each character in the string
+        Dim k As Integer
+        For k = 1 To Len(lineContent)</t></si><si><t xml:space="preserve"> current character to result
+                temp = temp [&] currentChar
+                
+                ' Check if current character is a number and the next character is a letter
+                If IsNumeric(currentChar) And nextChar Like "[A-Za-z]" Then
+</t></si><si><t xml:space="preserve">                    temp = temp [&] " "
+                ' Check if current character is a letter and the next character is a number
+                ElseIf currentChar Like "[A-Za-z]" And IsNumeric(nextChar) Then
+                    temp = temp [&] " "
+        </t></si><si><t xml:space="preserve">        End If
+            Else
+                ' For the last character, just add it to the result
+                temp = temp [&] currentChar
+            End If
+        Next k
+        
+        lineContent = temp
+        
+        'Debug.Print lineContent
+  </t></si><si><t xml:space="preserve">      lineContent = handleCapitalization(lineContent)
+
+        
+        ' Rebuild the line with the preserved leading spaces
+        result = result [&] leadingSpaces [&] lineContent
+        
+        ' Add a newline except after the last line
+        If i [<] UB</t></si><si><t xml:space="preserve">ound(lines) Then
+            result = result [&] Chr(10)
+        End If
+    
+    Next i
+    
+    
+    standardizeWhiteSpaceAndCapatilization = result
+    
+End Function
+
+
+
+
+' Helper function: Separate words in CamelCase
+</t></si><si><t xml:space="preserve">Function separateCamelCaseWords(ByVal str As String) As String
+    Dim i As Integer
+    Dim result As String
+    Dim special As Boolean
+
+    ' Check if the string is empty or only one character long
+    If Len(str) [<]= 1 Then
+        separateCamelCaseWords </t></si><si><t>-z0-9 ]" Then
+            special = False
+        ElseIf currentChar Like " " Then
+            special = False
+        End If
+
+        ' Check if the current character is uppercase
+        If currentChar Like "[A-Z]" Then
+            ' Add a space based on</t></si><si><t>en
+                result = result [&] " " [&] currentChar
+            Else
+                result = result [&] currentChar
+            End If
+        Else
+            result = result [&] currentChar
+        End If
+    Next i
+
+    separateCamelCaseWords = result
+E</t></si><si><t xml:space="preserve">nd Function
+
+
+' Helper function: add Underscore
+</t></si><si><t>Function addUnderscore(ByVal inputString As String) As String
+    Dim words() As String
+    Dim result As String
+    Dim i As Integer
+    
+    ' Split the string into words using space as a delimiter
+    words = Split(inputString, " ")
+    
+    ' Initializ</t></si><si><t>e the result
+    result = ""
+    
+    ' Process each word
+    For i = LBound(words) To UBound(words)
+        ' Debug.Print words(i)
+
+        ' After capital words or after strings ending in a digit
+        If (i [<] UBound(words) And words(i) = UCase(words(i</t></si><si><t xml:space="preserve">)) And words(i) Like "[A-Z]*" And Not words(i) Like "*[!A-Z]*" And _
+            i + 1 [<]= UBound(words)) Then
+            
+            If (Left(words(i + 1), 1) Like "[A-Za-z0-9]") Then
+                result = result [&] words(i) [&] "_"
+            Else
+    </t></si><si><t xml:space="preserve">            result = result [&] words(i)
+            End If
+
+        ' New logic: Add underscore after words that end with a capital letter
+        ElseIf (i [<] UBound(words) And Right(words(i), 1) Like "[A-Z]") Then
+            result = result [&] words(i) [&] "</t></si><si><t xml:space="preserve">_"
+
+        ' Default behavior: Add the word as is
+        Else
+            result = result [&] words(i)
+        End If
+        
+        ' Add a space if it's not the last word and no underscore was added
+        If i [<] UBound(words) And Right(result, 1) [<][>] </t></si><si><t xml:space="preserve">"_" Then
+            result = result [&] " "
+        End If
+    Next i
+    
+    ' Return the processed string
+    addUnderscore = result
+End Function
+
+
+
+
+
+' Helper function: Highlight special signs
+</t></si><si><t>Function checkAndReplaceFaultyCharacters(ByVal inputString As String) As String
+    Dim allowedChars As String
+    Dim faultyChars As String
+    Dim i As Integer
+    Dim currentChar As String
+    Dim resultString As String
+    
+    ' Define the allowed cha</t></si><si><t xml:space="preserve">racters: letters, numbers, and the hardcoded special characters
+    allowedChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$Ñ%^[&]*()_-+=[]{}|;:'"",.[<][>]?/\`~ " [&] Chr(10)
+    
+    faultyChars = ""
+    resultString = inputString
+    
+ </t></si><si><t>Char) = 0 Then
+            ' If it's a faulty character, add it to the faultyChars string
+            If InStr(faultyChars, currentChar) = 0 Then
+                faultyChars = faultyChars [&] currentChar
+            End If
+            ' Replace the faulty ch</t></si><si><t>aracter with '#'
+            resultString = Replace(resultString, currentChar, "#")
+        End If
+    Next i
+    
+    ' If there are any faulty characters, show a message box
+    If Len(faultyChars) [>] 0 Then
+        'MsgBox "The following characters are n</t></si><si><t xml:space="preserve">ot valid: " [&] Chr(10) [&] faultyChars [&] Chr(10) [&] "They are replaced with '#'", vbExclamation, "Invalid Characters Found and Replaced"
+        
+    End If
+    
+    ' Return the modified string
+    checkAndReplaceFaultyCharacters = resultString
+End Function
+
+</t></si><si><t xml:space="preserve">
+
+
+
+'Helper Function: split business string while preserving new lines and spaces after new lines.
+Public </t></si><si><t>Function splitPreservingNewLines(ByVal str As String) As Variant
+    Dim lines() As String
+    Dim result() As String
+    Dim i As Integer, j As Integer
+    Dim currentLine As String
+
+    ' Split the string into lines
+    lines = Split(str, Chr(10))
+    Re</t></si><si><t xml:space="preserve">Dim result(0)
+
+    ' Process each line separately
+    For i = LBound(lines) To UBound(lines)
+        currentLine = lines(i)
+
+        ' Handle leading spaces at the beginning of the line
+        If Left(currentLine, 1) = " " Then
+            j = 1
+         </t></si><si><t xml:space="preserve">d If
+
+        ' Split the rest of the line by spaces
+        If Len(currentLine) [>] 0 Then
+            Dim words() As String
+            words = Split(currentLine, " ")
+            For j = LBound(words) To UBound(words)
+                If Len(words(j)) [>] 0 </t></si><si><t xml:space="preserve">Then
+                    ReDim Preserve result(UBound(result) + 1)
+                    result(UBound(result)) = words(j)
+                End If
+            Next j
+        End If
+
+        ' Add a marker for the end of a line if it's not the last one
+       </t></si><si><t xml:space="preserve"> If i [<] UBound(lines) Then
+            ReDim Preserve result(UBound(result) + 1)
+            result(UBound(result)) = Chr(10)
+        End If
+    Next i
+
+    splitPreservingNewLines = result
+End Function
+
+
+
+' Helper function:  Encode specials
+Public </t></si><si><t xml:space="preserve">Function camelEncodeSpecialCharacters(ByVal str As String) As String
+    Dim specialCharEncodings As Collection
+    Dim key As Variant
+    Dim quo As String
+    Dim i As Long
+    
+    ' Initialize the collection with special character and encoding pairs
+  </t></si><si><t xml:space="preserve">  quo = Chr$(34)
+    Set specialCharEncodings = New Collection
+    With specialCharEncodings
+        ' Dot replacements
+        .Add Array("_P3__", " . ")
+        .Add Array("_P2__", " .")
+        .Add Array("_P__", ". ")
+        .Add Array("_p__", ".")
+  </t></si><si><t xml:space="preserve">      ' Comma replacements
+        .Add Array("_C3__", " , ")
+        .Add Array("_C2__", " ,")
+        .Add Array("_C__", ", ")
+        .Add Array("_c__", ",")
+        ' Question mark replacements
+        .Add Array("_Q3__", " ? ")
+        .Add Array("_Q2</t></si><si><t xml:space="preserve">__", " ?")
+        .Add Array("_Q__", "? ")
+        .Add Array("_q__", "?")
+        ' Exclamation mark replacements
+        .Add Array("_E3__", " ! ")
+        .Add Array("_E2__", " !")
+        .Add Array("_E__", "! ")
+        .Add Array("_e__", "!")
+      </t></si><si><t xml:space="preserve">  ' Semicolon replacements
+        .Add Array("_SC3__", " ; ")
+        .Add Array("_SC2__", " ;")
+        .Add Array("_SC__", "; ")
+        .Add Array("_sc__", ";")
+        ' Colon replacements
+        .Add Array("_D3__", " : ")
+        .Add Array("_D2__",</t></si><si><t xml:space="preserve"> " :")
+        .Add Array("_D__", ": ")
+        .Add Array("_d__", ":")
+        ' Percent sign replacements
+        .Add Array("_PT3__", " % ")
+        .Add Array("_PT2__", " %")
+        .Add Array("_PT__", "% ")
+        .Add Array("_pt__", "%")
+        ' </t></si><si><t>Open parenthesis replacements
+        .Add Array("_OP3__", " ( ")
+        .Add Array("_OP2__", " (")
+        .Add Array("_OP__", "( ")
+        .Add Array("_op__", "(")
+        ' Close parenthesis replacements
+        .Add Array("_CP3__", " ) ")
+        .Ad</t></si><si><t>d Array("_CP2__", " )")
+        .Add Array("_CP__", ") ")
+        .Add Array("_cp__", ")")
+        ' Open curly brace replacements
+        .Add Array("_OCP3__", " { ")
+        .Add Array("_OCP2__", " {")
+        .Add Array("_OCP__", "{ ")
+        .Add Arra</t></si><si><t xml:space="preserve">y("_ocp__", "{")
+        ' Close curly brace replacements
+        .Add Array("_CCP3__", " } ")
+        .Add Array("_CCP2__", " }")
+        .Add Array("_CCP__", "} ")
+        .Add Array("_ccp__", "}")
+        ' Open square bracket replacements
+        .Add </t></si><si><t>Array("_OSP3__", " [ ")
+        .Add Array("_OSP2__", " [")
+        .Add Array("_OSP__", "[ ")
+        .Add Array("_osp__", "[")
+        ' Close square bracket replacements
+        .Add Array("_CSP3__", " ] ")
+        .Add Array("_CSP2__", " ]")
+        .A</t></si><si><t xml:space="preserve">dd Array("_CSP__", "] ")
+        .Add Array("_csp__", "]")
+        ' Tilde replacements
+        .Add Array("_T3__", " ~ ")
+        .Add Array("_T2__", " ~")
+        .Add Array("_T__", "~ ")
+        .Add Array("_t__", "~")
+        ' Ampersand replacements
+ </t></si><si><t xml:space="preserve">       .Add Array("_AMP3__", " [&] ")
+        .Add Array("_AMP2__", " [&]")
+        .Add Array("_AMP__", "[&] ")
+        .Add Array("_amp__", "[&]")
+        ' Plus sign replacements
+        .Add Array("_ADD3__", " + ")
+        .Add Array("_ADD2__", " +")
+        .</t></si><si><t>Add Array("_ADD__", "+ ")
+        .Add Array("_add__", "+")
+        ' Minus sign replacements
+        .Add Array("_MIN3__", " - ")
+        .Add Array("_MIN2__", " -")
+        .Add Array("_MIN__", "- ")
+        .Add Array("_min__", "-")
+        ' Division s</t></si><si><t>ign replacements
+        .Add Array("_DIV3__", " / ")
+        .Add Array("_DIV2__", " /")
+        .Add Array("_DIV__", "/ ")
+        .Add Array("_div__", "/")
+        ' Multiplicator sign replacements
+        .Add Array("_MUL3__", " * ")
+        .Add Array</t></si><si><t>("_MUL2__", " *")
+        .Add Array("_MUL__", "* ")
+        .Add Array("_mul__", "*")
+        ' Equal sign replacements
+        .Add Array("_EQU3__", " = ")
+        .Add Array("_EQU2__", " =")
+        .Add Array("_EQU__", "= ")
+        .Add Array("_equ__"</t></si><si><t>, "=")
+        ' Less than sign replacements
+        .Add Array("_ST3__", " [<] ")
+        .Add Array("_ST2__", " [<]")
+        .Add Array("_ST__", "[<] ")
+        .Add Array("_st__", "[<]")
+        ' Greater than sign replacements
+        .Add Array("_GT3__", " [>]</t></si><si><t xml:space="preserve"> ")
+        .Add Array("_GT2__", " [>]")
+        .Add Array("_GT__", "[>] ")
+        .Add Array("_gt__", "[>]")
+        ' Hash/pound sign replacements
+        .Add Array("_NR3__", " # ")
+        .Add Array("_NR2__", " #")
+        .Add Array("_NR__", "# ")
+      </t></si><si><t xml:space="preserve">  .Add Array("_nr__", "#")
+        ' Quotation mark replacements
+        .Add Array("_QUO3__", " " [&] quo [&] " ")
+        .Add Array("_QUO2__", " " [&] quo)
+        .Add Array("_QUO__", quo [&] " ")
+        .Add Array("_quo__", quo)
+        ' @ replacements
+    </t></si><si><t xml:space="preserve">    .Add Array("_AT3__", " @ ")
+        .Add Array("_AT2__", " @")
+        .Add Array("_AT__", "@ ")
+        .Add Array("_at__", "@")
+        ' Ñ replacements
+        .Add Array("_EUR3__", " Ñ ")
+        .Add Array("_EUR2__", " Ñ")
+        .Add Array("_EUR</t></si><si><t>__", "Ñ ")
+        .Add Array("_eur__", "Ñ")
+        ' Ñ replacements
+        .Add Array("_USD3__", " $ ")
+        .Add Array("_USD2__", " $")
+        .Add Array("_USD__", "$ ")
+        .Add Array("_usd__", "$")
+        ' Apostrophe (')
+        .Add Array(</t></si><si><t>"_A3__", " ' ")
+        .Add Array("_A2__", " '")
+        .Add Array("_A__", "' ")
+        .Add Array("_a__", "'")
+        ' Backslash (\)
+        .Add Array("_BSL3__", " \ ")
+        .Add Array("_BSL2__", " \")
+        .Add Array("_BSL__", "\ ")
+        .</t></si><si><t xml:space="preserve"> ' Handle multiple consecutive special characters with only two underscores separating them
+    'str = Replace(str, "____", "__")
+    
+    camelEncodeSpecialCharacters = str
+End Function
+
+
+Public </t></si><si><t>Function camelDecodeSpecialCharacters(ByVal str As String) As String
+    Dim specialCharEncodings As Collection
+    Dim key As Variant
+    Dim quo As String
+    
+    'str = Replace(str, "__", "____")
+    
+    ' Initialize the collection with special charac</t></si><si><t xml:space="preserve">ter and encoding pairs
+    quo = Chr$(34)
+    
+    Set specialCharDecodings = New Collection
+    With specialCharDecodings
+        ' Dot replacements
+        .Add Array(" . ", "_P3__")
+        .Add Array(" .", "_P2__")
+        .Add Array(". ", "_P__")
+    </t></si><si><t xml:space="preserve">    .Add Array(".", "_p__")
+    
+        ' Comma replacements
+        .Add Array(" , ", "_C3__")
+        .Add Array(" ,", "_C2__")
+        .Add Array(", ", "_C__")
+        .Add Array(",", "_c__")
+    
+        ' Question mark replacements
+        .Add Array</t></si><si><t>(" ? ", "_Q3__")
+        .Add Array(" ?", "_Q2__")
+        .Add Array("? ", "_Q__")
+        .Add Array("?", "_q__")
+
+        ' Exclamation mark replacements
+        .Add Array(" ! ", "_E3__")
+        .Add Array(" !", "_E2__")
+        .Add Array("! ", "_E__</t></si><si><t>")
+        .Add Array("!", "_e__")
+    
+        ' Semicolon replacements
+        .Add Array(" ; ", "_SC3__")
+        .Add Array(" ;", "_SC2__")
+        .Add Array("; ", "_SC__")
+        .Add Array(";", "_sc__")
+    
+        ' Colon replacements
+        .Ad</t></si><si><t>d Array(" : ", "_D3__")
+        .Add Array(" :", "_D2__")
+        .Add Array(": ", "_D__")
+        .Add Array(":", "_d__")
+    
+        ' Percent sign replacements
+        .Add Array(" % ", "_PT3__")
+        .Add Array(" %", "_PT2__")
+        .Add Array("%</t></si><si><t xml:space="preserve"> ", "_PT__")
+        .Add Array("%", "_pt__")
+    
+        ' Open parenthesis replacements
+        .Add Array(" ( ", "_OP3__")
+        .Add Array(" (", "_OP2__")
+        .Add Array("( ", "_OP__")
+        .Add Array("(", "_op__")
+    
+        ' Close parent</t></si><si><t>hesis replacements
+        .Add Array(" ) ", "_CP3__")
+        .Add Array(" )", "_CP2__")
+        .Add Array(") ", "_CP__")
+        .Add Array(")", "_cp__")
+    
+        ' Open curly brace replacements
+        .Add Array(" { ", "_OCP3__")
+        .Add Arra</t></si><si><t>y(" {", "_OCP2__")
+        .Add Array("{ ", "_OCP__")
+        .Add Array("{", "_ocp__")
+    
+        ' Close curly brace replacements
+        .Add Array(" } ", "_CCP3__")
+        .Add Array(" }", "_CCP2__")
+        .Add Array("} ", "_CCP__")
+        .Add A</t></si><si><t>rray("}", "_ccp__")
+    
+        ' Open square bracket replacements
+        .Add Array(" [ ", "_OSP3__")
+        .Add Array(" [", "_OSP2__")
+        .Add Array("[ ", "_OSP__")
+        .Add Array("[", "_osp__")
+    
+        ' Close square bracket replacemen</t></si><si><t xml:space="preserve">ts
+        .Add Array(" ] ", "_CSP3__")
+        .Add Array(" ]", "_CSP2__")
+        .Add Array("] ", "_CSP__")
+        .Add Array("]", "_csp__")
+    
+        ' Tilde replacements
+        .Add Array(" ~ ", "_T3__")
+        .Add Array(" ~", "_T2__")
+        </t></si><si><t>.Add Array("~ ", "_T__")
+        .Add Array("~", "_t__")
+    
+        ' Ampersand replacements
+        .Add Array(" [&] ", "_AMP3__")
+        .Add Array(" [&]", "_AMP2__")
+        .Add Array("[&] ", "_AMP__")
+        .Add Array("[&]", "_amp__")
+    
+        ' Plus</t></si><si><t xml:space="preserve"> sign replacements
+        .Add Array(" + ", "_ADD3__")
+        .Add Array(" +", "_ADD2__")
+        .Add Array("+ ", "_ADD__")
+        .Add Array("+", "_add__")
+    
+        ' Minus sign replacements
+        .Add Array(" - ", "_MIN3__")
+        .Add Array(</t></si><si><t>" -", "_MIN2__")
+        .Add Array("- ", "_MIN__")
+        .Add Array("-", "_min__")
+    
+        ' Division sign replacements
+        .Add Array(" / ", "_DIV3__")
+        .Add Array(" /", "_DIV2__")
+        .Add Array("/ ", "_DIV__")
+        .Add Array("</t></si><si><t>/", "_div__")
+        
+        ' Multiplicator sign replacements
+        .Add Array(" * ", "_MUL3__")
+        .Add Array(" *", "_MUL2__")
+        .Add Array("* ", "_MUL__")
+        .Add Array("*", "_mul__")
+    
+        ' Equal sign replacements
+        .A</t></si><si><t>dd Array(" = ", "_EQU3__")
+        .Add Array(" =", "_EQU2__")
+        .Add Array("= ", "_EQU__")
+        .Add Array("=", "_equ__")
+    
+        ' Less than sign replacements
+        .Add Array(" [<] ", "_ST3__")
+        .Add Array(" [<]", "_ST2__")
+        .A</t></si><si><t xml:space="preserve">dd Array("[<] ", "_ST__")
+        .Add Array("[<]", "_st__")
+    
+        ' Greater than sign replacements
+        .Add Array(" [>] ", "_GT3__")
+        .Add Array(" [>]", "_GT2__")
+        .Add Array("[>] ", "_GT__")
+        .Add Array("[>]", "_gt__")
+    
+        ' </t></si><si><t>Hash/pound sign replacements
+        .Add Array(" # ", "_NR3__")
+        .Add Array(" #", "_NR2__")
+        .Add Array("# ", "_NR__")
+        .Add Array("#", "_nr__")
+    
+        ' Quotation mark replacements
+        .Add Array(" " [&] quo [&] " ", "_QUO3__")</t></si><si><t xml:space="preserve">
+        .Add Array(" " [&] quo, "_QUO2__")
+        .Add Array(quo [&] " ", "_QUO__")
+        .Add Array(quo, "_quo__")
+    
+        ' @ replacements
+        .Add Array(" @ ", "_AT3__")
+        .Add Array(" @", "_AT2__")
+        .Add Array("@ ", "_AT__")
+     </t></si><si><t xml:space="preserve">   .Add Array("@", "_at__")
+    
+        ' Ñ replacements
+        .Add Array(" Ñ ", "_EUR3__")
+        .Add Array(" Ñ", "_EUR2__")
+        .Add Array("Ñ ", "_EUR__")
+        .Add Array("Ñ", "_eur__")
+    
+        ' $ replacements
+        .Add Array(" $ ", </t></si><si><t xml:space="preserve">"_USD3__")
+        .Add Array(" $", "_USD2__")
+        .Add Array("$ ", "_USD__")
+        .Add Array("$", "_usd__")
+    
+        ' Apostrophe (')
+        .Add Array(" ' ", "_A3__")
+        .Add Array(" '", "_A2__")
+        .Add Array("' ", "_A__")
+        </t></si><si><t>.Add Array("'", "_a__")
+    
+        ' Backslash (\)
+        .Add Array(" \ ", "_BSL3__")
+        .Add Array(" \", "_BSL2__")
+        .Add Array("\ ", "_BSL__")
+        .Add Array("\", "_bsl__")
+        
+        .Add Array("èèè", "_u__") 'workaround to pre</t></si><si><t>serve underscores from input
+        
+        '.add Array("", "__") ' remove remaining double underscores
+        .Add Array(" ", "_") 'replaces single underscores used to for abbreviations back to spaces
+        
+        .Add Array("_", "èèè")
+    
+    En</t></si><si><t>Function replaceUnderscores(ByVal inputStr As String) As String
+    Dim resultStr As String
+    Dim i As Long
+    Dim strLength As Long
+    Dim currentChar As String
+    Dim previousChar As String
+    Dim nextChar As String
+    
+    resultStr = ""
+    strL</t></si><si><t>aracter is an underscore
+        If currentChar = "_" Then
+            ' Replace underscore only if the previous character is not a capitalized letter or digit and the next is a character
+            ' Replace only the underscores we did not create in "Add</t></si><si><t xml:space="preserve">Underscore"
+            If Not ((previousChar Like "[A-Z]") Or (previousChar Like "[0-9]") And nextChar [<][>] "") Then
+                resultStr = resultStr [&] "_u__"
+            Else
+                resultStr = resultStr [&] "_"
+            End If
+        Else
+</t></si><si><t xml:space="preserve">            ' Append the current character if it's not an underscore
+            resultStr = resultStr [&] currentChar
+        End If
+    Next i
+    
+    replaceUnderscores = resultStr
+    'Debug.Print ReplaceUnderscores
+End Function
+
+</t></si><si><t>Function handleLists(inputString As String) As String
+    Dim lines() As String
+    Dim i As Long
+    Dim currentLine As String
+    Dim firstWord As String
+    Dim romanNumerals As Variant
+    Dim needsLowercase As Boolean
+    
+    ' Define Roman numeral p</t></si><si><t xml:space="preserve">atterns
+    romanNumerals = Array("i", "ii", "iii", "iv", "v", "vi", "vii", "viii", "ix", "x")
+    
+    ' Split the input string into lines (using Chr(10) for line breaks)
+    lines = Split(inputString, Chr(10))
+    
+    ' Loop through each line
+    For i </t></si><si><t>= LBound(lines) To UBound(lines)
+        currentLine = lines(i)
+        needsLowercase = False
+        
+        ' Extract the first word of the current line
+        If InStr(1, LTrim(currentLine), " ") [>] 0 Then
+            firstWord = Left(LTrim(currentLin</t></si><si><t>e), InStr(1, LTrim(currentLine), " ") - 1)
+        Else
+            firstWord = LTrim(currentLine)
+        End If
+        
+        ' Check if the first word is a single letter or a Roman numeral
+        If (Len(firstWord) = 1 And firstWord Like "[A-Za-z]")</t></si><si><t xml:space="preserve"> Or _
+           Not IsError(Application.Match(LCase(firstWord), romanNumerals, 0)) Then
+            ' Check the previous line (ignoring leading spaces)
+            If i [>] LBound(lines) Then
+                Dim prevFirstWord As String
+                If In</t></si><si><t xml:space="preserve">Str(1, LTrim(lines(i - 1)), " ") [>] 0 Then
+                    prevFirstWord = Left(LTrim(lines(i - 1)), InStr(1, LTrim(lines(i - 1)), " ") - 1)
+                Else
+                    prevFirstWord = LTrim(lines(i - 1))
+                End If
+            </t></si><si><t xml:space="preserve">    If (Len(prevFirstWord) = 1 And prevFirstWord Like "[A-Za-z]") Or _
+                   Not IsError(Application.Match(LCase(prevFirstWord), romanNumerals, 0)) Then
+                    needsLowercase = True
+                End If
+            End If
+      </t></si><si><t xml:space="preserve">      
+            ' Check the next line (ignoring leading spaces)
+            If i [<] UBound(lines) Then
+                Dim nextFirstWord As String
+                If InStr(1, LTrim(lines(i + 1)), " ") [>] 0 Then
+                    nextFirstWord = Left(LTr</t></si><si><t xml:space="preserve">im(lines(i + 1)), InStr(1, LTrim(lines(i + 1)), " ") - 1)
+                Else
+                    nextFirstWord = LTrim(lines(i + 1))
+                End If
+                If (Len(nextFirstWord) = 1 And nextFirstWord Like "[A-Za-z]") Or _
+               </t></si><si><t xml:space="preserve">    Not IsError(Application.Match(LCase(nextFirstWord), romanNumerals, 0)) Then
+                    needsLowercase = True
+                End If
+            End If
+        End If
+        
+        ' Check if the first word starts with a single lowercase let</t></si><si><t>ke "[A-Za-z0-9]" Then
+            needsLowercase = True
+        End If
+        
+        ' Apply lowercase to the entire first word if conditions are met
+        If needsLowercase Then
+            lines(i) = Replace(currentLine, firstWord, LCase(firstWord),</t></si><si><t>Sub tableSelection()
+    'On Error GoTo ErrorHandler
+
+    transferTime = Now
+    fulltransfer = False
+
+    ' Mode selection
+    Dim modeSelection As UserForm_TransferMode
+    Set modeSelection = New UserForm_TransferMode
+    modeSelection.Show
+
+    If tran</t></si><si><t>sferMode = "" Then
+        MsgBox "No transfer mode selected. Program terminates."
+        Exit Sub
+    End If
+
+    ' Source and target selection
+    Dim sourceSelection As UserForm_SourceTable
+    Set sourceSelection = New UserForm_SourceTable
+    sourceS</t></si><si><t>election.Show
+
+    If fulltransfer = False Then
+
+        Dim targetSelection As UserForm_TargetTable
+        Set targetSelection = New UserForm_TargetTable
+        targetSelection.Show
+
+        If sourceTable = "" Or targetTable = "" Then
+            ' End</t></si><si><t>Excel Column - Explicit Excel Formula</t></si><si><t>meta_DocumentVersions</t></si><si><t>Document Management</t></si><si><t>meta_NonCapitalizedTitleWords</t></si><si><t>Non Capitalized Title Words</t></si><si><t>Table Patterns</t></si><si><t>Code Templates</t></si><si><t>meta_SimpleTestPattern</t></si><si><t>Simple Test Pattern</t></si><si><t>Formula:=[@[Date Tag]][&]"_"[&][@Name][&]"_"[&][@Version][&]".xlsm"</t></si><si><t>Formula:=IF(TRIM([@Package])="","",TRIM(LOWER([@Package]))[&]"::")[&][@Display]</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Containing Class]] ) = "",
+        "",
+    IF( LEFT([@[Containing Class]],1)="_",
+        RIGHT([@[Containing Class]],LEN([@[Containing Class]])-1),
+    IF( TRIM( [@Package] )
+            [<][>] TRIM( INDEX( meta_Classifiers[Package], MATCH( [@[Containing Class]], meta_Classifiers[ID],0 ) ) ),
+        TRIM( INDEX( meta_Classifiers[Package], MATCH( [@[Containing Class]], meta_Classifiers[ID], 0 ) ) )
+            [&] "::"
+            [&] INDEX( meta_Classifiers[Display], MATCH( [@[Containing Class]], meta_Classifiers[ID], 0 ) ),
+        INDEX( meta_Classifiers[Display], MATCH( [@[Containing Class]], meta_Classifiers[ID], 0 ) )
+    ))), "")</t></si><si><t>Formula:=IF([@[Containing Class:display]]="","",[@[Containing Class:display]][&]".")[&][@[Display without Class]]</t></si><si><t>Formula:="[@["[&][@[Name or Type]][&]":src]]"</t></si><si><t>Formula:=IF([@[Feature - VBA Type]]="public","Public Function "[&][@[Name or Type Camel Case Lower]][&]"("[&][@[Function - Parameters in VBA Header]][&]") As "[&][@[Type Derived:display]],
+IF([@[Feature - VBA Type]]="method","METHOD:TODO",""))</t></si><si><t>Formula:=TRIM(SUBSTITUTE([@Name]," ",""))</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Parent:src]] ) = "",
+        "",
+    IF( LEFT([@[Parent:src]],1)="_",
+        RIGHT([@[Parent:src]],LEN([@[Parent:src]])-1),
+    IF( TRIM( [@Package] )
+            [<][>] TRIM( INDEX( [Package], MATCH( [@[Parent:src]], [ID],0 ) ) ),
+        TRIM( INDEX( [Package], MATCH( [@[Parent:src]], [ID], 0 ) ) )
+            [&] "::"
+            [&] INDEX( [Display], MATCH( [@[Parent:src]], [ID], 0 ) ),
+        INDEX( [Display], MATCH( [@[Parent:src]], [ID], 0 ) )
+    ))), "")</t></si><si><t>Formula:=IFNA(IF([@[Class:src]]="","util",INDEX(meta_Classifiers[Package],MATCH([@[Class:src]],meta_Classifiers[ID],0))),"")</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Class:src]] ) = "",
+        "",
+    IF( LEFT([@[Class:src]],1)="_",
+        RIGHT([@[Class:src]],LEN([@[Class:src]])-1),
+    IF( TRIM( [@Package] )
+            [<][>] TRIM( INDEX( meta_Classifiers[Package], MATCH( [@[Class:src]], meta_Classifiers[ID],0 ) ) ),
+        TRIM( INDEX( meta_Classifiers[Package], MATCH( [@[Class:src]], meta_Classifiers[ID], 0 ) ) )
+            [&] "::"
+            [&] INDEX( meta_Classifiers[Display], MATCH( [@[Class:src]], meta_Classifiers[ID], 0 ) ),
+        INDEX( meta_Classifiers[Display], MATCH( [@[Class:src]], meta_Classifiers[ID], 0 ) )
+    ))), "")</t></si><si><t>Formula:=IF(TRIM([@Feature])="","",INDEX(meta_TypedModelElements[Type Derived],MATCH([@[Feature:src]],meta_TypedModelElements[ID],0)))</t></si><si><t>Formula:=IF([@[Class:src]]="","_Datatype","_Class")</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Feature:src]] ) = "",
+        "",
+
+        INDEX( meta_TypedModelElements[Display without Class], MATCH( [@[Feature:src]], meta_TypedModelElements[ID], 0 ) )
+ ), "")</t></si><si><t>Formula:=IF(TRIM([@Part])="","",IF(
+  TRIM([@Package])="",
+          "",
+          [@Package][&]"::")
+[&][@Part])</t></si><si><t>Formula:=[@Class][&]IF([@Feature]=""," ","."[&][@Feature][&]" ")[&]
+IF(LEN([@Class])+LEN([@Feature])[>]65,REPT(" ",78+IF([@Feature]="",1,0)-(LEN([@Class])+LEN([@Feature]))),
+IF(LEN([@Class])+LEN([@Feature])[>]55,REPT(" ",68+IF([@Feature]="",1,0)-(LEN([@Class])+LEN([@Feature]))),
+IF(LEN([@Class])+LEN([@Feature])[>]45,REPT(" ",58+IF([@Feature]="",1,0)-(LEN([@Class])+LEN([@Feature]))),
+IF(LEN([@Class])+LEN([@Feature])[>]35,REPT(" ",48+IF([@Feature]="",1,0)-(LEN([@Class])+LEN([@Feature]))),
+IF(LEN([@Class])+LEN([@Feature])[>]25,REPT(" ",38+IF([@Feature]="",1,0)-(LEN([@Class])+LEN([@Feature]))),
+IF(LEN([@Class])+LEN([@Feature])[>]15,REPT(" ",28+IF([@Feature]="",1,0)-(LEN([@Class])+LEN([@Feature]))),
+REPT(" ",18+IF([@Feature]="",1,0)-(LEN([@Class])+LEN([@Feature])))
+))))))
+[&]
+[@Kind][&]
+IF([@Line]="","",REPT(" ",10-LEN([@Kind]))[&]TEXT([@Line],"00"))</t></si><si><t>Formula:=[@[Class:src]][&]"_"[&][@Feature][&]"_"[&][@Kind]</t></si><si><t>Formula:=[@[Rule Biz ID Without Line]][&]"_"[&][@Line]</t></si><si><t>Formula:=IF([@[Line-1]]="","",INDEX([Part:src],MATCH([@[Rule Biz ID Without Line]][&]"_"[&][@[Line-1]],[Rule Biz ID],0)))</t></si><si><t>Formula:=IF(TRIM([@Line])="","",IF([@Line]=1,"",[@Line]-1))</t></si><si><t>Formula:=IF(TRIM([@Line])="",0,IF([@Line]=1,0,
+999))</t></si><si><t>Formula:=IF([@Base]="self",[@[Class:src]],
+IF([@Base]="super", "TODO type of overwritten version of this property or function. Needs resolution from feature to overwritten/specialized feature",
+IF([@Base]="trg", [@[Feature Type]],
+IF([@Base]="src", [@[Feature Type]],
+IF([@Base]="obj", "TODO type of result of LHS object rule, to be used in RHS new value rule",
+IF([@Base]="allInstances", IF([@Cast]="",[@[Class:src]], [@[Cast:src]]),
+IF([@[Base as Parameter]][<][>]"",INDEX(meta_TypedModelElements[Type Derived],MATCH([@[Base as Parameter]],meta_TypedModelElements[ID],0)),
+"_String")))))))</t></si><si><t>Formula:=IFNA(INDEX(meta_TypedModelElements[ID],MATCH([@[Feature:src]][&]"."[&][@Base],meta_TypedModelElements[ID],0)),"")</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Property 1:src]] ) = "",
+        "",
+
+        INDEX( meta_TypedModelElements[Display without Class], MATCH( [@[Property 1:src]], meta_TypedModelElements[ID], 0 ) )
+ ), "")</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Property 2:src]] ) = "",
+        "",
+
+        INDEX( meta_TypedModelElements[Display without Class], MATCH( [@[Property 2:src]], meta_TypedModelElements[ID], 0 ) )
+ ), "")</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Cast:src]] ) = "",
+        "",
+    IF( LEFT([@[Cast:src]],1)="_",
+        RIGHT([@[Cast:src]],LEN([@[Cast:src]])-1),
+    IF( TRIM( [@Package] )
+            [<][>] TRIM( INDEX( meta_Classifiers[Package], MATCH( [@[Cast:src]], meta_Classifiers[ID],0 ) ) ),
+        TRIM( INDEX( meta_Classifiers[Package], MATCH( [@[Cast:src]], meta_Classifiers[ID], 0 ) ) )
+            [&] "::"
+            [&] INDEX( meta_Classifiers[Display], MATCH( [@[Cast:src]], meta_Classifiers[ID], 0 ) ),
+        INDEX( meta_Classifiers[Display], MATCH( [@[Cast:src]], meta_Classifiers[ID], 0 ) )
+    ))), "")</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Property 3:src]] ) = "",
+        "",
+
+        INDEX( meta_TypedModelElements[Display without Class], MATCH( [@[Property 3:src]], meta_TypedModelElements[ID], 0 ) )
+ ), "")</t></si><si><t>Formula:=+"1"</t></si><si><t>Formula:=IF([@[Manual VBA Code]][<][>]"",[@[Manual VBA Code]],"TODO")</t></si><si><t>Formula:=IF([@Property][<][>]"","",[@Package][&]"::"[&]INDEX(meta_Classifiers[Display],MATCH([@[Owning Table Instances Class]],meta_Classifiers[ID],0))[&]"."[&]camelCaseLower([@[Excel Column - Label Actual]]))</t></si><si><t>Formula:=IFNA(IF([@[Property Owning Class]]=[@[Owning Table Instances Class]],"x",
+IF([@[Property Owning Class]]=[@[Generalization 1]],TRUE,
+IF([@[Property Owning Class]]=[@[Generalization 2]],TRUE,
+IF([@[Property Owning Class]]=[@[Generalization 3]],TRUE,
+IF([@[Property Owning Class]]=[@[Generalization 4]],TRUE,
+IF([@[Property Owning Class]]=[@[Generalization 5]],TRUE,
+IF([@[Property Owning Class]]=[@[Generalization 6]],TRUE,FALSE
+))))))),FALSE)</t></si><si><t>Formula:=OR([@[Is From Specialization 1]],[@[Is From Specialization 2]],[@[Is From Specialization 3]],[@[Is From Specialization 4]],[@[Is From Specialization 5]],[@[Is From Specialization 6]])</t></si><si><t>Formula:=INDEX(meta_TypedModelElements[Name or Type],MATCH([@Property],meta_TypedModelElements[ID],0))</t></si><si><t>Formula:=INDEX(meta_TypedModelElements[Property - Changeable],MATCH([@Property],meta_TypedModelElements[ID],0))</t></si><si><t>Formula:=IF([@[Property Owning Class is Specialization of Instance Class]],[@[Property Owning Class Name]][&]" - ","")[&][@[Property Name]][&]
+IF(AND([@[Property Kind]]="_Reference",[@[Property Changeable]]="x",[@[Semantics Case]]="src"),":src",
+IF(AND([@[Property Kind]]="_Reference",[@[Property Changeable]]="x",[@[Semantics Case]]="display"),"",
+IF(AND([@[Property Kind]]="_Reference",[@[Property Changeable]]="x"),":"[&][@[Semantics Case]],
+IF(AND([@[Property Changeable]]="x",[@[Semantics Case]]="src"),"",
+IF(AND([@[Property Changeable]]="x"),":"[&][@[Semantics Case]],
+IF(AND([@[Property Changeable]][<][>]"x",[@[Semantics Case]]="derive"),"",
+IF(AND([@[Property Changeable]][<][>]"x"),":"[&][@[Semantics Case]],"TODO")))))))</t></si><si><t>Formula:=IF([@Package]="","",[@Package][&]"::")[&][@Display]</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Branch of Table:src]] ) = "",
+        "",
+    IF( LEFT([@[Branch of Table:src]],1)="_",
+        RIGHT([@[Branch of Table:src]],LEN([@[Branch of Table:src]])-1),
+    IF( TRIM( [@Package] )
+            [<][>] TRIM( INDEX( [Package], MATCH( [@[Branch of Table:src]], [ID],0 ) ) ),
+        TRIM( INDEX( [Package], MATCH( [@[Branch of Table:src]], [ID], 0 ) ) )
+            [&] "::"
+            [&] INDEX( [Name], MATCH( [@[Branch of Table:src]], [ID], 0 ) ),
+        INDEX( [Name], MATCH( [@[Branch of Table:src]], [ID], 0 ) )
+    ))), "")</t></si><si><t>Formula:=IF(ROW()=2,"",INDEX([Excel Formula for Column "Excel Column - Label Actual" of Table Columns], ROW()-2))</t></si><si><t>Formula:=[@[ExceFormula Previous Line ]][&]
+IF([@[Excel Table - Excel Name]][<][>]"","IF([@[Owning Table:src]]="[&]CHAR(34)[&]"_"[&][@[Excel Table - Excel Name]][&]CHAR(34)[&]",INDEX("[&][@[Excel Table - Excel Name]][&]"[#Headers],[@Position]),
+","")</t></si><si><t>Formula:=TRIM(SUBSTITUTE([@[Template Begin]]," ",""))</t></si><si><t>Formula:= IFNA( IF( TRIM( [@[Matched Patern 1:src]] ) = "",
+        "",
+    IF( LEFT([@[Matched Patern 1:src]],1)="_",
+        RIGHT([@[Matched Patern 1:src]],LEN([@[Matched Patern 1:src]])-1),
+    IF( TRIM( [@Package] )
+            [<][>] TRIM( INDEX( [Package], MATCH( [@[Matched Patern 1:src]], [ID],0 ) ) ),
+        TRIM( INDEX( [Package], MATCH( [@[Matched Patern 1:src]], [ID], 0 ) ) )
+            [&] "::"
+            [&] INDEX( [Display], MATCH( [@[Matched Patern 1:src]], [ID], 0 ) ),
+        INDEX( [Display], MATCH( [@[Matched Patern 1:src]], [ID], 0 ) )
+    ))), "")</t></si><si><t>Formula:=stringToBusiness([@[String Value 1]])</t></si><si><t>Formula:=camelCaseUpper([@[String Value 1]])</t></si><si><t>Formula:=camelCaseToBusiness([@[Test CamelCaseUpper]])</t></si><si><t>Formula:=EXACT(camelCaseLower([@[String Value 1]]),businessToCamelCaseLower(stringToBusiness([@[String Value 1]])))</t></si><si><t>Formula:=EXACT(camelCaseUpper([@[String Value 1]]),businessToCamelCaseUpper(stringToBusiness([@[String Value 1]])))</t></si><si><t>Formula:=EXACT(camelCaseToBusiness(
+businessToCamelCaseUpper(
+stringToBusiness([@[String Value 1]]))),
+stringToBusiness([@[String Value 1]]))</t></si><si><t>Formula:=IF(
+  TRIM([@Package])="",
+          "",
+          [@Package][&]"::")
+[&][@[T2 Name]]</t></si><si><t>Referenced Table</t></si><si><t xml:space="preserve"> 1).Value = "ID"
+            .Cells(1, 2).Value = "Kind:src"
+            .Cells(1, 3).Value = "Owning Table:src"
+            .Cells(1, 4).Value = "Position"
+            .Cells(1, 5).Value = "Stored Column Position"
+            .Cells(1, 6).Value = "Excel C</t></si><si><t>olumn - Label Overwrite"
+            .Cells(1, 7).Value = "Excel Column - Explicit Excel Formula"
+        End With
+        
+        ' Create the 'Columns_Extract' table object
+        Set newTable = NewSheet.ListObjects.Add(xlSrcRange, NewSheet.Range("A1:G</t></si><si><t xml:space="preserve">  If missingColumns [<][>] "" Then
+        MsgBox "The following mandatory columns were missing and added to the table '" [&] mainTableName [&] "':" [&] vbNewLine [&] missingColumns, vbInformation
+    Else
+        'MsgBox "All required columns already exist in the mai</t></si><si><t xml:space="preserve">n table.", vbInformation
+    End If
+    
+    Set compareExtract = tblMain
+End Function
+
+'Helper
+</t></si><si><t xml:space="preserve">Sub Worksheet_Change(ByVal cellRef As Range)
+    If cellRef.Cells.CountLarge = 1 Then
+        referingTableName = cellRef.ListObject.name
+        referingColumnName = Cells(cellRef.ListObject.Range.row, cellRef.column).Value
+        referedTableName = ""
+ </t></si><si><t>Function createTransferModeForm()
+    Dim MyUserForm As VBComponent
+    Dim CommandButton1 As MSForms.CommandButton
+    Dim CommandButton2 As MSForms.CommandButton
+    Dim N As Integer
+
+    ' Check if UserForm_TransferMode already exists
+    For N = 1 To T</t></si><si><t>ct.VBComponents.Add(vbext_ct_MSForm)
+    
+    MyUserForm.name = "UserForm_TransferMode"
+    
+    With MyUserForm
+        .Properties("Caption") = "Select Transfer Mode"
+        .Properties("Width") = 300
+        .Properties("Height") = 200
+        .Propert</t></si><si><t xml:space="preserve">ies("BorderStyle") = 1 ' Makes the form resizable
+    End With
+    
+    
+
+    ' Add "Normal Transfer" button
+    Set CommandButton1 = MyUserForm.Designer.Controls.Add("forms.CommandButton.1")
+    With CommandButton1
+        .Caption = "Normal Transfer"
+   </t></si><si><t xml:space="preserve">     .Height = 30
+        .Width = 100
+        .Left = 30
+        .Top = 50
+    End With
+
+
+    ' Add event handlers for CommandButtons
+    With MyUserForm.CodeModule
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">tical"
+        .InsertLines .CountOfLines + 1, "        End"
+        .InsertLines .CountOfLines + 1, "    End If"
+        .InsertLines .CountOfLines + 1, "End Sub"
+    
+    End With
+End Function
+
+' Subroutine to create UserForm_SourceTable
+</t></si><si><t>Function createSourceTableForm()
+    Dim MyUserForm As VBComponent
+    Dim CommandButton1 As MSForms.CommandButton
+    Dim ListBox1 As MSForms.ListBox
+    Dim N As Integer
+
+    ' Check if UserForm_SourceTable already exists
+    For N = 1 To ThisWorkbook.VB</t></si><si><t>Add(vbext_ct_MSForm)
+    With MyUserForm
+        .Properties("Caption") = "Select Source Table"
+        .Properties("Width") = 300
+        .Properties("Height") = 300
+        .Properties("BorderStyle") = 1 ' Makes the form resizable
+    End With
+
+    MyUse</t></si><si><t xml:space="preserve">rForm.name = "UserForm_SourceTable"
+    
+    ' Add ListBox
+    Set ListBox1 = MyUserForm.Designer.Controls.Add("Forms.ListBox.1")
+    With ListBox1
+        .name = "ListBox1"
+        .Left = 30
+        .Top = 30
+        .Width = 240
+        .Height = 150
+ </t></si><si><t xml:space="preserve">   End With
+
+    ' Add "Full Transfer (all tables)" button
+    Set CommandButton1 = MyUserForm.Designer.Controls.Add("forms.CommandButton.1")
+    With CommandButton1
+        .Caption = "Full Transfer (all tables)"
+        .Height = 30
+        .Width = 150
+</t></si><si><t xml:space="preserve">        .Left = 30
+        .Top = 200
+    End With
+
+    ' Add event handlers
+    With MyUserForm.CodeModule
+        ' CommandButton1 Click event
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">tical"
+        .InsertLines .CountOfLines + 1, "        End"
+        .InsertLines .CountOfLines + 1, "    End If"
+        .InsertLines .CountOfLines + 1, "End Sub"
+    
+    End With
+End Function
+
+' Subroutine to create UserForm_TargetTable
+</t></si><si><t>Function createTargetTableForm()
+    Dim MyUserForm As VBComponent
+    Dim CommandButton1 As MSForms.CommandButton
+    Dim ListBox1 As MSForms.ListBox
+    Dim N As Integer
+
+    ' Check if UserForm_TargetTable already exists
+    For N = 1 To ThisWorkbook.VB</t></si><si><t>Add(vbext_ct_MSForm)
+    With MyUserForm
+        .Properties("Caption") = "Select Target Table"
+        .Properties("Width") = 300
+        .Properties("Height") = 300
+        .Properties("BorderStyle") = 1 ' Makes the form resizable
+    End With
+    
+    M</t></si><si><t xml:space="preserve">yUserForm.name = "UserForm_TargetTable"
+
+    ' Add ListBox
+    Set ListBox1 = MyUserForm.Designer.Controls.Add("Forms.ListBox.1")
+    With ListBox1
+        .name = "ListBox1"
+        .Left = 30
+        .Top = 30
+        .Width = 240
+        .Height = 150
+ </t></si><si><t xml:space="preserve">   End With
+
+    ' Add "Continue without Target" button
+    Set CommandButton1 = MyUserForm.Designer.Controls.Add("forms.CommandButton.1")
+    With CommandButton1
+        .Caption = "Continue without Target"
+        .Height = 30
+        .Width = 150
+      </t></si><si><t xml:space="preserve">  .Left = 30
+        .Top = 200
+    End With
+
+    ' Add event handlers
+    With MyUserForm.CodeModule
+        ' CommandButton1 Click event
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">tical"
+        .InsertLines .CountOfLines + 1, "        End"
+        .InsertLines .CountOfLines + 1, "    End If"
+        .InsertLines .CountOfLines + 1, "End Sub"
+    End With
+End Function
+
+' Subroutine to create UserForm_SourceInvalid
+</t></si><si><t xml:space="preserve">Function createSourceInvalidForm()
+    Dim MyUserForm As VBComponent
+    Dim CommandButton1 As MSForms.CommandButton
+    Dim CommandButton2 As MSForms.CommandButton
+    Dim Label As MSForms.Label
+    Dim N As Integer
+
+    ' Check if UserForm_SourceInvalid </t></si><si><t xml:space="preserve">t MyUserForm = ThisWorkbook.VBProject.VBComponents.Add(vbext_ct_MSForm)
+    With MyUserForm
+        .Properties("Caption") = "Invalid Source Table"
+        .Properties("Width") = 350
+        .Properties("Height") = 150
+        .Properties("BorderStyle") = </t></si><si><t>1 ' Makes the form resizable
+    End With
+
+    MyUserForm.name = "UserForm_SourceInvalid"
+    
+    ' Add Label
+    Set Label = MyUserForm.Designer.Controls.Add("Forms.Label.1")
+    With Label
+        .Caption = "The selected source table is invalid. Should</t></si><si><t xml:space="preserve"> the selected table be fixed?"
+        .Height = 30
+        .Width = 300
+        .Left = 25
+        .Top = 20
+    End With
+
+    ' Add "Yes" button
+    Set CommandButton1 = MyUserForm.Designer.Controls.Add("forms.CommandButton.1")
+    With CommandButton1
+  </t></si><si><t xml:space="preserve">      .Caption = "Yes"
+        .Height = 30
+        .Width = 80
+        .Left = 50
+        .Top = 70
+    End With
+
+    ' Add "No (end transfer)" button
+    Set CommandButton2 = MyUserForm.Designer.Controls.Add("forms.CommandButton.1")
+    With CommandButto</t></si><si><t xml:space="preserve">n2
+        .Caption = "No (end transfer)"
+        .Height = 30
+        .Width = 120
+        .Left = 150
+        .Top = 70
+    End With
+
+    ' Add event handlers
+    With MyUserForm.CodeModule
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">tical"
+        .InsertLines .CountOfLines + 1, "        End"
+        .InsertLines .CountOfLines + 1, "    End If"
+        .InsertLines .CountOfLines + 1, "End Sub"
+    End With
+End Function
+
+' Subroutine to create UserForm_TargetInvalid
+</t></si><si><t xml:space="preserve">Function createTargetInvalidForm()
+    Dim MyUserForm As VBComponent
+    Dim CommandButton1 As MSForms.CommandButton
+    Dim CommandButton2 As MSForms.CommandButton
+    Dim Label As MSForms.Label
+    Dim N As Integer
+
+    ' Check if UserForm_TargetInvalid </t></si><si><t xml:space="preserve">t MyUserForm = ThisWorkbook.VBProject.VBComponents.Add(vbext_ct_MSForm)
+    With MyUserForm
+        .Properties("Caption") = "Invalid Target Table"
+        .Properties("Width") = 350
+        .Properties("Height") = 150
+        .Properties("BorderStyle") = </t></si><si><t>1 ' Makes the form resizable
+    End With
+
+    MyUserForm.name = "UserForm_TargetInvalid"
+    
+    ' Add Label
+    Set Label = MyUserForm.Designer.Controls.Add("Forms.Label.1")
+    With Label
+        .Caption = "The selected target table is invalid. Should</t></si><si><t xml:space="preserve">tical"
+        .InsertLines .CountOfLines + 1, "        End"
+        .InsertLines .CountOfLines + 1, "    End If"
+        .InsertLines .CountOfLines + 1, "End Sub"
+    End With
+End Function
+
+' Subroutine to create UserForm_SourceTable
+</t></si><si><t xml:space="preserve">ok.VBProject.VBComponents(N).name = "UserForm_BackupTableForm" Then
+            Exit Function
+        End If
+    Next N
+
+    ' Create UserForm_SourceTable
+    Set MyUserForm = ThisWorkbook.VBProject.VBComponents.Add(vbext_ct_MSForm)
+    With MyUserForm
+   </t></si><si><t xml:space="preserve">     .Properties("Caption") = "Select Table for backup via doubleclick.."
+        .Properties("Width") = 400
+        .Properties("Height") = 400
+        .Properties("BorderStyle") = 1 ' Makes the form resizable
+    End With
+
+    MyUserForm.name = "UserForm</t></si><si><t>_BackupTable"
+    
+    ' Add ListBox
+    Set ListBox1 = MyUserForm.Designer.Controls.Add("Forms.ListBox.1")
+    With ListBox1
+        .name = "ListBox1"
+        .Left = 50
+        .Top = 50
+        .Width = 300
+        .Height = 300
+    End With
+
+
+    ' Ad</t></si><si><t xml:space="preserve">d event handlers
+    With MyUserForm.CodeModule
+        
+        ' ListBox1 Double Click event
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)"
+        .InsertLines .CountOfLines + 1, "    backupTable = Me.ListBox1.Text"
+        .InsertLines .CountOfLines + 1, "    Unload Me"
+        .InsertLines .CountOfLines + 1, "End Sub"
+        
+  </t></si><si><t>Sub UserForm_Initialize()"
+        .InsertLines .CountOfLines + 1, "    Dim sh As Worksheet"
+        .InsertLines .CountOfLines + 1, "    Dim tbl As ListObject"
+        .InsertLines .CountOfLines + 1, "    Dim str As String"
+        .InsertLines .CountOfLi</t></si><si><t>nes + 1, "    For Each sh In ThisWorkbook.Worksheets"
+        .InsertLines .CountOfLines + 1, "        For Each tbl In sh.ListObjects"
+        .InsertLines .CountOfLines + 1, "            str = sh.Name [&] "" ("" [&] tbl.Name [&] "")"""
+        .InsertLines .Cou</t></si><si><t>ntOfLines + 1, "            Me.ListBox1.AddItem str"
+        .InsertLines .CountOfLines + 1, "        Next tbl"
+        .InsertLines .CountOfLines + 1, "    Next sh"
+        .InsertLines .CountOfLines + 1, "End Sub"
+        
+        ' Handle close button (</t></si><si><t xml:space="preserve">X)
+        .InsertLines .CountOfLines + 1, "Private </t></si><si><t xml:space="preserve">tical"
+        .InsertLines .CountOfLines + 1, "        End"
+        .InsertLines .CountOfLines + 1, "    End If"
+        .InsertLines .CountOfLines + 1, "End Sub"
+    
+    End With
+End Function
+
+
+</t></si><si><t>Function TestSimplePattern()
+    Dim patternMatchFilterColumnNames() As String
+    Dim patternMatchFilterColumnValues() As String
+    Dim output As String
+    
+    ' Define the arrays
+    patternMatchFilterColumnNames = Split("Filter1,Filter2", ",")
+    pa</t></si><si><t>tternMatchFilterColumnValues = Split("Value1,Value2", ",")
+
+    output = instantiatedSimpleCodePattern("meta_SimpleTestPattern", patternMatchFilterColumnNames, patternMatchFilterColumnValues, "Order", "Template")
+    Debug.Print "(" [&] output [&] ")"
+End Func</t></si><si><t xml:space="preserve">tion
+
+
+
+
+
+
+
+
+
+</t></si><si><t>ingTable.ListColumns(referingColumnName [&] " Q")
+         For Each sht In ActiveWorkbook.Worksheets
+             For Each tbl In sht.ListObjects
+                 If tbl.name = referedTableName Then
+                      Set refTbl = tbl
+                 End</t></si><si><t>able.ListColumns("Package")
+         Set referingTableRefNameColumn = referingTable.ListColumns(referingColumnName)
+         '
+         For Each sht In ActiveWorkbook.Worksheets
+             For Each tbl In sht.ListObjects
+                 If tbl.name = re</t></si><si><t>Objects
+                 If tbl.name = referedTableName Then
+                      Set refTbl = tbl
+                 End If
+              Next tbl
+         Next sht
+         Set referedTable = refTbl
+         Set referedTableIdColumn = referedTable.ListCol</t></si><si><t xml:space="preserve">Sub UserForm_Initialize()
+    Dim sh As Worksheet
+    Dim tbl As ListObject
+    For Each sh In ThisWorkbook.Worksheets
+        For Each tbl In sh.ListObjects
+            Me.ListBox1.AddItem tbl.name
+        Next tbl
+    Next sh
+End Sub
+Private </t></si><si><t>Sub createTableBackup()
+    Dim sheetName As String
+    Dim tableName As String
+    Dim currentDateTime As String
+    
+    Dim backupForm As UserForm_BackupTable
+    Set backupForm = New UserForm_BackupTable
+    backupForm.Show
+    
+    transferTime = Now(</t></si><si><t xml:space="preserve">)
+    currentDateTime = Format(transferTime, "yymmddhhmm")
+    
+    sheetName = Trim(Left(backupTable, InStr(backupTable, "(") - 1))
+    tableName = Trim(Mid(backupTable, InStr(backupTable, "(") + 1, InStr(backupTable, ")") - InStr(backupTable, "(") - 1))
+</t></si><si><t xml:space="preserve">    
+    Call createBackup(sheetName, tableName, currentDateTime)
+    
+    MsgBox "Backup of the Table: " [&] vbNewLine [&] tableName [&] vbNewLine [&] "in the Sheet:" [&] vbNewLine [&] sheetName [&] vbNewLine [&] "was created with the following name:" [&] vbNewLine [&] sheet</t></si><si><t xml:space="preserve">Name [&] "_" [&] currentDateTime, vbInformation
+    
+End Sub
+
+</t></si><si><t xml:space="preserve">nOrderColumnName Then
+            orderColumnIndex = colIndex
+        End If
+        If tbl.ListColumns(colIndex).name = instantiatedTemplateColumnFromPatternSourceTable Then
+            instantiatedColumnIndex = colIndex
+        End If
+    Next colIndex
+
+</t></si><si><t>Function createBackup(tabName As String, tableName As String, currentDateTime As String) As ListObject
+
+    Dim NewSheet As Worksheet
+    Dim backupNameTable As String
+    
+    
+    Set createBackup = Nothing
+    Set wsTables = Nothing
+    
+    
+    backup</t></si><si><t>eet.ListObjects.Add(xlSrcRange, NewSheet.Range("A1:E1").CurrentRegion, , xlYes)
+        newTable.name = "meta_Tables_Extract" [&] currentDateTime
+        
+    ElseIf tableType = "Columns" Then
+    
+        ' Create 'Columns_Extract' sheet with specific colum</t></si><si><t xml:space="preserve">1").CurrentRegion, , xlYes)
+        newTable.name = "meta_Columns_Extract" [&] currentDateTime
+        
+    End If
+    
+    Set createExtract = newTable
+
+End Function
+
+
+
+
+'Helper
+</t></si><si><t xml:space="preserve">      NewSheet.Range("A1").PasteSpecial Paste:=xlPasteAll
+        Application.CutCopyMode = False
+        
+        Set tblMain = NewSheet.ListObjects(1)
+        tblMain.name = mainTableName
+        With tblMain.ListRows.Add
+            .Range.Cells(1, 1).V</t></si><si><t xml:space="preserve">d Then
+            ' Column is missing, add it to tblMain
+            tblMain.ListColumns.Add.name = colName
+            missingColumns = missingColumns [&] colName [&] vbNewLine
+        End If
+    Next colName
+
+    ' Display a message if columns were added
+  </t></si><si><t>Function processMetaData(currentDateTime As String)
+    Dim wsTables As Worksheet, wsColumns As Worksheet
+    Dim wsTablesExtract As Worksheet, wsColumnsExtract As Worksheet
+    Dim tblTables As ListObject, tblColumns As ListObject
+    Dim tblTablesExtract</t></si><si><t xml:space="preserve"> As ListObject, tblColumnsExtract As ListObject
+    
+    Dim sheet As Worksheet, table As ListObject, column As ListColumn
+    Dim tableExtractArray() As Variant, columnExtractArray() As Variant
+    Dim tableCount As Long, columnCount As Long
+    Dim table</t></si><si><t>Index As Long, columnIndex As Long
+    Dim id As String, columnID As String, newName As String
+    Dim StoredPosition As Long, i As Long
+
+    MsgBox "Processing workbook meta-data and storing it in the temporary _extract tables. This may take some time..",</t></si><si><t xml:space="preserve"> vbInformation
+    
+    ' Cache Sheets [&] Tables
+    Set wsTables = ThisWorkbook.Sheets("Tables")
+    Set tblTables = wsTables.ListObjects(1)
+    
+    Set wsColumns = ThisWorkbook.Sheets("Columns")
+    Set tblColumns = wsColumns.ListObjects(1)
+    
+    Set </t></si><si><t>wsTablesExtract = ThisWorkbook.Sheets("Tables_Extract" [&] currentDateTime)
+    Set wsColumnsExtract = ThisWorkbook.Sheets("Columns_Extract" [&] currentDateTime)
+    
+    Set tblTablesExtract = wsTablesExtract.ListObjects(1)
+    Set tblColumnsExtract = wsColum</t></si><si><t>nsExtract.ListObjects(1)
+
+    ' Load Tables and Columns Data into Arrays for Faster Lookup
+    Dim tableData As Variant, columnData As Variant
+    If Not tblTables.DataBodyRange Is Nothing Then tableData = tblTables.DataBodyRange.Value
+    If Not tblColumn</t></si><si><t>s.DataBodyRange Is Nothing Then columnData = tblColumns.DataBodyRange.Value
+
+    ' Get column indexes
+    Dim nameColIndex As Long, idColIndex As Long, owningTableColIndex As Long
+    nameColIndex = FindColumnIndex(tblTables, "Name")
+    idColIndex = FindC</t></si><si><t>olumnIndex(tblTables, "ID")
+    owningTableColIndex = FindColumnIndex(tblColumns, "Owning Table:src")
+
+    ' Store Table IDs in Arrays for Faster Lookup
+    Dim tableIDs() As String, tableNames() As String
+    If Not IsEmpty(tableData) And nameColIndex [>] 0</t></si><si><t xml:space="preserve"> And idColIndex [>] 0 Then
+        ReDim tableIDs(1 To UBound(tableData, 1))
+        ReDim tableNames(1 To UBound(tableData, 1))
+        
+        For i = 1 To UBound(tableData, 1)
+            tableIDs(i) = CStr(tableData(i, idColIndex))
+            tableName</t></si><si><t xml:space="preserve">s(i) = CStr(tableData(i, nameColIndex))
+        Next i
+    End If
+
+    ' Store Column IDs in Arrays for Faster Lookup
+    Dim columnIDs() As String, columnNames() As String
+    If Not IsEmpty(columnData) And idColIndex [>] 0 And owningTableColIndex [>] 0 Then
+</t></si><si><t xml:space="preserve">        ReDim columnIDs(1 To UBound(columnData, 1))
+        ReDim columnNames(1 To UBound(columnData, 1))
+        
+        For i = 1 To UBound(columnData, 1)
+            columnIDs(i) = CStr(columnData(i, idColIndex))
+            columnNames(i) = CStr(colum</t></si><si><t xml:space="preserve">nData(i, owningTableColIndex) [&] "_" [&] columnData(i, nameColIndex))
+        Next i
+    End If
+
+    ' Initialize Counters
+    tableCount = 0
+    columnCount = 0
+
+    ' **Iterate Once Through Sheets [&] Tables**
+    For Each sheet In ThisWorkbook.Sheets
+       </t></si><si><t>Function mergeTables(currentDateTime As String)
+    Dim wsTablesExtract As Worksheet, wsColumnsExtract As Worksheet
+    Dim wsTables As Worksheet, wsColumns As Worksheet
+    Dim tblTablesExtract As ListObject, tblColumnsExtract As ListObject
+    Dim tblTab</t></si><si><t>Function deleteUnmatchedRows(targetTable As ListObject, validIDs As Collection)
+    Dim idRange As Range
+    Dim idArray As Variant
+    Dim i As Long
+    Dim idColumn As Integer
+    Dim deleteRows As Range
+
+    ' Check if table has data
+    If targetTable.</t></si><si><t xml:space="preserve">Function ' Exit if "ID" column is not found
+
+    ' Define the range containing IDs (excluding header)
+    Set idRange = targetTable.ListColumns(idColumn).DataBodyRange
+    If idRange Is Nothing Then Exit </t></si><si><t>Function ' Exit if there is no data
+
+    ' Load IDs into an array for faster processing
+    idArray = idRange.Value
+
+    ' Identify rows to delete
+    For i = UBound(idArray, 1) To 1 Step -1 ' Loop in reverse to avoid shifting issues
+        If Not Collect</t></si><si><t xml:space="preserve">ionContains(validIDs, idArray(i, 1)) Then
+            targetTable.ListRows(i).Delete ' Delete row directly
+        End If
+    Next i
+End Function
+
+' Helper function to check if Collection contains an item
+</t></si><si><t xml:space="preserve">Function copyDownFormulas(tbl As ListObject)
+    Dim colHeader As Range
+    Dim colData As Range
+    Dim strFormula As String
+    
+    ' Loop through all columns in the table
+    For Each lc In tbl.ListColumns
+        Set colData = lc.DataBodyRange
+       </t></si><si><t xml:space="preserve"> 
+        ' Ensure column has data and first cell contains a formula
+        If Not colData Is Nothing Then
+            If colData.Cells(1, 1).HasFormula Then
+                strFormula = colData.Cells(1, 1).formula
+                colData.formula = strFor</t></si><si><t xml:space="preserve">mula ' Copy formula to entire column range
+            End If
+        End If
+    Next lc
+End Function
+
+</t></si><si><t>Sub createTablesAsFiles()
+    Dim ws As Worksheet
+    Dim tbl As ListObject
+    Dim wb As Workbook
+    Dim newWs As Worksheet
+    Dim rowIndex As Long
+    Dim transferTime As String
+    Dim currentDateTime As String
+    Dim copyMode As String
+    Dim sheet</t></si><si><t xml:space="preserve"> As Worksheet
+    Dim includeSheet As Boolean
+    Dim includeRow As Boolean
+    Dim headerRange As Range
+    Dim dataRange As Range
+    Dim r As Range
+    Dim userChoice As Variant
+    Dim snippetTable As ListObject
+    Dim snippetText As String
+    Dim fo</t></si><si><t>undSnippet As Boolean
+    
+    ' User selection for export mode
+    userChoice = Application.InputBox( _
+        "Select export mode:" [&] vbNewLine [&] vbNewLine [&] _
+        "1 Full (all tables + content)" [&] vbNewLine [&] _
+        "2 Model (all meta tables + c</t></si><si><t>late"
+    transferTime = Now()
+    currentDateTime = Format(transferTime, "yymmddhhmm")
+    
+    Set ws = ThisWorkbook.Sheets.Add
+    ws.name = copyMode [&] "_File_" [&] currentDateTime
+    
+    rowIndex = 1
+    
+    ws.Cells(rowIndex, 1).Value = copyMode [&] "_</t></si><si><t>File_" [&] currentDateTime
+    rowIndex = rowIndex + 2
+
+    ' Check if "meta_Snippets" exists and contains a "Layer0" snippet
+    On Error Resume Next
+    Set snippetTable = ThisWorkbook.Sheets("Snippets").ListObjects(1)
+    On Error GoTo 0
+    
+    If Not s</t></si><si><t xml:space="preserve">nippetTable Is Nothing Then
+        ' Find the correct column indexes
+        Dim subPackageCol As ListColumn
+        Dim snippetCol As ListColumn
+        Dim snippetRow As ListRow ' Correct declaration
+        
+        ' Get the column references
+        </t></si><si><t>On Error Resume Next
+        Set subPackageCol = snippetTable.ListColumns("</t></si><si><t>ls(1, snippetCol.Index).Value
+                    foundSnippet = True
+                    Exit For
+                End If
+            Next snippetRow
+            
+            ' If found, insert at the top of the template
+            If foundSnippet And Not</t></si><si><t xml:space="preserve"> copyMode = "domain" Then
+                ws.Cells(rowIndex, 1).Value = "#### Layer 0 snippet for manual copy into VBA project ####"
+                rowIndex = rowIndex + 1
+                ws.Cells(rowIndex, 1).Value = snippetText
+                rowIndex </t></si><si><t>= rowIndex + 2 ' Leave space before next content
+            End If
+        End If
+    End If
+
+    ' Loop through all sheets in the workbook
+    For Each sheet In ThisWorkbook.Sheets
+        includeSheet = False
+    
+        ' Determine if the sheet should</t></si><si><t xml:space="preserve"> be included based on mode
+        On Error Resume Next
+        Set tbl = sheet.ListObjects(1)
+        On Error GoTo 0
+        
+        If Not tbl Is Nothing Then
+            includeSheet = False ' Reset for each table
+        
+            Select Case copy</t></si><si><t xml:space="preserve">Mode
+                Case "full"
+                    includeSheet = True ' Include all tables
+                Case "model"
+                    If InStr(1, tbl.name, "meta_", vbTextCompare) [>] 0 Then includeSheet = True ' Include meta_ tables only
+          </t></si><si><t xml:space="preserve">      Case "veri"
+                    If InStr(1, tbl.name, "meta_", vbTextCompare) [>] 0 Then includeSheet = True ' Start by including meta_ tables
+                Case "domainVba"
+                    If Not InStr(1, tbl.name, "meta_", vbTextCompare) [>] 0 Or</t></si><si><t xml:space="preserve"> InStr(1, tbl.name, "Snippets", vbTextCompare) [>] 0 Then includeSheet = True ' Exclude meta_but include snippets
+                Case "domain"
+                    If Not InStr(1, tbl.name, "meta_", vbTextCompare) [>] 0 Then includeSheet = True ' Exclude meta_</t></si><si><t xml:space="preserve">
+            End Select
+    
+            ' If sheet is included, process its tables
+            If includeSheet Then
+                includeRow = True
+            
+                ' Additional filtering for "plain veri.excel" mode
+                If copyMo</t></si><si><t>de = "veri" Then
+                    If tbl.name = "meta_Tables" Or tbl.name = "meta_Columns" Then
+                        ' Only include rows where ID contains "meta_"
+                        includeRow = False
+                        Dim rowCell As Range</t></si><si><t xml:space="preserve">
+                        Dim rowIndexOffset As Long
+                        rowIndexOffset = rowIndex ' Start position for filtered rows
+                
+                        ' Insert ## (sheetname) ## (tablename) ##
+                        ws.Cells(row</t></si><si><t xml:space="preserve">IndexOffset, 1).Value = "## " [&] sheet.name [&] " ## " [&] tbl.name [&] " ##"
+                        rowIndexOffset = rowIndexOffset + 1
+                
+                        ' Copy Table Headers
+                        tbl.HeaderRowRange.Copy
+               </t></si><si><t xml:space="preserve">         ws.Cells(rowIndexOffset, 1).PasteSpecial Paste:=xlPasteValues
+                        rowIndexOffset = rowIndexOffset + 1
+                
+                        ' Loop through "ID" column to check rows
+                        For Each rowCell In</t></si><si><t xml:space="preserve"> tbl.ListColumns("ID").DataBodyRange
+                            If InStr(1, rowCell.Value, "meta_", vbTextCompare) [>] 0 Then
+                                rowCell.EntireRow.Copy
+                                ws.Cells(rowIndexOffset, 1).PasteSpecial Pas</t></si><si><t xml:space="preserve">te:=xlPasteValues
+                                rowIndexOffset = rowIndexOffset + 1
+                                includeRow = True ' At least one row was copied
+                            End If
+                        Next rowCell
+                
+ </t></si><si><t xml:space="preserve">                       ' Move to next section only if rows were copied
+                        If includeRow Then rowIndex = rowIndexOffset + 2
+                        includeRow = False
+                    End If
+                End If
+            
+      </t></si><si><t xml:space="preserve">          ' Export table if it's included
+                If includeRow Then
+                    ws.Cells(rowIndex, 1).Value = "## " [&] sheet.name [&] " ## " [&] tbl.name [&] " ##"
+                    rowIndex = rowIndex + 1
+            
+                    ' Cop</t></si><si><t>y Table Headers
+                    tbl.HeaderRowRange.Copy
+                    ws.Cells(rowIndex, 1).PasteSpecial Paste:=xlPasteValues
+                    rowIndex = rowIndex + 1
+
+                    ' Copy full table for other modes
+                    I</t></si><si><t xml:space="preserve">          End If
+                End If
+            End If
+        End If
+        Set tbl = Nothing
+    Next sheet
+    
+    ' Notify user of success
+    MsgBox "TablesAsFile created successfully!", vbInformation
+    
+    ' Restore application settings
+    </t></si><si><t xml:space="preserve">Application.Calculation = xlCalculationAutomatic
+    Application.ScreenUpdating = True
+    Application.EnableEvents = True
+    
+End Sub
+</t></si><si><t>Sub importTablesAsFiles()
+    Dim wsTemplate As Worksheet
+    Dim wb As Workbook
+    Dim ws As Worksheet
+    Dim rowIndex As Long, lastRow As Long
+    Dim sheetName As String, tableName As String
+    Dim headerRow As Range, dataStartRow As Long, dataEndRow</t></si><si><t xml:space="preserve"> As Long
+    Dim currentLine As String, nextLine As String
+    Dim parts() As String
+    Dim tblRange As Range, targetSheet As Worksheet
+    Dim pasteTopLeft As Range
+    Dim tbl As ListObject
+    Dim nowStamp As String
+    Dim colCount As Long
+    Dim exi</t></si><si><t>Function mergeObject()
+    ' Optimize for performance
+    Application.ScreenUpdating = False
+    Application.EnableEvents = False
+    Application.Calculation = xlCalculationManual
+    
+    Dim ttbl As ListObject
+    
+    ' Set references to source and targ</t></si><si><t>et tables
+    Set stbl = Worksheets(Range(sourceTable).Parent.name).ListObjects(sourceTable)
+    Set ttbl = Worksheets(Range(targetTable).Parent.name).ListObjects(targetTable)
+    
+    ' Load headers
+    sourceHeaders = stbl.HeaderRowRange.Value2
+    targe</t></si><si><t>tHeaders = ttbl.HeaderRowRange.Value2
+    
+    ' Load data
+    Dim sourceData As Variant, targetData As Variant, targetFormulas As Variant
+    sourceData = stbl.DataBodyRange.Value2
+    targetData = ttbl.DataBodyRange.Value2
+    targetFormulas = ttbl.DataB</t></si><si><t>odyRange.formula ' Store formulas
+    
+    ' Find ID columns
+    Dim sourceIdCol As Long, targetIdCol As Long
+    sourceIdCol = GetIdColumnIndex(sourceHeaders)
+    targetIdCol = GetIdColumnIndex(targetHeaders)
+    
+    ' Build column mapping
+    Dim column</t></si><si><t>Mapping As Collection
+    Set columnMapping = New Collection
+    Dim matchedColumns As Collection
+    Set matchedColumns = New Collection
+    
+    Dim i As Long, j As Long
+    For i = 1 To UBound(sourceHeaders, 2)
+        For j = 1 To UBound(targetHeaders,</t></si><si><t xml:space="preserve"> 2)
+            If CStr(sourceHeaders(1, i)) = CStr(targetHeaders(1, j)) Then
+                columnMapping.Add Array(i, j) ' Store source and target column indexes
+                matchedColumns.Add j ' Track columns that are being updated
+               </t></si><si><t>DataBodyRange.Columns(j)) Then
+            formulaColumns.Add j
+        End If
+    Next j
+    
+    ' Create an array-based lookup for target IDs
+    Dim targetLookup() As String
+    Dim targetLookupIndex() As Long
+    Dim targetCount As Long
+    targetCoun</t></si><si><t xml:space="preserve">t = UBound(targetData, 1)
+    
+    ReDim targetLookup(1 To targetCount)
+    ReDim targetLookupIndex(1 To targetCount)
+    
+    For i = 1 To targetCount
+        targetLookup(i) = CStr(targetData(i, targetIdCol))
+        targetLookupIndex(i) = i
+    Next i
+ </t></si><si><t xml:space="preserve">   
+    ' Update or insert data
+    Dim newRows As Collection
+    Set newRows = New Collection
+    
+    For i = 1 To UBound(sourceData, 1)
+        Dim id As String
+        id = CStr(sourceData(i, sourceIdCol))
+    
+        Dim foundIndex As Long
+        fo</t></si><si><t xml:space="preserve">undIndex = MatchID(targetLookup, id)
+    
+        If foundIndex [>] 0 Then
+            ' Update existing row
+            Dim targetRowIdx As Long
+            targetRowIdx = targetLookupIndex(foundIndex)
+    
+            ' Always update matched columns
+      </t></si><si><t xml:space="preserve"> mapping(0))
+                End If
+            Next j
+        Else
+            ' Collect new row for insertion
+            newRows.Add i
+        End If
+    Next i
+
+
+    ' Write back updated data while preserving formulas in unmatched columns
+    Dim colIn</t></si><si><t>dex As Long, rowIndex As Long
+    For rowIndex = 1 To UBound(targetData, 1)
+        For colIndex = 1 To UBound(targetData, 2)
+            ' If column was not in the matched list, preserve formula
+            If Not IsColumnMatched(colIndex, matchedColumns)</t></si><si><t xml:space="preserve"> And ColumnHasFormula(ttbl.DataBodyRange.Columns(colIndex)) Then
+                targetData(rowIndex, colIndex) = targetFormulas(rowIndex, colIndex)
+            End If
+        Next colIndex
+    Next rowIndex
+    
+    ' Apply updated data
+    ttbl.DataBodyR</t></si><si><t xml:space="preserve">   Application.ScreenUpdating = True
+    Exit Function
+End Function
+
+' </t></si><si><t xml:space="preserve"> = 0
+End Function
+
+Private </t></si><si><t xml:space="preserve">temp, 1)) [&] Mid(temp, 2)
+End Function
+
+
+
+'TODO without seperator versions/with fixed length versions
+
+' HELPER
+
+' Entry from Utils
+Public </t></si><si><t xml:space="preserve">aultyCharacters(temp)
+    'Debug.Print temp
+    
+    ' Initialize currentSegment as an empty string
+    currentSegment = ""
+    
+    ' Iterate through the characters in the string
+    For i = 1 To Len(temp)
+        If Mid(temp, i, 1) = " " Then
+           </t></si><si><t xml:space="preserve">           ' If it's not a space, continue building the current segment
+            currentSegment = currentSegment [&] Mid(temp, i, 1)
+        End If
+    Next i
+    
+    ' Add the last segment if it exists
+    If Len(currentSegment) [>] 0 Then
+        segment</t></si><si><t xml:space="preserve">Function getLeadingSpaces(ByVal inputLine As String) As Integer
+    Dim i As Integer
+    For i = 1 To Len(inputLine)
+        If Mid(inputLine, i, 1) [<][>] " " Then Exit For
+    Next i
+    getLeadingSpaces = i - 1
+End Function
+
+'NEXT 2
+Public </t></si><si><t xml:space="preserve">' Handle Capitalization
+    For i = LBound(wordArray) + 1 To UBound(wordArray)
+        word = wordArray(i)
+        If Len(word) [>] 0 And Not IsNumeric(Left(word, 1)) Then
+            encodedStr = UCase(Left(word, 1)) [&] Mid(word, 2)
+            wordArray(i) </t></si><si><t xml:space="preserve">"N[0-9]" Then
+        inputString = Mid(inputString, 2)
+    End If
+    
+    'inputString = Replace(inputString, "__", "____")
+    'Debug.Print inputString
+
+    ' Step 1: Split the input string by lines first
+    lineArray = Split(inputString, "_n__")
+    
+</t></si><si><t xml:space="preserve">hem is numeric
+        If Left(line, 1) = "_" And InStr(line, "s__") [>] 2 Then
+            ' Extract the part between "_" and "s__"
+            numStr = Mid(line, 2, InStr(line, "s__") - 2)
+            
+            ' Ensure the extracted part is a number
+  </t></si><si><t xml:space="preserve">          If IsNumeric(numStr) Then
+                numSpaces = CInt(numStr)
+                ' Replace the prefix with the appropriate number of spaces
+                line = String(numSpaces, " ") [&] Mid(line, InStr(line, "s__") + 3)
+            End If
+   </t></si><si><t>(inputString, 1)
+    previousChar = Left(inputString, 1)
+    
+    ' Step 1: Split based on capitalization and specific characters
+    For i = 2 To Len(inputString)
+        currentChar = Mid(inputString, i, 1)
+        
+        ' Check if the current charact</t></si><si><t>' Step 1: Remove leading whitespaces
+    firstNonWhitespaceFound = False
+    For i = 1 To Len(str)
+        ' Check if the current character is not a space, tab, newline, or carriage return
+        If Mid(str, i, 1) [<][>] " " And Asc(Mid(str, i, 1)) [<][>] 9 And A</t></si><si><t xml:space="preserve">sc(Mid(str, i, 1)) [<][>] 10 And Asc(Mid(str, i, 1)) [<][>] 13 Then
+            firstNonWhitespaceFound = True
+        End If
+        
+        ' If non-whitespace found, exit the loop
+        If firstNonWhitespaceFound Then
+            Exit For
+        End If
+    </t></si><si><t>Next i
+    
+    ' Return the string starting from the first non-whitespace character
+    str = Mid(str, i)
+    
+    
+    ' Step 2: replace Tabs with three spaces
+    str = Replace(str, Chr(9), "   ")
+    
+    
+    
+    ' Split the string into lines based o</t></si><si><t xml:space="preserve"> 
+        ' Identify and preserve the leading spaces
+        Dim j As Integer
+        For j = 1 To Len(lines(i))
+            If Mid(lines(i), j, 1) = " " Then
+                leadingSpaces = leadingSpaces [&] " "
+            Else
+                Exit For
+   </t></si><si><t xml:space="preserve">
+            currentChar = Mid(lineContent, k, 1)
+            
+            ' Check if there is a next character to compare
+            If k [<] Len(lineContent) Then
+                nextChar = Mid(lineContent, k + 1, 1)
+                
+                ' Add</t></si><si><t>= str
+        Exit Function
+    End If
+
+    result = ""
+    special = False ' Initialize special to false
+
+    ' Add the first character (no space needed before the first character)
+    result = Mid(str, 1, 1)
+
+    ' Iterate from the second character to th</t></si><si><t>e end of the string
+    For i = 2 To Len(str)
+        ' Get the current character
+        Dim currentChar As String
+        currentChar = Mid(str, i, 1)
+
+        ' Check if the current character is a special character
+        If Not currentChar Like "[A-Za</t></si><si><t xml:space="preserve"> conditions
+            If Mid(str, i - 1, 1) Like "[A-Z]" And (i [<] Len(str) And Mid(str, i + 1, 1) Like "[a-z]") And Not special Then
+                result = result [&] " " [&] currentChar
+            ElseIf Mid(str, i - 1, 1) Like "[a-z]" And Not special Th</t></si><si><t xml:space="preserve">   ' Iterate through each character in the input string
+    For i = 1 To Len(inputString)
+        currentChar = Mid(inputString, i, 1)
+        
+        ' Check if the current character is not in the allowed characters
+        If InStr(allowedChars, current</t></si><si><t xml:space="preserve">   Do While Mid(currentLine, j, 1) = " "
+                j = j + 1
+            Loop
+            ReDim Preserve result(UBound(result) + 1)
+            result(UBound(result)) = Left(currentLine, j - 1)
+            currentLine = Mid(currentLine, j)
+        En</t></si><si><t>ength = Len(inputStr)
+    
+    For i = 1 To strLength
+        currentChar = Mid(inputStr, i, 1)
+        
+        ' Get the previous character (if exists)
+        If i [>] 1 Then
+            previousChar = Mid(inputStr, i - 1, 1)
+        Else
+            prev</t></si><si><t>iousChar = ""
+        End If
+        
+        ' Get the next character (if exists)
+        If i [<] strLength Then
+            nextChar = Mid(inputStr, i + 1, 1)
+        Else
+            nextChar = ""
+        End If
+        
+        ' Check if the current ch</t></si><si><t>ter followed by any special character
+        'Debug.Print firstWord
+        'Debug.Print Mid(firstWord, 1, 1)
+        'Debug.Print Mid(firstWord, 2, 1)
+        If Len(firstWord) [>]= 2 And Mid(firstWord, 1, 1) Like "[A-Za-z]" And Not Mid(firstWord, 2, 1) Li</t></si><si><t>::Transfer</t></si><si><t>Public sourceTable As String
+Public targetTable As String
+Public transferTime As Date
+Public sourcevalid As Boolean
+Public targetvalid As Boolean
+Public fulltransfer As Boolean
+Public transferMode As String
+
+'ObjectTransfer
+Private stbl As ListObject
+Priva</t></si><si><t xml:space="preserve">te ttbl As ListObject
+Private sourceHeaders As Variant
+Private targetHeaders As Variant
+
+'SourceValidation
+Public source_fix As Boolean
+
+'TargertValidation
+Public target_fix As Boolean
+
+
+</t></si><si><t xml:space="preserve"> program if source or target were not selected
+            MsgBox "Source or target table was not selected. Program terminates."
+            Exit Sub
+        End If
+
+        ' Validation
+        Call validateSource
+
+        If targetTable [<][>] "no selection"</t></si><si><t xml:space="preserve"> Then
+            ' If target table was selected, validate it
+            Call validateTarget
+        ElseIf sourcevalid = True Then
+            ' If not, create new table and begin transfer
+            MsgBox "No target table selected. New target table wi</t></si><si><t xml:space="preserve">ll be created."
+            Call createTargetTable
+        End If
+
+        ' Call transfer if target table was selected and both source and target were fixed
+        If targetTable [<][>] "no selection" And sourcevalid = True And targetvalid = True Then
+      </t></si><si><t xml:space="preserve">      If transferMode = "normal" Then
+                Call transferObject
+            End If
+        End If
+
+    Else
+        MsgBox "Full transfer was selected. All tables will be validated and transferred."
+        targetTable = "no selection"
+
+        F</t></si><si><t>or Each sh In ThisWorkbook.Worksheets
+            For Each tbl In sh.ListObjects
+                sourceTable = tbl.name
+                Call validateSource
+                MsgBox "New target table for " [&] sourceTable [&] " will be created."
+                C</t></si><si><t xml:space="preserve">all createTargetTable
+                
+                ' Call transfer if target table was selected and both source and target were fixed
+                If targetTable [<][>] "no selection" And sourcevalid = True And targetvalid = True Then
+                  </t></si><si><t xml:space="preserve">  If transferMode = "normal" Then
+                        Call transferObject
+                    End If
+                End If
+                
+            Next tbl
+        Next sh
+
+        MsgBox "Full transfer completed."
+    End If
+
+    endTime = Now
+
+</t></si><si><t xml:space="preserve">    MsgBox "Transfer successful."
+    Exit Sub
+
+'ErrorHandler:
+'    MsgBox "An error occurred: " [&] Err.Description, vbCritical
+End Sub
+
+
+
+'############# ObjectTransfer code #############
+
+
+
+</t></si><si><t>targetLookup As New FastLookup
+    
+    ' Set references to source and target tables using the public variables
+    Set stbl = Worksheets(Range(sourceTable).Parent.name).ListObjects(sourceTable)
+    Set ttbl = Worksheets(Range(targetTable).Parent.name).Lis</t></si><si><t xml:space="preserve">stColumns(storedColName)
+    On Error GoTo 0
+    
+    If storedCol Is Nothing Then
+        Set storedCol = targetTbl.ListColumns.Add
+        storedCol.name = storedColName
+    End If
+    
+    ' Store the value
+    storedCol.DataBodyRange(targetRow).Value2 </t></si><si><t xml:space="preserve">mnIndex = 0 ' Return 0 if not found
+End Function
+
+
+
+
+
+
+'############# SourceValidation code #############
+
+</t></si><si><t>le_invalid_formula As Boolean
+    
+    Application.ScreenUpdating = False
+    Application.Calculation = xlCalculationManual
+    
+    Set stbl = Worksheets(Range(sourceTable).Parent.name).ListObjects(sourceTable)
+    
+    'check for ID column
+    source_id_</t></si><si><t xml:space="preserve">
+        
+        For Each cel In id_range
+            If (Application.WorksheetFunction.CountIf(Worksheets(Range(sourceTable).Parent.name).Range(id_range_add), cel) [>] 1) Then
+                source_id_duplicate = True
+                Exit For
+            </t></si><si><t xml:space="preserve"> = True Then
+            'call fix function
+            Call fixingtable(stbl, sourceTable, source_id_count, source_id_col, source_id_duplicate, source_table_invalid_value, source_table_invalid_formula, False)
+        End If
+    End If
+End Sub
+
+
+'#########</t></si><si><t xml:space="preserve">#### TargetValidation code #############
+
+</t></si><si><t>le_invalid_formula As Boolean
+    
+    Application.ScreenUpdating = False
+    Application.Calculation = xlCalculationManual
+    
+    Set ttbl = Worksheets(Range(targetTable).Parent.name).ListObjects(targetTable)
+    
+    'check for ID column
+    target_id_</t></si><si><t xml:space="preserve">
+        
+        For Each cel In id_range
+            If (Application.WorksheetFunction.CountIf(Worksheets(Range(targetTable).Parent.name).Range(id_range_add), cel) [>] 1) Then
+                target_id_duplicate = True
+                Exit For
+            </t></si><si><t>e
+        Dim targetInvalid As UserForm_TargetInvalid
+        Set targetInvalid = New UserForm_TargetInvalid
+        targetInvalid.Show
+        
+        If target_fix = True Then
+            'call fix function
+            Call fixingtable(ttbl, targetTable</t></si><si><t xml:space="preserve">, target_id_count, target_id_col, target_id_duplicate, target_table_invalid_value, target_table_invalid_formula, True)
+        End If
+    End If
+End Sub
+
+
+
+'############# TableFix code #############
+
+</t></si><si><t>MDDHHMMSS")
+    
+    tbl.ListColumns.Add.name = "fix transfer party " [&] Format(transferTime, "YYYYMMDDHHMMSS")
+    If party = False Then
+        tbl.ListColumns("fix transfer party " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange = "source"
+    El</t></si><si><t>se
+        tbl.ListColumns("fix transfer party " [&] Format(transferTime, "YYYYMMDDHHMMSS")).DataBodyRange = "target"
+    End If
+    
+    tbl.ListColumns.Add.name = "fix kind " [&] Format(transferTime, "YYYYMMDDHHMMSS")
+    tbl.ListColumns("fix kind " [&] Format</t></si><si><t xml:space="preserve">    ElseIf id_count = 0 Then
+    'no ID column -[>] create ID column and generate GUIDs for each row
+    
+        'QUESTION: could this be problematic for any formulas in the table? Should we add ID column to the end?
+        tbl.ListColumns.Add(1).name = "I</t></si><si><t>s
+        
+        'Worksheets(Range(strTable).Parent.Name).Range(id_range_add).Validation.Delete
+        'Worksheets(tbl.Parent.Name).Range(id_range_add).Validation.Delete
+    
+
+       ThisWorkbook.Worksheets(tbl.Parent.name).Columns(tbl.ListColumns("ID")</t></si><si><t xml:space="preserve">ction.CountIf(Worksheets(Range(strTable).Parent.name).Range(id_range_add), cel) [>] 1) Then
+            'cel has duplicates
+            
+                counter = -1
+                i = 1
+                
+                For Each cel1 In id_range
+           </t></si><si><t xml:space="preserve">UID = "{" [&] GUID [&] "}"
+    
+End Function
+    
+
+'############# TargetCreation code #############
+
+
+</t></si><si><t>t
+    Dim ws As Worksheet
+    Set ws = ThisWorkbook.Sheets(sheetName)
+    
+    ws.ListObjects.Add(xlSrcRange, Range("$B$4:$B$4"), , xlYes).name = sheetName    'B4 is the fixed start point for tables
+    
+    Set stbl = Worksheets(Range(sourceTable).Parent.</t></si><si><t>name).ListObjects(sourceTable)
+    Set ttbl = ws.ListObjects(sheetName)
+    
+    Dim colHeader As Range
+    For Each colHeader In stbl.HeaderRowRange
+        If Not (stbl.ListColumns(colHeader.Value).DataBodyRange(1).HasFormula Or _
+                InStr(c</t></si><si><t xml:space="preserve">            stbl.ListColumns(colHeader.Value).Range.Copy _
+                Destination:=Worksheets(Range(sheetName).Parent.name).Range(Worksheets(Range(sheetName).Parent.name).Cells(4, i), Worksheets(Range(sheetName).Parent.name).Cells(4, i))
+            i</t></si><si><t xml:space="preserve">t sourcePartyCol = stbl.ListColumns.Add
+    sourcePartyCol.name = "transfer party " [&] timeFormatLong
+    
+    Set sourceKindCol = stbl.ListColumns.Add
+    sourceKindCol.name = "transfer kind " [&] timeFormatLong
+    
+    ' Prepare arrays for bulk update
+    </t></si><si><t>es
+    
+    ' Add traceability information for target table using bulk operations
+    Dim targetPartyCol As ListColumn
+    Dim targetKindCol As ListColumn
+    
+    ' Add columns
+    Set targetPartyCol = ttbl.ListColumns.Add
+    targetPartyCol.name = "trans</t></si><si><t xml:space="preserve">dyRange.Value = partyValues
+    targetKindCol.DataBodyRange.Value = kindValues
+    
+    Application.EnableEvents = True
+    Application.Calculation = xlCalculationAutomatic
+    Application.ScreenUpdating = True
+End Sub
+
+
+'currently not used
+</t></si><si><t>UserForm_BackupTable</t></si><si><t xml:space="preserve">Sub ListBox1_DblClick(ByVal Cancel As MSForms.ReturnBoolean)
+    backupTable = Me.ListBox1.Text
+    Unload Me
+End Sub
+Private </t></si><si><t>Sub UserForm_Initialize()
+    Dim sh As Worksheet
+    Dim tbl As ListObject
+    Dim str As String
+    For Each sh In ThisWorkbook.Worksheets
+        For Each tbl In sh.ListObjects
+            str = sh.name [&] " (" [&] tbl.name [&] ")"
+            Me.ListBox1.Ad</t></si><si><t xml:space="preserve">dItem str
+        Next tbl
+    Next sh
+End Sub
+Private </t></si><si><t xml:space="preserve"> 1, 1)
+        End If
+    Next i
+    
+    ' Rejoin the lines into a single string
+    handleLists = Join(lines, Chr(10))
+End Function
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+</t></si><si><t xml:space="preserve">  Application.ScreenUpdating = True
+
+End Sub
+
+
+
+
+
+
+
+
+
+
+
+
+</t></si><si><t>Sub createForms()
+
+    ' Create all forms
+    Call createTransferModeForm
+    Call createSourceTableForm
+    Call createTargetTableForm
+    Call createSourceInvalidForm
+    Call createTargetInvalidForm
+    Call createBackupTableForm
+
+    MsgBox "Forms crea</t></si><si><t xml:space="preserve">ted successfully."
+
+End Sub
+
+' Subroutine to create UserForm_TransferMode
+</t></si><si><t>hisWorkbook.VBProject.VBComponents.count
+        If ThisWorkbook.VBProject.VBComponents(N).name = "UserForm_TransferMode" Then
+            Exit Function
+        End If
+    Next N
+
+    ' Create UserForm_TransferMode
+    Set MyUserForm = ThisWorkbook.VBProje</t></si><si><t>Project.VBComponents.count
+        If ThisWorkbook.VBProject.VBComponents(N).name = "UserForm_SourceTable" Then
+            Exit Function
+        End If
+    Next N
+
+    ' Create UserForm_SourceTable
+    Set MyUserForm = ThisWorkbook.VBProject.VBComponents.</t></si><si><t>Project.VBComponents.count
+        If ThisWorkbook.VBProject.VBComponents(N).name = "UserForm_TargetTable" Then
+            Exit Function
+        End If
+    Next N
+
+    ' Create UserForm_TargetTable
+    Set MyUserForm = ThisWorkbook.VBProject.VBComponents.</t></si><si><t>already exists
+    For N = 1 To ThisWorkbook.VBProject.VBComponents.count
+        If ThisWorkbook.VBProject.VBComponents(N).name = "UserForm_SourceInvalid" Then
+            Exit Function
+        End If
+    Next N
+
+    ' Create UserForm_SourceInvalid
+    Se</t></si><si><t>already exists
+    For N = 1 To ThisWorkbook.VBProject.VBComponents.count
+        If ThisWorkbook.VBProject.VBComponents(N).name = "UserForm_TargetInvalid" Then
+            Exit Function
+        End If
+    Next N
+
+    ' Create UserForm_TargetInvalid
+    Se</t></si><si><t>Function createBackupTableForm()
+    Dim MyUserForm As VBComponent
+    Dim ListBox1 As MSForms.ListBox
+    Dim N As Integer
+
+    ' Check if UserForm_SourceTable already exists
+    For N = 1 To ThisWorkbook.VBProject.VBComponents.count
+        If ThisWorkbo</t></si><si><t xml:space="preserve"> Return empty array if no keys exist
+    End If
+    AllKeys = result
+End Property
+
+Public Property Get count() As Long
+    count = keyCount
+End Property</t></si><si><t xml:space="preserve">Public backupTable As String
+
+</t></si><si><t xml:space="preserve">Sub createAndComplementTablesAndColums()
+    Dim tblTables As ListObject, tblColumns As ListObject
+    Dim rowTable As ListRow, rowColumn As ListRow
+    Dim wsTarget As Worksheet, tblTarget As ListObject
+    Dim sheetName As String, tableName As String
+   </t></si><si><t xml:space="preserve"> Dim colLabel As String, colFormula As String
+    Dim colPos As Long, existingFormula As String
+    Dim mode As String
+    Dim rngColumn As Range
+    Dim cell As Range
+    Dim colCount As Long
+    Dim currentDateTime As String
+    Dim transferTime As Date
+</t></si><si><t xml:space="preserve">    Dim userChoice As Variant
+    Dim startTime As Double
+
+    transferTime = Now()
+    currentDateTime = Format(transferTime, "yyyymmddhhmmss")
+    startTime = Timer
+
+    Application.ScreenUpdating = False
+    Application.Calculation = xlCalculationManual</t></si><si><t xml:space="preserve">
+    Application.EnableEvents = False
+
+    userChoice = Application.InputBox( _
+        "Choose handling of old values/formulas:" [&] vbNewLine [&] vbNewLine [&] _
+        "1 - Overwrite (lose old overwritten values/formulas!)" [&] vbNewLine [&] _
+        "2 - Backu</t></si><si><t xml:space="preserve">pValues (save old overwritten formula-VALUES in '_backup'' column.)" [&] vbNewLine [&] _
+        "3 - BackupFormulas (save old overwritten formula in '_backup'' column.)", _
+        "Select Mode", Type:=1)
+
+    Select Case userChoice
+        Case 1
+           </t></si><si><t xml:space="preserve"> mode = "overwrite"
+        Case 2
+            mode = "backupV"
+        Case 3
+            mode = "backupF"
+        Case Else
+            MsgBox "Invalid Number. Stopping execution..", vbInformation
+            Exit Sub
+    End Select
+
+    MsgBox "Attempti</t></si><si><t>ng to create and complement tables and columns based on entries in 'meta_Tables' and 'meta_Columns' ..", vbInformation
+
+    On Error Resume Next
+    Set tblTables = ThisWorkbook.Sheets("Tables").ListObjects("meta_Tables")
+    Set tblColumns = ThisWorkbook.</t></si><si><t>Sheets("Columns").ListObjects("meta_Columns")
+    On Error GoTo 0
+
+    If tblTables Is Nothing Then
+        MsgBox "Table 'meta_Tables' in sheet 'Tables' not found. Stopping execution..", vbInformation
+        Exit Sub
+    End If
+
+    If tblColumns Is Noth</t></si><si><t>ing Then
+        MsgBox "Table 'meta_Columns' in sheet 'Columns' not found. Stopping execution..", vbInformation
+        Exit Sub
+    End If
+
+   ' === STEP 1: Ensure existence and correct alignment of sheets and tables ===
+For Each rowTable In tblTables.Li</t></si><si><t>stRows
+    sheetName = rowTable.Range(1, tblTables.ListColumns("Excel Table - Sheet Name").Index).Value
+    tableName = rowTable.Range(1, tblTables.ListColumns("Excel Table - Excel Name").Index).Value
+
+    Dim wsExpected As Worksheet
+    Dim wsActual As Wo</t></si><si><t>rksheet
+    Dim tblFound As ListObject
+    Dim tableExists As Boolean: tableExists = False
+    Dim sheetExists As Boolean: sheetExists = False
+
+    ' Check if sheet with expected name exists
+    On Error Resume Next
+    Set wsExpected = ThisWorkbook.Sheets</t></si><si><t>(sheetName)
+    On Error GoTo 0
+    sheetExists = Not wsExpected Is Nothing
+
+    ' Check if table exists anywhere in workbook and track the sheet it's in
+    Set tblFound = Nothing
+    For Each wsActual In ThisWorkbook.Worksheets
+        On Error Resume Ne</t></si><si><t xml:space="preserve">xt
+        Set tblFound = wsActual.ListObjects(tableName)
+        On Error GoTo 0
+        If Not tblFound Is Nothing Then Exit For
+    Next wsActual
+    tableExists = Not tblFound Is Nothing
+
+    ' === Case 1: Table and Sheet exist but not aligned ===
+    </t></si><si><t xml:space="preserve">If tableExists And sheetExists And Not wsActual Is wsExpected Then
+        ' Clear expected sheet and move table
+            wsExpected.Cells.Clear
+            tblFound.Range.Copy Destination:=wsExpected.Range("A1")
+            tblFound.Delete
+        
+   </t></si><si><t xml:space="preserve">         ' Use existing pasted table instead of adding a new one
+            Dim pastedTable As ListObject
+            On Error Resume Next
+            Set pastedTable = wsExpected.ListObjects(1)
+            On Error GoTo 0
+        
+            If Not past</t></si><si><t>edTable Is Nothing Then
+                pastedTable.name = tableName
+                Set tblFound = pastedTable
+            Else
+                ' Fallback in case paste didn't include a table (just in case)
+                Set tblFound = wsExpected.ListOb</t></si><si><t>jects.Add(xlSrcRange, wsExpected.Range("A1").CurrentRegion, , xlYes)
+                tblFound.name = tableName
+            End If
+
+    ' === Case 2: Sheet exists, Table does not ===
+    ElseIf sheetExists And Not tableExists Then
+        wsExpected.Cells.C</t></si><si><t>lear
+        wsExpected.Cells(1, 1).Value = "ID"
+        wsExpected.Cells(2, 1).Value = 1
+        Set tblFound = wsExpected.ListObjects.Add(xlSrcRange, wsExpected.Range("A1").CurrentRegion, , xlYes)
+        tblFound.name = tableName
+
+    ' === Case 3: Tabl</t></si><si><t>e exists, Sheet does not ===
+    ElseIf tableExists And Not sheetExists Then
+        wsActual.name = sheetName ' Rename the existing sheet holding the table
+
+    ' === Case 4: Neither exists ===
+    ElseIf Not tableExists And Not sheetExists Then
+        S</t></si><si><t>et wsExpected = ThisWorkbook.Sheets.Add(After:=Sheets(Sheets.count))
+        wsExpected.name = sheetName
+        wsExpected.Cells(1, 1).Value = "ID"
+        wsExpected.Cells(2, 1).Value = 1
+        Set tblFound = wsExpected.ListObjects.Add(xlSrcRange, wsEx</t></si><si><t xml:space="preserve">pected.Range("A1").CurrentRegion, , xlYes)
+        tblFound.name = tableName
+    End If
+
+    ' Cleanup
+    Set wsExpected = Nothing
+    Set wsActual = Nothing
+    Set tblFound = Nothing
+Next rowTable
+
+
+   ' === STEP 2: Efficiently create, update, position </t></si><si><t>or remove columns ===
+
+    Dim processedTable As String
+    Dim tableLabels() As String
+    Dim tableRow As ListRow
+    Dim count As Long
+    
+    ' Get unique table names from meta_Columns
+    For Each tableRow In tblColumns.ListRows
+        processedTabl</t></si><si><t>e = Trim(tableRow.Range(1, tblColumns.ListColumns("Owning Table Excel Name").Index).Value)
+        
+        ' Avoid duplicates (simple array check)
+        Dim found As Boolean: found = False
+        For i = 1 To count
+            If tableLabels(i) = proce</t></si><si><t>ssedTable Then
+                found = True
+                Exit For
+            End If
+        Next i
+        If Not found Then
+            count = count + 1
+            ReDim Preserve tableLabels(1 To count)
+            tableLabels(count) = processedTabl</t></si><si><t>e
+        End If
+    Next tableRow
+    
+    ' Process each table
+    For i = 1 To count
+        Call processTableColumns(tableLabels(i), tblColumns, mode, currentDateTime)
+    Next i
+
+
+
+  ' === STEP 3: Delete sheets not listed in meta_Tables ===
+    Dim ws</t></si><si><t xml:space="preserve"> As Worksheet
+    Dim keepSheets As String, idx As Long
+    
+    ' Build pipe-delimited list of sheet names to keep
+    keepSheets = "|Tables|Columns|"
+    For Each rowTable In tblTables.ListRows
+        keepSheets = keepSheets [&] rowTable.Range(1, tblTable</t></si><si><t xml:space="preserve">s.ListColumns("Excel Table - Sheet Name").Index).Value [&] "|"
+    Next rowTable
+    
+    ' Delete all sheets not in keep list
+    Application.DisplayAlerts = False
+    For Each ws In ThisWorkbook.Worksheets
+        If InStr(keepSheets, "|" [&] ws.name [&] "|") </t></si><si><t>= 0 Then ws.Delete
+    Next ws
+    Application.DisplayAlerts = True
+
+
+    Application.Calculation = xlCalculationAutomatic
+    Application.ScreenUpdating = True
+    Application.EnableEvents = True
+
+    MsgBox "Workbook structure update completed in " [&] For</t></si><si><t xml:space="preserve">mat(Timer - startTime, "0.00") [&] " seconds.", vbInformation
+End Sub
+
+Private </t></si><si><t>Function processTableColumns(ByVal tableName As String, ByRef tblColumns As ListObject, ByVal mode As String, ByVal currentDateTime As String)
+    Dim wsTarget As Worksheet, tblTarget As ListObject
+    Dim rowColumn As ListRow
+    Dim colLabel As String, c</t></si><si><t>olFormula As String, existingFormula As String
+    Dim colPos As Long, i As Long
+    Dim foundCol As ListColumn, rngColumn As Range
+    Dim expectedLabels() As String, labelCount As Long
+    Dim backupRequests As Collection
+    Set backupRequests = New Col</t></si><si><t xml:space="preserve">lection
+
+    ' Find the table
+    For Each wsTarget In ThisWorkbook.Worksheets
+        On Error Resume Next
+        Set tblTarget = wsTarget.ListObjects(tableName)
+        On Error GoTo 0
+        If Not tblTarget Is Nothing Then Exit For
+    Next wsTarget
+</t></si><si><t xml:space="preserve">    If tblTarget Is Nothing Then Exit Function
+
+    ' Prepare expected column list
+    labelCount = 0
+    For Each rowColumn In tblColumns.ListRows
+        If Trim(rowColumn.Range(1, tblColumns.ListColumns("Owning Table Excel Name").Index).Value) = tableNa</t></si><si><t>me Then
+            colLabel = rowColumn.Range(1, tblColumns.ListColumns("Excel Column - Label").Index).Value
+            colFormula = rowColumn.Range(1, tblColumns.ListColumns("Excel Column - Excel Formula").Index).Value
+            colPos = rowColumn.Ran</t></si><si><t>ge(1, tblColumns.ListColumns("Position").Index).Value
+
+            ' Track expected labels
+            labelCount = labelCount + 1
+            ReDim Preserve expectedLabels(1 To labelCount)
+            expectedLabels(labelCount) = colLabel
+
+            ' C</t></si><si><t xml:space="preserve">heck if column exists
+            Set foundCol = Nothing
+            On Error Resume Next
+            Set foundCol = tblTarget.ListColumns(colLabel)
+            On Error GoTo 0
+
+            If Not foundCol Is Nothing Then
+                ' Move if needed
+ </t></si><si><t xml:space="preserve">               If foundCol.Index [<][>] colPos Then
+                    foundCol.Range.Cut
+                    tblTarget.ListColumns(colPos).Range.Insert Shift:=xlToRight
+                End If
+
+                ' Handle formula
+                If colFormula [<][>]</t></si><si><t xml:space="preserve"> "" And Left(colFormula, 8) = "Formula:" Then
+                    Set rngColumn = tblTarget.ListColumns(colLabel).DataBodyRange
+                    existingFormula = ""
+                    On Error Resume Next
+                    existingFormula = rngColum</t></si><si><t xml:space="preserve">        Exit Function
+    End If
+
+    ' Find the order column and instantiated template column indexes
+    orderColumnIndex = 0
+    instantiatedColumnIndex = 0
+    For colIndex = 1 To tbl.ListColumns.count
+        If tbl.ListColumns(colIndex).name = patter</t></si><si><t xml:space="preserve">        For colIndex = 1 To tbl.ListColumns.count
+                If tbl.ListColumns(colIndex).name = columnName Then
+                    columnIndex = colIndex
+                    Exit For
+                End If
+            Next colIndex
+
+            If c</t></si><si><t>x, orderColumnIndex), tempArray(rowIndex, instantiatedColumnIndex))
+        End If
+    Next rowIndex
+
+    ' Sort matched rows by the order column
+    If matchedRows.count [>] 1 Then
+        Dim j As Long, k As Long
+        Dim temp As Variant
+        For j =</t></si><si><t xml:space="preserve"> 1 To matchedRows.count - 1
+            For k = j + 1 To matchedRows.count
+                If matchedRows(j)(0) [>] matchedRows(k)(0) Then
+                    temp = matchedRows(j)
+                    matchedRows(j) = matchedRows(k)
+                    match</t></si><si><t>edRows(k) = temp
+                End If
+            Next k
+        Next j
+    End If
+
+    output = ""
+
+    For i = 1 To matchedRows.count
+        output = output [&] matchedRows(i)(1)
+    
+    
+        If i [<] matchedRows.count Then
+            output = outpu</t></si><si><t xml:space="preserve">.Sheets(ThisWorkbook.Sheets.count))
+        NewSheet.name = "Tables_Extract" [&] currentDateTime
+        
+        ' Add headers to the new sheet
+        With NewSheet
+            .Cells(1, 1).Value = "ID"
+            .Cells(1, 2).Value = "Kind:src"
+         </t></si><si><t>ns
+        Set NewSheet = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.count))
+        NewSheet.name = "Columns_Extract" [&] currentDateTime
+        
+        ' Add headers to the new sheet
+        With NewSheet
+            .Cells(1,</t></si><si><t xml:space="preserve">[&] "'. Creating it..", vbCritical
+        Set NewSheet = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.count))
+        NewSheet.name = mainSheetName
+        
+        ' Copy the template as base table
+        tblExtract.Range.Copy
+  </t></si><si><t>Function FindColumnIndex(tbl As ListObject, colName As String) As Long
+    Dim i As Long
+    For i = 1 To tbl.ListColumns.count
+        If tbl.ListColumns(i).name = colName Then
+            FindColumnIndex = i
+            Exit Function
+        End If
+    N</t></si><si><t xml:space="preserve">ListRows.count = 0 Then Exit Function
+
+    ' Find the "ID" column index
+    On Error Resume Next
+    idColumn = Application.Match("ID", targetTable.HeaderRowRange, 0)
+    On Error GoTo 0
+
+    If idColumn = 0 Then Exit </t></si><si><t xml:space="preserve">f Not tbl.DataBodyRange Is Nothing Then
+                        tbl.DataBodyRange.Copy
+                        ws.Cells(rowIndex, 1).PasteSpecial Paste:=xlPasteValues
+                        rowIndex = rowIndex + tbl.DataBodyRange.Rows.count + 2
+          </t></si><si><t>stsTable As Boolean
+    Dim currentDateTime As String
+    
+    Set wb = ThisWorkbook
+    
+    transferTime = Now()
+    currentDateTime = Format(transferTime, "yymmddhhmm")
+
+    ' Find the _File sheet
+    For Each ws In wb.Sheets
+        If InStr(1, ws.name</t></si><si><t xml:space="preserve">, "_File", vbTextCompare) [>] 0 Then
+            If Not wsTemplate Is Nothing Then
+                MsgBox "Multiple ""_File"" sheets found! </t></si><si><t>Sub requires exactly one file. Stopping execution..", vbCritical
+                Exit Sub
+            End If
+            Set wsTemplate = ws
+        End If
+    Next ws
+
+    If wsTemplate Is Nothing Then
+        MsgBox """_File"" sheet not found! Stopping e</t></si><si><t>xecution..", vbCritical
+        Exit Sub
+    End If
+
+    Application.ScreenUpdating = False
+    Application.Calculation = xlCalculationManual
+    Application.EnableEvents = False
+
+    rowIndex = 1
+    lastRow = wsTemplate.Cells(wsTemplate.Rows.count, 1).En</t></si><si><t xml:space="preserve">d(xlUp).row
+
+    Do While rowIndex [<]= lastRow
+        currentLine = Trim(wsTemplate.Cells(rowIndex, 1).Value)
+
+        If Left(currentLine, 3) = "## " Then
+            ' Parse line: ## SheetName ## TableName ##
+            parts = Split(currentLine, "##")
+</t></si><si><t xml:space="preserve">            If UBound(parts) [<] 2 Then
+                MsgBox "Malformed header at row " [&] rowIndex, vbExclamation
+                Exit Sub
+            End If
+            sheetName = Trim(parts(1))
+            tableName = Trim(parts(2))
+
+            ' Heade</t></si><si><t xml:space="preserve">rs
+            rowIndex = rowIndex + 1
+            colCount = wsTemplate.Cells(rowIndex, wsTemplate.Columns.count).End(xlToLeft).column
+            Set headerRow = wsTemplate.Range(wsTemplate.Cells(rowIndex, 1), wsTemplate.Cells(rowIndex, colCount))
+
+     </t></si><si><t xml:space="preserve">       ' Data starts here
+            rowIndex = rowIndex + 1
+            dataStartRow = rowIndex
+
+            Do While rowIndex [<]= lastRow
+                nextLine = Trim(wsTemplate.Cells(rowIndex, 1).Value)
+                If nextLine = "" Or Left(nextLi</t></si><si><t xml:space="preserve">ne, 2) = "##" Then Exit Do
+                rowIndex = rowIndex + 1
+            Loop
+            dataEndRow = rowIndex - 1
+
+            ' Ensure target sheet exists
+            On Error Resume Next
+            Set targetSheet = wb.Sheets(sheetName)
+        </t></si><si><t xml:space="preserve">    On Error GoTo 0
+            If targetSheet Is Nothing Then
+                Set targetSheet = wb.Sheets.Add(After:=wb.Sheets(wb.Sheets.count))
+                targetSheet.name = sheetName
+            End If
+
+            ' Check if table already exists
+ </t></si><si><t xml:space="preserve">           existsTable = False
+            For Each tbl In targetSheet.ListObjects
+                If tbl.name = tableName Then
+                    existsTable = True
+                    Exit For
+                End If
+            Next tbl
+
+            If </t></si><si><t xml:space="preserve">existsTable Then
+                Call createBackup(sheetName, tableName, currentDateTime)
+                MsgBox "Preexisting table '" [&] tableName [&] "' on sheet '" [&] sheetName [&] "' was backed up and replaced.", vbInformation
+                tbl.Delete
+    </t></si><si><t xml:space="preserve">        End If
+
+            ' Paste table values
+            Set tblRange = wsTemplate.Range(wsTemplate.Cells(headerRow.row, 1), wsTemplate.Cells(dataEndRow, colCount))
+            Set pasteTopLeft = targetSheet.Cells(targetSheet.Cells(targetSheet.Rows.cou</t></si><si><t>nt, 1).End(xlUp).row + 2, 1)
+
+            tblRange.Copy
+            pasteTopLeft.PasteSpecial Paste:=xlPasteValues
+
+
+            ' Create new table
+            targetSheet.ListObjects.Add(xlSrcRange, _
+                pasteTopLeft.Resize(tblRange.Rows.coun</t></si><si><t>t, tblRange.Columns.count), , xlYes).name = tableName
+                
+            Set targetSheet = Nothing
+        Else
+            rowIndex = rowIndex + 1
+        End If
+    Loop
+
+    Application.ScreenUpdating = True
+    Application.Calculation = xlCal</t></si><si><t>culationAutomatic
+    Application.EnableEvents = True
+
+    MsgBox "All table data imported and updated." [&] vbNewLine [&] "Note: Only calculated values of formulas were stored. Use createAndComplementTablesAndColumns to restore formulas in tables.", vbInforma</t></si><si><t xml:space="preserve">tion
+End Sub
+
+
+' Finds the row where a specific keyword is found in column A
+</t></si><si><t xml:space="preserve">Function FindRow(ws As Worksheet, keyword As String) As Long
+    Dim lastRow As Long, i As Long
+    lastRow = ws.Cells(Rows.count, 1).End(xlUp).row
+    For i = 1 To lastRow
+        If ws.Cells(i, 1).Value = keyword Then
+            FindRow = i
+            </t></si><si><t>Function GetColumnIndex(ws As Worksheet, colName As String) As Long
+    Dim i As Long
+    For i = 1 To ws.Cells(1, ws.Columns.count).End(xlToLeft).column
+        If ws.Cells(1, i).Value = colName Then
+            GetColumnIndex = i
+            Exit Functio</t></si><si><t xml:space="preserve">Function sheetExists(sheetName As String, wb As Workbook) As Boolean
+    Dim ws As Worksheet
+    On Error Resume Next
+    Set ws = wb.Sheets(sheetName)
+    sheetExists = Not ws Is Nothing
+    On Error GoTo 0
+End Function
+
+
+</t></si><si><t xml:space="preserve"> Exit For
+            End If
+        Next j
+    Next i
+    
+    ' Identify formula columns
+    Dim formulaColumns As Collection
+    Set formulaColumns = New Collection
+    
+    For j = 1 To ttbl.DataBodyRange.Columns.count
+        If ColumnHasFormula(ttbl.</t></si><si><t xml:space="preserve">      For j = 1 To columnMapping.count
+                Dim mapping As Variant
+                mapping = columnMapping(j)
+    
+                If mapping(1) [>] 0 And mapping(0) [>] 0 Then
+                    targetData(targetRowIdx, mapping(1)) = sourceData(i,</t></si><si><t xml:space="preserve">ange.Value2 = targetData
+    
+    ' Insert new rows
+    If newRows.count [>] 0 Then
+        InsertNewRows newRows, sourceData, columnMapping, ttbl
+    End If
+
+ExitSub:
+    Application.Calculation = xlCalculationAutomatic
+    Application.EnableEvents = True
+ </t></si><si><t xml:space="preserve">Function InsertNewRows(newRows As Collection, sourceData As Variant, columnMapping As Collection, ttbl As ListObject)
+    Dim targetColCount As Long
+    targetColCount = ttbl.ListColumns.count ' Ensure we account for dynamically added columns
+    
+    Dim </t></si><si><t xml:space="preserve">newRowsArray() As Variant
+    ReDim newRowsArray(1 To newRows.count, 1 To targetColCount) ' Resize based on target table columns
+    
+    Dim i As Long, j As Long
+    For i = 1 To newRows.count
+        Dim sourceIdx As Long
+        sourceIdx = newRows(i)
+ </t></si><si><t xml:space="preserve">       
+        For j = 1 To columnMapping.count
+            Dim mapping As Variant
+            mapping = columnMapping(j)
+            If mapping(1) [<]= targetColCount And mapping(0) [<]= UBound(sourceData, 2) Then ' Ensure bounds
+                newRowsArray</t></si><si><t>(i, mapping(1)) = sourceData(sourceIdx, mapping(0))
+            End If
+        Next j
+    Next i
+    
+    Dim newRange As Range
+    Set newRange = ttbl.ListRows.Add(AlwaysInsert:=True).Range
+    If newRows.count [>] 1 Then
+        Set newRange = newRange.Res</t></si><si><t xml:space="preserve">ize(newRows.count, targetColCount)
+    End If
+    newRange.Value2 = newRowsArray
+End Function
+
+
+Private </t></si><si><t xml:space="preserve">
+    Dim segmentsArray() As String
+    Dim i As Integer
+    
+
+    Set segments = camelToBusinessSegments(inputString)
+    
+    ReDim segmentsArray(1 To segments.count)
+    
+    For i = 1 To segments.count
+        segmentsArray(i) = segments(i)
+    Next i
+ </t></si><si><t xml:space="preserve">  Dim segmentsArray() As String
+    Dim i As Integer
+    
+    
+    Set segments = stringToBusinessSegments(inputString)
+    
+    ReDim segmentsArray(1 To segments.count)
+    
+    For i = 1 To segments.count
+        segmentsArray(i) = segments(i)
+    Next i</t></si><si><t xml:space="preserve"> If
+    Next i
+
+    ReDim lineArray(1 To segments.count)
+    
+    For i = 1 To segments.count
+        lineArray(i) = segments(i)
+    Next i
+    
+    inputString = Join(lineArray, "")
+    Set segments = New Collection
+    inputString = handleLists(inputStri</t></si><si><t xml:space="preserve">Add Array("_bsl__", "\")
+    End With
+    
+    ' Replace each special character with its corresponding encoding
+    For i = 1 To specialCharEncodings.count
+        key = specialCharEncodings(i)
+        str = Replace(str, key(1), key(0))
+    Next i
+    
+   </t></si><si><t>d With
+
+
+        
+
+    
+    ' Replace each encoded string with its corresponding special character
+    For i = 1 To specialCharDecodings.count
+        key = specialCharDecodings(i)
+        str = Replace(str, key(1), key(0))
+        'Debug.Print (str)
+    N</t></si><si><t>ws.count [>] 0 Then
+        For i = 1 To updatedRows.count
+            Dim updateInfo As Variant
+            updateInfo = updatedRows(i)
+            Dim sourceRowIdx As Long: sourceRowIdx = CLng(updateInfo(0))
+            Dim targetRowIdx As Long: targetRowI</t></si><si><t>dx = CLng(updateInfo(1))
+            
+            Dim j As Long
+            For j = 1 To columnMapping.count
+                Dim mapping As Variant
+                mapping = columnMapping(j)
+                colIdx = mapping(1)
+                If Not HasFor</t></si><si><t xml:space="preserve">
+        ttbl.DataBodyRange.formula = targetFormulas
+    End If
+    
+    ' Handle new rows
+    If newRows.count [>] 0 Then
+        Dim newRowsArray() As Variant
+        ReDim newRowsArray(1 To newRows.count, 1 To UBound(targetData, 2))
+        
+        For i</t></si><si><t xml:space="preserve"> = 1 To newRows.count
+            CopyRowToArray sourceData, newRowsArray, newRows(i), i, columnMapping
+        Next i
+        
+        Dim newRange As Range
+        Set newRange = ttbl.ListRows.Add(AlwaysInsert:=True).Range
+        If newRows.count [>] 1 Th</t></si><si><t xml:space="preserve">en
+            Set newRange = newRange.Resize(newRows.count, UBound(targetData, 2))
+        End If
+        newRange.Value2 = newRowsArray
+    End If
+    
+ExitSub:
+    Application.Calculation = xlCalculationAutomatic
+    Application.EnableEvents = True
+    </t></si><si><t xml:space="preserve"> To columnMapping.count
+        mapping = columnMapping(i)
+        If mapping(2) Then ' Has formula
+            ' Handle formula columns with stored values
+            HandleStoredValue stbl, ttbl, sourceRowIndex, destRowIndex, _
+                          </t></si><si><t>Function HasFormula(tbl As ListObject, columnName As String) As Boolean
+    Dim col As ListColumn
+    On Error Resume Next
+    Set col = tbl.ListColumns(columnName)
+    On Error GoTo 0
+    
+    If Not col Is Nothing Then
+        If col.DataBodyRange.Rows.c</t></si><si><t>rgetStatus(1 To targetCount + newRows.count, 1 To 2)
+    
+    ' Fill source status array
+    Dim i As Long
+    For i = 1 To sourceCount
+        sourceStatus(i, 1) = "source"
+        sourceStatus(i, 2) = "update target"
+    Next i
+    
+    ' Update status f</t></si><si><t xml:space="preserve">or new rows
+    For i = 1 To newRows.count
+        sourceStatus(newRows(i), 2) = "create target"
+    Next i
+    
+    ' Fill target status array
+    For i = 1 To targetCount + newRows.count
+        targetStatus(i, 1) = "target"
+        targetStatus(i, 2) = </t></si><si><t>e
+    Application.Calculation = xlCalculationManual
+    Application.EnableEvents = False
+    
+    ' Create new sheet
+    With ThisWorkbook
+        
+        .Sheets.Add(After:=.Sheets(.Sheets.count)).name = sheetName
+    End With
+    
+    ' Create ListObjec</t></si><si><t xml:space="preserve">Dim rowCount As Long
+    rowCount = stbl.ListRows.count
+    
+    Dim partyValues() As Variant
+    Dim kindValues() As Variant
+    ReDim partyValues(1 To rowCount, 1 To 1)
+    ReDim kindValues(1 To rowCount, 1 To 1)
+    
+    ' Fill arrays
+    Dim j As Long
+</t></si><si><t>fer party c " [&] timeFormatLong
+    
+    Set targetKindCol = ttbl.ListColumns.Add
+    targetKindCol.name = "transfer kind c " [&] timeFormatLong
+    
+    ' Prepare arrays for target table
+    rowCount = ttbl.ListRows.count
+    ReDim partyValues(1 To rowCount,</t></si><si><t>Sub createBackupTransfer(mode As Boolean)
+
+    Application.ScreenUpdating = False
+    
+    If mode = False Then
+
+        Sheets(sourceTable).Copy After:=Sheets(Sheets.count)
+        ThisWorkbook.Sheets(Sheets.count).name = "source_backup_bT_" [&] Format(tran</t></si><si><t xml:space="preserve">sferTime, "YYYYMMDDHHMM")
+    
+        If targetTable [<][>] "no selection" Then
+            Sheets(targetTable).Copy After:=Sheets(Sheets.count)
+            ThisWorkbook.Sheets(Sheets.count).name = "target_backup_bT_" [&] Format(transferTime, "YYYYMMDDHHMM")
+  </t></si><si><t xml:space="preserve">      End If
+        
+    ElseIf mode = True Then
+    
+        Sheets(sourceTable).Copy After:=Sheets(Sheets.count)
+        ThisWorkbook.Sheets(Sheets.count).name = "source_backup_aT_" [&] Format(transferTime, "YYYYMMDDHHMM")
+    
+        If targetTable [<][>] "</t></si><si><t xml:space="preserve">no selection" Then
+            Sheets(targetTable).Copy After:=Sheets(Sheets.count)
+            ThisWorkbook.Sheets(Sheets.count).name = "target_backup_aT_" [&] Format(transferTime, "YYYYMMDDHHMM")
+        End If
+        
+    End If
+
+    Sheets(1).Select
+
+  </t></si><si><t xml:space="preserve">Function TestString2Camel()
+    Dim inp As String
+    inp = "hello AGO ago Ago Hello"
+    Debug.Print "String-Input: (" [&] inp [&] ")"
+    Debug.Print " "
+    Debug.Print "StringToBusiness: (" [&] stringToBusiness(inp) [&] ")"
+    Debug.Print " "
+    Debug.Print </t></si><si><t xml:space="preserve">"camelCaseUpper: (" [&] camelCaseUpper(inp) [&] ")"
+    Debug.Print " "
+End Function
+
+</t></si><si><t xml:space="preserve">Function TestCamel2Business()
+    Dim inp As String
+    inp = "HelloAgoAgoAgoHello"
+    Debug.Print "Camel-Input: (" [&] inp [&] ")"
+    Debug.Print " "
+    Debug.Print "camelCaseToBusiness: (" [&] camelCaseToBusiness(inp) [&] ")"
+    Debug.Print " "
+End Function
+</t></si><si><t xml:space="preserve"> Dim foundT As Boolean, foundC As Boolean
+    Dim backupName As String
+    
+    transferTime = Now()
+    currentDateTime = Format(transferTime, "yymmddhhmm")
+    
+    startTime = Timer
+    
+    Application.ScreenUpdating = False
+    Application.Calculation</t></si><si><t xml:space="preserve"> = xlCalculationManual
+    Application.EnableEvents = False
+    
+    
+    MsgBox "Creating backups of 'meta_Tables' and 'meta_Columns' and creating temporary extract tables..", vbInformation
+    
+    ' Step 1: Backup existing Tables and Columns if they exi</t></si><si><t>st
+    Set tblTables = createBackup("Tables", "meta_Tables", currentDateTime)
+
+    Set tblColumns = createBackup("Columns", "meta_Columns", currentDateTime)
+
+    ' Step 2: Create Extract Tables
+    Set extractTables = createExtract("Tables", currentDateTim</t></si><si><t>e)
+    
+    Set extractColumns = createExtract("Columns", currentDateTime)
+    
+    ' Step 3: Validate Extract Against Base Tables
+    Set tblTables = compareExtract("Tables", currentDateTime)
+    
+    Set tblColumns = compareExtract("Columns", currentDate</t></si><si><t xml:space="preserve">Time)
+    
+    ' Step 4: Process Metadata from Current Workbook
+    processMetaData (currentDateTime)
+    
+    ' Step 5: Merge Extract Data into Main Tables
+    Call mergeTables(currentDateTime)
+    
+    elapsedTime = Timer - startTime
+    formattedTime = </t></si><si><t>Format(Int(elapsedTime / 60), "00") [&] ":" [&] Format(elapsedTime Mod 60, "00")
+    MsgBox "Current sheet-structure successfully documented in meta_Tables and meta_Columns. Duration: " [&] formattedTime [&] " minutes.", vbInformation
+    
+    
+    Application.Cal</t></si><si><t xml:space="preserve">culation = xlCalculationAutomatic
+    Application.ScreenUpdating = True
+    Application.StatusBar = False
+    Application.EnableEvents = True
+End Sub
+
+
+
+' Helper
+</t></si><si><t xml:space="preserve"> If sheet.name Like "*_Backup*" Or sheet.name Like "*_Extract*" Or _
+           sheet.name Like "*_Branch*" Or sheet.name Like "*_Template*" Or _
+           sheet.name Like "*_Nonmanaged*" Or InStr(sheet.name, currentDateTime) [>] 0 Then GoTo NextSheet
+
+    </t></si><si><t xml:space="preserve">    For Each table In sheet.ListObjects
+            tableCount = tableCount + 1
+            newName = camelCaseToBusiness(table.name)
+            
+            ' Lookup Table ID using a simple loop
+            id = "_" [&] table.name
+            For i = 1 To </t></si><si><t>UBound(tableNames)
+                If tableNames(i) = newName Then
+                    id = tableIDs(i)
+                    Exit For
+                End If
+            Next i
+
+            ' Store table data
+            ReDim Preserve tableExtractArray(1 To</t></si><si><t xml:space="preserve"> 5, 1 To tableCount)
+            tableExtractArray(1, tableCount) = id
+            tableExtractArray(2, tableCount) = "_ExcelTable"
+            tableExtractArray(3, tableCount) = table.name
+            tableExtractArray(4, tableCount) = newName
+           </t></si><si><t xml:space="preserve"> tableExtractArray(5, tableCount) = sheet.name
+
+            ' Iterate through table columns
+            StoredPosition = 1
+            For Each column In table.ListColumns
+                If column.name Like "*transfer*" Or column.name Like "*fix kind*" Th</t></si><si><t>en GoTo NextColumn
+
+                columnCount = columnCount + 1
+                columnID = "_" [&] table.name [&] "_" [&] column.name
+
+                ' Lookup Column ID using a simple loop
+                For i = 1 To UBound(columnNames)
+                    I</t></si><si><t>f columnNames(i) = (id [&] "_" [&] stringToBusiness(column.name)) Then
+                        columnID = columnIDs(i)
+                        Exit For
+                    End If
+                Next i
+
+                ' Store column data
+                ReDim</t></si><si><t xml:space="preserve"> Preserve columnExtractArray(1 To 7, 1 To columnCount)
+                columnExtractArray(1, columnCount) = columnID
+                columnExtractArray(2, columnCount) = "_ExcelColumn"
+                columnExtractArray(3, columnCount) = id
+               </t></si><si><t xml:space="preserve"> columnExtractArray(4, columnCount) = column.Index
+                columnExtractArray(5, columnCount) = IIf(column.DataBodyRange.Cells(1, 1).HasFormula, "", StoredPosition)
+                If Not column.DataBodyRange.Cells(1, 1).HasFormula Then StoredPosit</t></si><si><t>ion = StoredPosition + 1
+                columnExtractArray(6, columnCount) = column.name
+                columnExtractArray(7, columnCount) = IIf(column.DataBodyRange.Cells(1, 1).HasFormula, "Formula:" [&] column.DataBodyRange.Cells(1, 1).formula, "")
+
+Next</t></si><si><t>Column:
+            Next column
+        Next table
+NextSheet:
+    Next sheet
+
+    ' **Write Data in Bulk**
+    If tableCount [>] 0 Then
+        tblTablesExtract.ListRows.Add
+        tblTablesExtract.DataBodyRange.Resize(UBound(tableExtractArray, 2), 5).Value</t></si><si><t xml:space="preserve">2 = Application.Transpose(tableExtractArray)
+    End If
+    If columnCount [>] 0 Then
+        tblColumnsExtract.ListRows.Add
+        tblColumnsExtract.DataBodyRange.Resize(UBound(columnExtractArray, 2), 7).Value2 = Application.Transpose(columnExtractArray)
+ </t></si><si><t xml:space="preserve">   End If
+    
+    MsgBox "Workbook meta-data processed and stored in temporary _extract tables.", vbInformation
+    
+    Erase tableExtractArray
+    Erase columnExtractArray
+    
+    Set tblTablesExtract = Nothing
+    Set tblColumnsExtract = Nothing
+    
+</t></si><si><t xml:space="preserve">    
+End Function
+
+
+
+
+
+' Helper
+</t></si><si><t xml:space="preserve">les As ListObject, tblColumns As ListObject
+    Dim validIDs As Collection
+    
+    MsgBox "Merging updated meta-data into existing meta_Tables and meta_Columns tables. Confirmation about successfull merge will be provided. Please wait..", vbInformation
+
+ </t></si><si><t xml:space="preserve">   ' Cache extract table sheets
+    Set wsTablesExtract = ThisWorkbook.Sheets("Tables_Extract" [&] currentDateTime)
+    Set wsColumnsExtract = ThisWorkbook.Sheets("Columns_Extract" [&] currentDateTime)
+    
+    ' Cache target table sheets
+    Set wsTables = Th</t></si><si><t>isWorkbook.Sheets("Tables")
+    Set wsColumns = ThisWorkbook.Sheets("Columns")
+    
+    ' Access extract tables
+    Set tblTablesExtract = wsTablesExtract.ListObjects(1)
+    Set tblColumnsExtract = wsColumnsExtract.ListObjects(1)
+    
+    ' Access target t</t></si><si><t xml:space="preserve">ables
+    Set tblTables = wsTables.ListObjects(1)
+    Set tblColumns = wsColumns.ListObjects(1)
+
+    ' Step 1: Validate and Merge Tables
+    
+    ' Set source and target table names for global transfer variables
+    sourceTable = tblTablesExtract.name
+    </t></si><si><t>targetTable = tblTables.name
+    
+    ' Extract valid IDs after merge
+    Set validIDs = ExtractIDs(tblTablesExtract)
+    
+    Call mergeObject
+    
+    Set tblTablesExtract = Nothing
+
+    ' Delete rows not in validIDs
+    Call deleteUnmatchedRows(tblTable</t></si><si><t>s, validIDs)
+    
+    Call copyDownFormulas(tblTables)
+
+    ' Step 2: Validate and Merge Columns
+
+    ' Set source and target table names for global transfer variables
+    sourceTable = tblColumnsExtract.name
+    targetTable = tblColumns.name
+    
+    ' Ex</t></si><si><t>tract valid IDs after merge
+    Set validIDs = ExtractIDs(tblColumnsExtract)
+    
+    Call mergeObject
+    
+    Set tblColumnsExtract = Nothing
+
+    ' Delete rows not in validIDs
+    Call deleteUnmatchedRows(tblColumns, validIDs)
+    
+    Call copyDownForm</t></si><si><t>ulas(tblColumns)
+    
+    ' Step 3: remove unneeded sheets
+    
+    ' Delete extracts
+    Application.DisplayAlerts = False
+    wsTablesExtract.Delete
+    wsColumnsExtract.Delete
+    Application.DisplayAlerts = True
+    
+    
+
+    
+    
+End Function
+
+
+' He</t></si><si><t xml:space="preserve">lper
+</t></si><si><t xml:space="preserve">ontent)" [&] vbNewLine [&] _
+        "3 Veri.Excel (all meta tables +  only meta content in Tables/Columns)" [&] vbNewLine [&] _
+        "4 Domain + VBA (all non-meta tables + content + VBA)" [&] vbNewLine [&] _
+        "5 Domain (all non-meta tables + content)", _
+  </t></si><si><t xml:space="preserve">      "Select Export Mode", Type:=1)
+
+    ' Set the copy mode flag based on selection
+    Select Case userChoice
+        Case 1
+            copyMode = "full"
+        Case 2
+            copyMode = "model"
+        Case 3
+            copyMode = "veri"
+       </t></si><si><t xml:space="preserve"> Case 4
+            copyMode = "domainVba"
+        Case 5
+            copyMode = "domain"
+        Case Else
+            MsgBox "Invalid Number. Stopping execution..", vbInformation
+            Exit </t></si><si><t xml:space="preserve">Sub dataFromCodeDefault()
+    Call dataFromCode("Function", 256)
+End Sub
+
+Sub dataFromCodeByModule()
+    Call dataFromCode("Module", 32767)
+End Sub
+
+Sub dataFromCodeByFunctionOrSub()
+    Call dataFromCode("Function", 32767)
+End Sub
+
+' Helper - Exports all existing VBA Modules and Class Modules from this excel workbook into a table "Snippets" in a excel tab "Snippets"
+' If a table "Snippets" already exists, it is deleted and replaced with a new one
+Function dataFromCode(splitType As String, snippetSize As Double)
+    Dim ws As Worksheet
+    Dim tbl As ListObject
+    Dim columnNames As Variant
+    Dim vbaModule As Object
+    Dim vbaContent As String
+    Dim chunks() As String
+    Dim i As Long, j As Long
+    Dim packageName As String, subPackageName As String, kind As String
+    Dim snippetID As Long, vbaComponentCounter As Long
+    Dim vbaComponentHandledCounter As Long, vbaComponentNonEmptyCounter As Long
+    Dim currentLine As Long, chunk As String
+    Dim startTime As Double, elapsedTime As Double
+    Dim splitTypeBackup As String, snippetSizeBackup As Double
+    
+    ' Speed Optimization: Disable events, screen updates, and calculations
+    Application.ScreenUpdating = False
+    Application.Calculation = xlCalculationManual
+    Application.EnableEvents = False
+    
+    splitTypeBackup = splitType
+    snippetSizeBackup = snippetSize
+    startTime = Timer
+    
+    ' Check if "Snippets" sheet exists and create if necessary
+    On Error Resume Next
+    Set ws = ThisWorkbook.Sheets("Snippets")
+    If ws Is Nothing Then
+        Set ws = ThisWorkbook.Sheets.Add
+        ws.name = "Snippets"
+    End If
+    On Error GoTo 0
+    
+    ' Delete existing table if it exists
+    On Error Resume Next
+    Set tbl = ws.ListObjects("meta_Snippets")
+    If Not tbl Is Nothing Then tbl.Delete
+    On Error GoTo 0
+    
+    ' Create table
+    columnNames = Array("ID", "Kind:src", "Kind", "Package", "Sub Package", "Line", "Snippet")
+    Set tbl = ws.ListObjects.Add(xlSrcRange, ws.Range("A1:G1"), , xlYes)
+    tbl.name = "meta_Snippets"
+    ws.Range("A1:G1").Value = columnNames
+    
+    Call setTechnicalName(ws, tbl.name)
+    
+    snippetID = 1
+    vbaComponentCounter = 0
+    vbaComponentHandledCounter = 0
+    vbaComponentNonEmptyCounter = 0
+    
+    ' Loop through all VBA components
+    For Each vbaModule In ThisWorkbook.VBProject.VBComponents
+        vbaComponentCounter = vbaComponentCounter + 1
+        vbaComponentHandledCounter = vbaComponentHandledCounter + 1
+        
+        ' Get module content if it has lines of code
+        If vbaModule.CodeModule.CountOfLines [>] 0 Then
+            vbaContent = vbaModule.CodeModule.lines(1, vbaModule.CodeModule.CountOfLines)
+        Else
+            vbaContent = ""
+        End If
+        
+        ' Process only non-empty modules
+        If vbaContent [<][>] "" Then
+            vbaComponentNonEmptyCounter = vbaComponentNonEmptyCounter + 1
+            
+            ' Determine package, subpackage, and kind
+            Dim moduleName As String
+            moduleName = vbaModule.CodeModule.name
+            Select Case vbaModule.Type
+                Case 1: ' vbext_ct_StdModule
+                    kind = "_ModuleSnippet"
+                    If moduleName = "main" Then
+                        packageName = ""
+                        subPackageName = ""
+                    ElseIf moduleName = "util" Then
+                        packageName = "util"
+                        subPackageName = ""
+                    ElseIf InStr(moduleName, "_") [>] 0 Then
+                        packageName = Split(moduleName, "_")(0)
+                        subPackageName = "::" [&] Replace(Mid(moduleName, Len(packageName) + 2), "_", "::")
+                    Else
+                        packageName = "util"
+                        subPackageName = moduleName
+                    End If
+                Case 2: ' vbext_ct_ClassModule
+                    kind = "_ClassSnippet"
+                    Dim classParts() As String
+                    classParts = Split(moduleName, "_", 2)
+                    packageName = classParts(0)
+                    If UBound(classParts) [>]= 1 Then
+                        subPackageName = "::" [&] Replace(classParts(1), "_", "::")
+                    Else
+                        subPackageName = ""
+                    End If
+                Case 100: ' vbext_ct_Document
+                    kind = "_ExcelTabSnippet"
+                    packageName = moduleName
+                    subPackageName = ""
+                Case 3: ' vbext_ct_MSForm
+                    kind = "_FormSnippet"
+                    packageName = moduleName
+                    subPackageName = ""
+                Case Else
+                    GoTo NextModule
+            End Select
+            
+            ' Force large chunk extraction for "Layer0"
+            If InStr(moduleName, "Layer0") [>] 0 Then
+                splitType = "Module"
+                snippetSize = 32767
+            End If
+            
+            ' Split module into chunks
+            chunks = splitModuleIntoChunks(vbaContent, splitType, snippetSize)
+            splitType = splitTypeBackup
+            snippetSize = snippetSizeBackup
+            
+            ' Add chunks to the table
+            currentLine = 1
+            For j = LBound(chunks) To UBound(chunks)
+                chunk = chunks(j)
+                With tbl.ListRows.Add
+                    .Range(1, 1).Value = "_Snippets"
+                    .Range(1, 2).Value = kind
+                    .Range(1, 3).Value = Replace(kind, "_", "")
+                    .Range(1, 4).Value = packageName
+                    .Range(1, 5).Value = subPackageName
+                    .Range(1, 6).Value = currentLine
+                    .Range(1, 7).Value = chunk
+                End With
+                snippetID = snippetID + 1
+                currentLine = currentLine + 1
+            Next j
+        End If
+NextModule:
+    Next vbaModule
+    
+    ' Restore settings and calculate elapsed time
+    Application.ScreenUpdating = True
+    Application.Calculation = xlCalculationAutomatic
+    Application.EnableEvents = True
+    
+    elapsedTime = Timer - startTime
+    MsgBox "Export completed in " [&] Format(elapsedTime, "0.00") [&] " seconds. " [&] vbaComponentHandledCounter [&] " out of " [&] vbaComponentCounter [&] " components processed. " [&] vbaComponentNonEmptyCounter [&] " non-empty components exported. " [&] "Total snippets: " [&] snippetID, vbInformation
+    
+End Function
+
+' Helper - Function to split the module content into chunks
+Function splitModuleIntoChunks(content As String, splitType As String, snippetSize As Double) As Variant
+    Dim result() As String
+    Dim position As Long
+    Dim start As Long
+    Dim length As Long
+    Dim part As String
+    Dim chunkIndex As Long
+    Dim funcPosition As Long
+    Dim subPosition As Long
+    Dim minPosition As Long
+    Dim nextFuncPosition As Long
+    Dim nextSubPosition As Long
+    Dim nextMinPosition As Long
+
+    position = 1
+    chunkIndex = 0
+    start = 1
+
+    Do While position [<]= Len(content)
+        If splitType = "Function" Then
+            ' Stopword-based splitting logic
+            subPosition = InStr(position, content, "Sub ")
+            funcPosition = InStr(position, content, "Function ")
+
+            If subPosition [>] 0 And funcPosition [>] 0 Then
+                minPosition = Application.WorksheetFunction.Min(subPosition, funcPosition)
+            ElseIf subPosition [>] 0 Then
+                minPosition = subPosition
+            ElseIf funcPosition [>] 0 Then
+                minPosition = funcPosition
+            Else
+                minPosition = 0
+            End If
+
+            If minPosition = start Then
+                ' Search for the next occurrence of "Sub" or "Function"
+                nextSubPosition = InStr(start + 1, content, "Sub ")
+                nextFuncPosition = InStr(start + 1, content, "Function ")
+
+                If nextSubPosition [>] 0 And nextFuncPosition [>] 0 Then
+                    nextMinPosition = Application.WorksheetFunction.Min(nextSubPosition, nextFuncPosition)
+                ElseIf nextSubPosition [>] 0 Then
+                    nextMinPosition = nextSubPosition
+                ElseIf nextFuncPosition [>] 0 Then
+                    nextMinPosition = nextFuncPosition
+                Else
+                    nextMinPosition = 0
+                End If
+
+                ' Determine the length based on the next keyword position or snippetSize char limit
+                If nextMinPosition = 0 Or (nextMinPosition - start) [>]= snippetSize Then
+                    length = snippetSize
+                Else
+                    length = nextMinPosition - start
+                End If
+            Else
+                If minPosition = 0 Or (minPosition - start) [>]= snippetSize Then
+                    length = snippetSize
+                Else
+                    length = minPosition - start
+                End If
+            End If
+        ElseIf splitType = "Module" Then
+            ' Split only by snippetSize
+            length = snippetSize
+        End If
+
+        ' Extract the part of the content for this chunk
+        part = Mid(content, start, length)
+
+        ' Add the chunk to the result array
+        ReDim Preserve result(chunkIndex)
+        result(chunkIndex) = part
+
+        ' Escape chunk if it starts with "=" or a single quote
+        If Left(result(chunkIndex), 1) = "=" Then
+            result(chunkIndex) = "'" [&] result(chunkIndex)
+        ElseIf Left(result(chunkIndex), 1) = "'" Then
+            result(chunkIndex) = "'" [&] result(chunkIndex)
+        End If
+
+        chunkIndex = chunkIndex + 1
+        start = start + length
+        position = start
+    Loop
+
+    splitModuleIntoChunks = result
+End Function
+
+
+
+'ATTENTION, action is irreversible, make sure to have backup / export / snippets
+Sub deleteAllVBA()
+    Dim vbComp As VBComponent
+    Dim vbProj As VBProject
+
+    ' Ensure the VBA Extensibility reference is enabled
+    On Error Resume Next
+    Set vbProj = ThisWorkbook.VBProject
+    On Error GoTo 0
+
+    For Each vbComp In vbProj.VBComponents
+        Select Case vbComp.Type
+            ' Delete Class Modules and Standard Modules
+            Case vbext_ct_ClassModule, vbext_ct_StdModule, vbext_ct_MSForm
+                vbProj.VBComponents.Remove vbComp
+
+            ' Empty all Document modules (e.g., ThisWorkbook, worksheets)
+            Case vbext_ct_Document
+                With vbComp.CodeModule
+                    .DeleteLines 1, .CountOfLines
+                End With
+        End Select
+    Next vbComp
+End Sub
+
+'Creates VBA code from Snippets table
+
+'Remark: The following error:
+' An error occurred: Method 'Add' of object '_VBComponents' failed
+'is handled with -[>] VBA editor -[>] "Tools" -[>] "References" -[>] activating "Microsoft Visual Basic for Applications Extensibility 5.3"
+
+Sub codeFromData()
+    Dim ws As Worksheet
+    Dim tbl As ListObject
+    Dim row As ListRow
+    Dim moduleName As String
+    Dim package As String
+    Dim subPackage As String
+    Dim kindSrc As String
+    Dim snippet As String
+    Dim vbaComponent As Object
+    Dim foundTable As Boolean
+    Dim i As Long
+    
+    ' Arrays to store module names, types, and their concatenated code snippets
+    Dim moduleNames() As String
+    Dim moduleTypes() As String
+    Dim moduleCode() As String
+    Dim moduleCount As Long
+    Dim moduleCreatedCount As Long
+    Dim moduleFilledCount As Long
+    
+    moduleCount = 0
+    moduleFilledCount = 0
+    moduleCreatedCount = 0
+    
+    
+    ' Find the "Snippets" table or a table containing "Snippets" in its name
+    foundTable = False
+    For Each ws In ThisWorkbook.Worksheets
+        For Each tbl In ws.ListObjects
+            If tbl.name = "meta_Snippets" Or InStr(1, tbl.name, "meta_Snippets", vbTextCompare) [>] 0 Then
+                foundTable = True
+                Exit For
+            End If
+        Next tbl
+        If foundTable Then Exit For
+    Next ws
+    
+    If Not foundTable Then
+        MsgBox "Table 'meta_Snippets' not found. Attempting to create VBA from TablesAsFile."
+        
+        Set tbl = createSnippetsFromTemplate()
+        If tbl Is Nothing Then
+            MsgBox "No TablesAsFile found. VBA code can't be generated. Stopping execution."
+            Exit Sub
+        End If
+    End If
+    
+    ' Sort the table by Package, Subpackage, and Line columns
+    With tbl.Sort
+        .SortFields.Clear
+        .SortFields.Add key:=tbl.ListColumns("Package").Range, SortOn:=xlSortOnValues, Order:=xlAscending
+        .SortFields.Add key:=tbl.ListColumns("Sub Package").Range, SortOn:=xlSortOnValues, Order:=xlAscending
+        .SortFields.Add key:=tbl.ListColumns("Line").Range, SortOn:=xlSortOnValues, Order:=xlAscending
+        .Header = xlYes
+        .Apply
+    End With
+    
+    For Each row In tbl.ListRows
+        If Not (row.Range(tbl.ListColumns("ID").Index).Value = "_SnippetsRowTemplate") Then
+            package = row.Range(tbl.ListColumns("Package").Index).Value
+            subPackage = row.Range(tbl.ListColumns("Sub Package").Index).Value
+            kindSrc = row.Range(tbl.ListColumns("Kind:src").Index).Value
+            snippet = row.Range(tbl.ListColumns("Snippet").Index).Value
+            If Left(snippet, 2) = "''" Then
+                snippet = Mid(snippet, 2)
+            End If
+            
+            ' Determine the name of the VBA module/class based on Package and Subpackage
+            Select Case True
+                Case package = "" And subPackage = ""
+                    moduleName = "main"
+                Case package = "util" And subPackage = ""
+                    moduleName = "util"
+                Case package = "util" And Left(subPackage, 2) [<][>] "::"
+                    moduleName = subPackage
+                Case package [<][>] "" And subPackage Like "::*"
+                    moduleName = package [&] Replace(subPackage, "::", "_")
+                Case Else
+                    moduleName = package
+            End Select
+            
+            ' Check if the moduleName already exists in the array
+            Dim Exists As Boolean
+            Exists = False
+            For i = 0 To moduleCount - 1
+                If moduleNames(i) = moduleName Then
+                    moduleCode(i) = moduleCode(i) [&] snippet
+                    Exists = True
+                    Exit For
+                End If
+            Next i
+            
+            If Not Exists Then
+                ' Resize the arrays and add the new module name and snippet
+                ReDim Preserve moduleNames(moduleCount)
+                ReDim Preserve moduleTypes(moduleCount)
+                ReDim Preserve moduleCode(moduleCount)
+                moduleNames(moduleCount) = moduleName
+                moduleCode(moduleCount) = snippet
+                moduleTypes(moduleCount) = kindSrc
+                
+                Debug.Print moduleNames(moduleCount) [&] " is stored in position " [&] moduleCount [&] " with Type " [&] moduleTypes(moduleCount)
+             
+                moduleCount = moduleCount + 1
+                
+            End If
+        End If
+    Next row
+    
+
+    For i = 0 To moduleCount - 1
+        
+        ' DO NOT re-generate Layer0, as this has to be generated manually prior to this code execution
+        If moduleNames(i) [<][>] "Layer0" Then
+            On Error Resume Next
+            Set vbaComponent = ThisWorkbook.VBProject.VBComponents(moduleNames(i))
+            On Error GoTo 0
+            
+            If vbaComponent Is Nothing Then
+                ' Determine the type based on the module name
+                If InStr(1, moduleTypes(i), "_ClassSnippet") [>] 0 Then
+                    Set vbaComponent = ThisWorkbook.VBProject.VBComponents.Add(vbext_ct_ClassModule)
+                ElseIf InStr(1, moduleTypes(i), "_ModuleSnippet") [>] 0 Then
+                    Set vbaComponent = ThisWorkbook.VBProject.VBComponents.Add(vbext_ct_StdModule)
+                ElseIf InStr(1, moduleTypes(i), "_ExcelTabSnippet") [>] 0 Then
+                    'Set vbaComponent = ThisWorkbook.VBProject.VBComponents.Add(vbext_ct_Document)
+                    GoTo NextIteration
+                ElseIf InStr(1, moduleTypes(i), "_FormSnippet") [>] 0 Then
+                    ' Skip the iteration for "_FormSnippet"
+                    GoTo NextIteration
+                End If
+                vbaComponent.name = moduleNames(i)
+                Debug.Print moduleNames(i) [&] " created!"
+                moduleCreatedCount = moduleCreatedCount + 1
+            End If
+            
+            ' Clear any existing code in the module and insert the concatenated content
+            vbaComponent.CodeModule.DeleteLines 1, vbaComponent.CodeModule.CountOfLines
+            vbaComponent.CodeModule.InsertLines 1, moduleCode(i)
+            moduleFilledCount = moduleFilledCount + 1
+            Debug.Print moduleNames(i) [&] " filled!"
+            Set vbaComponent = Nothing
+        End If
+NextIteration:
+    Next i
+    
+    MsgBox "Import from 'meta_Snippets' table to VBA components completed." [&] vbCrLf [&] moduleCount [&] " VBA components were identified in 'Snippets' table." [&] vbCrLf [&] " - thereof " [&] moduleCreatedCount [&] " new componets were created." [&] vbCrLf [&] " - thereof " [&] moduleFilledCount [&] " componets were filled." [&] vbCrLf [&] vbCrLf [&] "(Layer0 is identified but never created/filled, as this should be done manually. Forms are identified but never created/filled, these need to be created using CreateForms.CreateForms)"
+End Sub
+
+' Helper - removes all data from tables except for  specified tables / tables-package combinations
+Function removeAllButFirstRowAndResizeTables()
+
+    Dim ws As Worksheet
+    Dim tbl As ListObject
+    Dim tblName As String
+    Dim rowTemplateID As String
+    Dim dataRange As Range
+    Dim cell As Range
+    Dim columnPackage As Range
+    Dim packageValue As Variant
+    Dim excludeTables As Variant
+    Dim checkPackageTables As Variant
+    Dim rowsToKeep() As Variant
+    Dim keepRowCount As Long
+    Dim i As Long
+    
+    ' Define tables to skip unconditionally
+    excludeTables = Array("meta_Tables", "meta_Columns", "meta_NonCapitalizedTitleWords", "meta_TablePatterns", "meta_CodeTemplates", "meta_DocumentVersions", "meta_PackageDocumentation")
+    
+    ' Define tables to check for "Package" column
+    checkPackageTables = Array("meta_Classifiers", "meta_TypedElements", "meta_Rules", "meta_Literals")
+    
+    ' Loop through each worksheet and each table
+    For Each ws In ThisWorkbook.Worksheets
+        For Each tbl In ws.ListObjects
+            tblName = tbl.name
+            
+            ' Skip excluded tables
+            If isInArray(tblName, excludeTables) Then
+                GoTo SkipTable
+            End If
+            
+            ' Special handling for "checkPackageTables"
+            If isInArray(tblName, checkPackageTables) Then
+                On Error Resume Next
+                Set columnPackage = tbl.ListColumns("Package").DataBodyRange
+                On Error GoTo 0
+                
+                ' Only proceed if the "Package" column exists
+                If Not columnPackage Is Nothing Then
+                    ' Initialize the array to store rows to keep
+                    ReDim rowsToKeep(1 To tbl.ListRows.count, 1 To tbl.DataBodyRange.Columns.count)
+                    keepRowCount = 0
+                    
+                    ' Collect rows to keep
+                    For i = 1 To columnPackage.Rows.count
+                        packageValue = columnPackage.Cells(i, 1).Value
+                        
+                        ' Check the type and value of the package column cell
+                        If Not IsError(packageValue) And VarType(packageValue) = vbString Then
+                            If packageValue = "meta" Or packageValue = "util" Then
+                                keepRowCount = keepRowCount + 1
+                                rowsToKeep(keepRowCount, 1) = tbl.DataBodyRange.Rows(i).Value
+                            End If
+                        End If
+                    Next i
+                    
+                    ' Clear the table entirely
+                    If tbl.ListRows.count [>] 0 Then
+                        tbl.DataBodyRange.ClearContents
+                    End If
+                    
+                    ' Add back the rows to keep
+                    If keepRowCount [>] 0 Then
+                        tbl.Resize tbl.HeaderRowRange.Resize(1 + keepRowCount, tbl.HeaderRowRange.Columns.count)
+                        For i = 1 To keepRowCount
+                            tbl.ListRows.Add
+                            tbl.DataBodyRange.Rows(i).Value = rowsToKeep(i, 1)
+                        Next i
+                        
+                        ' Resize again to remove any extra rows
+                        Dim lastRow As Long
+                        On Error Resume Next
+                        lastRow = tbl.DataBodyRange.Find("*", SearchOrder:=xlByRows, SearchDirection:=xlPrevious).row
+                        On Error GoTo 0
+                        If lastRow [>] tbl.HeaderRowRange.row Then
+                            tbl.Resize tbl.HeaderRowRange.Resize(lastRow - tbl.HeaderRowRange.row + 1, tbl.HeaderRowRange.Columns.count)
+                        Else
+                            tbl.Resize tbl.HeaderRowRange.Resize(2, tbl.HeaderRowRange.Columns.count)
+                        End If
+                    Else
+                        ' If no rows to keep, resize to one empty row
+                        If Not tbl.DataBodyRange Is Nothing Then
+                            tbl.Resize tbl.HeaderRowRange.Resize(2, tbl.HeaderRowRange.Columns.count)
+                            tbl.DataBodyRange.ClearContents
+                        End If
+                    End If
+                    
+                    GoTo SkipTable
+                End If
+            End If
+            
+            ' General case: Remove all rows but the first row
+            rowTemplateID = "_" [&] tblName [&] "RowTemplate"
+            
+            'Debug.Print rowTemplateID
+            
+            If tbl.ListRows.count [>] 1 Then
+                ' Delete all rows except the first
+                tbl.DataBodyRange.Offset(1, 0).Resize(tbl.DataBodyRange.Rows.count - 1).Delete
+            ElseIf tbl.ListRows.count = 0 Then
+                tbl.ListRows.Add
+            End If
+            
+            ' Add the row template ID to the first row, column 1
+            tbl.ListRows(1).Range.Cells(1, 1).Value = rowTemplateID
+            
+            ' Preserve formulas in the first row, clear non-formula cells
+            With tbl.ListRows(1).Range
+                For Each cell In .Cells
+                    If Not cell.HasFormula And cell.column [<][>] tbl.ListColumns(1).Range.column Then
+                        cell.ClearContents
+                    End If
+                Next cell
+            End With
+            
+            ' Resize table to only the first row
+            With tbl
+                .Resize tbl.HeaderRowRange.Resize(2, .HeaderRowRange.Columns.count)
+            End With
+            
+SkipTable:
+        Next tbl
+    Next ws
+    
+
+End Function
+' Helper
+Function isInArray(valueToFind As String, arr As Variant) As Boolean
+    Dim i As Variant
+    For Each i In arr
+        If i = valueToFind Then
+            isInArray = True
+            Exit Function
+        End If
+    Next i
+    isInArray = False
+End Function
+
+Sub createVersionWithoutDataAndCode()
+    
+    Dim startTime As Single
+    Dim elapsedTime As Single
+    
+    
+    If MsgBox("Press OK to remove data (meta/util data not removed).", vbOKCancel + vbExclamation, "Continue or Cancel") = vbCancel Then
+        Exit Sub ' Exit the macro
+    End If
+    
+    startTime = Timer
+    
+    Application.EnableEvents = False
+    
+    ' call RemoveAllButFirstRowAndResizeTables to remove data
+   Call removeAllButFirstRowAndResizeTables
+
+    elapsedTime = Timer - startTime
+    
+    Dim hours As Long
+    Dim minutes As Long
+    Dim seconds As Long
+    
+    hours = Int(elapsedTime / 3600)
+    minutes = Int((elapsedTime Mod 3600) / 60)
+    seconds = Int(elapsedTime Mod 60)
+    
+    If MsgBox("Successfully removed data in " [&] Format(hours, "00") [&] ":" [&] Format(minutes, "00") [&] ":" [&] Format(seconds, "00") [&] " Press OK to execute dataFromCode and create VBA snippets.", vbOKCancel + vbExclamation, "Continue or Cancel") = vbCancel Then
+        Exit Sub ' Exit the macro
+    End If
+    
+    ' Call dataFromCodeDefault to extract code to snippets table
+    Call dataFromCodeDefault
+    
+    If MsgBox("Successfully created snippets. Press OK to execute deleteModulesAndEmptyDocuments and remove all VBA content.", vbOKCancel + vbExclamation, "Continue or Cancel") = vbCancel Then
+        Exit Sub ' Exit the macro
+    End If
+
+    ' Call deleteAllVBA to remove code modules
+    Call deleteAllVBA
+
+    'MsgBox "Successfully removed all VBA content. Saving file as .xlsx ..."
+    ' Save the modified workbook with "_noDataNoCode" suffix
+    
+    'skipping for now, due to error
+    
+    'Application.DisplayAlerts = False
+    
+    ' Construct the new file name with .xlsx extension
+    'newFileName = ThisWorkbook.Path [&] "/" [&] Replace(ThisWorkbook.Name, ".xlsm", "_noDataNoCode.xlsx")
+    
+    ' Save a copy of the workbook as .xlsx
+    'ThisWorkbook.SaveAs FileName:=newFileName, FileFormat:=51
+    
+    'Application.DisplayAlerts = True
+
+    elapsedTime = Timer - startTime
+    
+    hours = Int(elapsedTime / 3600)
+    minutes = Int((elapsedTime Mod 3600) / 60)
+    seconds = Int(elapsedTime Mod 60)
+
+    MsgBox "Execution completed in " [&] Format(hours, "00") [&] ":" [&] Format(minutes, "00") [&] ":" [&] Format(seconds, "00") [&] vbCrLf [&] "Workbook does not contain any data or vba content anymore." [&] vbCrLf [&] "Please proceed to save as .xlsx manually."
+    
+    Application.EnableEvents = True
+End Sub
+
+Sub setAllTechnicalNames()
+    Dim ws As Worksheet
+    Dim vbComp As VBIDE.VBComponent
+    
+    For Each ws In ThisWorkbook.Worksheets
+        For Each vbComp In ThisWorkbook.VBProject.VBComponents
+            If ws.CodeName = vbComp.name Then
+            
+                newName = ws.name
+                
+                '(Name) property has to start with letter
+                If Not (Mid(newName, 1, 1) Like "[A-Za-z]") Then
+                    newName = "A" [&] newName
+                End If
+                
+                '(Name) property only allows for max 31 characters
+                vbComp.name = Left(newName, 31)
+            End If
+        Next vbComp
+    Next ws
+    
+End Sub
+
+Function setTechnicalName(ws As Worksheet, tableName As String)
+    Dim vbComp As VBIDE.VBComponent
+    Dim backupNameTable As String
+    Dim startTime As Double
+
+    backupNameTable = Left(tableName, 30)
+
+    ' Ensure name starts with a letter
+    If Not (Mid(backupNameTable, 1, 1) Like "[A-Za-z]") Then
+        backupNameTable = "A" [&] backupNameTable
+    End If
+
+    ' Try to get the VBComponent with a short wait loop
+    startTime = Timer
+    Do
+        On Error Resume Next
+        Set vbComp = ThisWorkbook.VBProject.VBComponents(ws.CodeName)
+        On Error GoTo 0
+        If Not vbComp Is Nothing Then Exit Do
+        DoEvents
+        If Timer - startTime [>] 2 Then Exit Do ' continue, just skip renaming
+    Loop
+
+    ' Rename only if VBComponent was successfully set
+    If Not vbComp Is Nothing Then
+        On Error Resume Next
+        vbComp.name = backupNameTable
+        On Error GoTo 0
+    End If
+End Function
+
+
+Function createSnippetsFromTemplate() As ListObject
+    Dim wsTemplate As Worksheet
+    Set wb = ThisWorkbook
+
+    ' Locate the template sheet dynamically
+    For Each wsTemplate In wb.Sheets
+        If InStr(1, wsTemplate.name, "_File", vbTextCompare) [>] 0 Then Exit For
+    Next wsTemplate
+    If wsTemplate Is Nothing Then
+        MsgBox "Template sheet not found!", vbCritical
+        Set createSnippetsFromtTemplate = Nothing
+        Exit Function
+    End If
+
+    Set wsSnippets = wb.Sheets.Add
+    wsSnippets.name = "Snippets"
+    
+    ' Locate and copy VBA Snippets Data
+    rowIndex = FindRow(wsTemplate, "## Snippets ## meta_Snippets ##") + 1
+    
+    ' Find the end of the Snippets section (next '##' or end of data)
+    lastRow = wsTemplate.Cells(wsTemplate.Rows.count, 1).End(xlUp).row
+    endRow = lastRow
+    
+    For i = rowIndex + 1 To lastRow
+        If Left(Trim(wsTemplate.Cells(i, 1).Value), 2) = "##" Then
+            endRow = i - 1
+            Exit For
+        End If
+    Next i
+    
+    ' Copy header row
+    wsTemplate.Rows(rowIndex).Copy
+    wsSnippets.Cells(1, 1).PasteSpecial Paste:=xlPasteValues
+    
+    ' Copy snippet data (if any)
+    If endRow [>] rowIndex Then
+        wsTemplate.Range(wsTemplate.Cells(rowIndex + 1, 1), wsTemplate.Cells(endRow, wsTemplate.UsedRange.Columns.count)).Copy
+        wsSnippets.Cells(2, 1).PasteSpecial Paste:=xlPasteValues
+    End If
+
+    ' Create Snippets Table
+    Set rng = wsSnippets.Range("A1").CurrentRegion
+    Set tbl = wsSnippets.ListObjects.Add(xlSrcRange, rng, , xlYes)
+    tbl.name = "meta_Snippets"
+
+    Set createSnippetsFromTemplate = tbl
+End Function
+
+' Finds the row where a specific keyword is found in column A
+Function FindRow(ws As Worksheet, keyword As String) As Long
+    Dim lastRow As Long, i As Long
+    lastRow = ws.Cells(Rows.count, 1).End(xlUp).row
+    For i = 1 To lastRow
+        If ws.Cells(i, 1).Value = keyword Then
+            FindRow = i
+            Exit Function
+        End If
+    Next i
+    FindRow = 0
+End Function
+
+
+
+
+
+</t></si><si><t xml:space="preserve">ext i
+
+    
+    camelDecodeSpecialCharacters = str
+End Function
+
+</t></si><si><t>Function handleCapitalization(inputString As String) As String
+    Dim ws As Worksheet
+    Dim wordList As ListObject
+    Dim wordRange As Range
+    Dim wordArray() As String
+    Dim currentWord As String
+    Dim result As String
+    Dim separators As Stri</t></si><si><t xml:space="preserve">ng
+    Dim isWord As Boolean
+    Dim i As Long
+    Dim char As String
+    Dim hasWordList As Boolean
+    Dim word As Variant
+
+    ' Try to set the worksheet and table
+    On Error Resume Next
+    Set ws = ThisWorkbook.Sheets("Non Capitalized Title Words")
+</t></si><si><t xml:space="preserve">    If Not ws Is Nothing Then
+        Set wordList = ws.ListObjects("meta_NonCapitalizedTitleWords")
+        If Not wordList Is Nothing Then
+            hasWordList = True
+        End If
+    End If
+    On Error GoTo 0
+
+    ' If word list is found, load int</t></si><si><t>o array for faster lookup
+    If hasWordList Then
+        ReDim wordArray(1 To wordList.ListRows.count)
+        i = 1
+        For Each wordRange In wordList.ListColumns("Word").DataBodyRange
+            wordArray(i) = LCase(wordRange.Value)
+            i =</t></si><si><t xml:space="preserve"> i + 1
+        Next wordRange
+    End If
+
+    ' Reset variables for processing
+    currentWord = ""
+    separators = ""
+    isWord = True
+    result = ""
+
+    ' Go through each character
+    For i = 1 To Len(inputString)
+        char = Mid(inputString, i, </t></si><si><t xml:space="preserve">1)
+
+        If char Like "[A-Za-z]" Then
+            If Not isWord Then
+                result = result [&] separators
+                separators = ""
+                isWord = True
+            End If
+            currentWord = currentWord [&] char
+        Else
+</t></si><si><t xml:space="preserve">            If isWord Then
+                currentWord = UCase(Left(currentWord, 1)) [&] Mid(currentWord, 2)
+
+                If hasWordList Then
+                    For Each word In wordArray
+                        If StrComp(currentWord, word, vbTextCompa</t></si><si><t xml:space="preserve">re) = 0 Then
+                            currentWord = LCase(currentWord)
+                            Exit For
+                        End If
+                    Next word
+                End If
+
+                result = result [&] currentWord
+              </t></si><si><t xml:space="preserve">  currentWord = ""
+                isWord = False
+            End If
+            separators = separators [&] char
+        End If
+    Next i
+
+    ' Process any remaining word
+    If currentWord [<][>] "" Then
+        currentWord = UCase(Left(currentWord, 1)) [&] Mi</t></si><si><t>d(currentWord, 2)
+
+        If hasWordList Then
+            For Each word In wordArray
+                If StrComp(currentWord, word, vbTextCompare) = 0 Then
+                    currentWord = LCase(currentWord)
+                    Exit For
+                En</t></si><si><t xml:space="preserve">d If
+            Next word
+        End If
+
+        result = result [&] currentWord
+    End If
+
+    ' Add any trailing separators
+    If separators [<][>] "" Then
+        result = result [&] separators
+    End If
+
+    ' Capitalize first character of final result
+  </t></si><si><t xml:space="preserve">  handleCapitalization = UCase(Left(result, 1)) [&] Mid(result, 2)
+End Function
+
+
+
+
+</t></si><si><t xml:space="preserve">n.Cells(1, 1).formula
+                    On Error GoTo 0
+
+                    If mode = "overwrite" Then
+                        On Error Resume Next
+                        Err.Clear
+                        rngColumn.formula = Mid(colFormula, 9)
+        </t></si><si><t xml:space="preserve">                If Err.Number [<][>] 0 Then
+                        MsgBox "Invalid Formula. Skipping this column." [&] vbCrLf [&] "Failed to apply formula in column '" [&] colLabel [&] "' of table '" [&] tableName [&] "'." [&] vbCrLf [&] _
+                               "For</t></si><si><t xml:space="preserve">mula: " [&] Mid(colFormula, 9) [&] vbCrLf [&] "End.", vbExclamation, "Formula Error - Skipping Column"
+                        Err.Clear
+                        
+                        End If
+                        On Error GoTo 0
+
+
+                    ElseIf </t></si><si><t xml:space="preserve">mode = "backupV" Or mode = "backupF" Then
+                        If existingFormula [<][>] Mid(colFormula, 9) Then
+                            ' Queue backup request for later
+                            
+                            
+                         </t></si><si><t xml:space="preserve">   Dim valuesArray As Variant
+                            valuesArray = rngColumn.Value2
+                            
+                            Dim firstFormula As String
+                            firstFormula = rngColumn.Cells(1, 1).formula
+
+         </t></si><si><t xml:space="preserve">                   backupRequests.Add Array(colLabel, firstFormula, valuesArray)
+                            rngColumn.formula = Mid(colFormula, 9)
+                        Else
+                            rngColumn.formula = Mid(colFormula, 9)
+            </t></si><si><t xml:space="preserve">            End If
+                    End If
+                End If
+            Else
+                ' Add new column
+                Dim newCol As ListColumn
+                Set newCol = tblTarget.ListColumns.Add(position:=colPos)
+                newCol.</t></si><si><t>name = colLabel
+                If colFormula [<][>] "" And Left(colFormula, 8) = "Formula:" Then
+                    newCol.DataBodyRange.formula = Mid(colFormula, 9)
+                End If
+            End If
+        End If
+    Next rowColumn
+
+    ' === Apply</t></si><si><t xml:space="preserve"> backup columns after all standard columns ===
+    Dim b As Variant
+    For Each b In backupRequests
+        colLabel = b(0)
+        existingFormula = b(1)
+        Dim storedValues As Variant: storedValues = b(2)
+
+        Dim backupName As String: backupNa</t></si><si><t xml:space="preserve">me = colLabel [&] "_backup" [&] currentDateTime
+        On Error Resume Next
+        tblTarget.ListColumns(backupName).Delete
+        On Error GoTo 0
+
+        Dim backupCol As ListColumn
+        Set backupCol = tblTarget.ListColumns.Add
+        backupCol.name </t></si><si><t>= backupName
+
+        If mode = "backupV" Then
+            backupCol.DataBodyRange.Value = storedValues
+        ElseIf mode = "backupF" Then
+            backupCol.DataBodyRange.formula = existingFormula
+        End If
+
+    Next b
+
+    ' === Remove extra co</t></si><si><t>lumns not in meta_Columns ===
+    For i = tblTarget.ListColumns.count To 1 Step -1
+        Dim currentLabel As String
+        currentLabel = tblTarget.ListColumns(i).name
+        If Right(currentLabel, 21) = "_backup" [&] currentDateTime Then GoTo SkipDelete</t></si><si><t xml:space="preserve">
+
+        Dim keep As Boolean: keep = False
+        For j = 1 To labelCount
+            If expectedLabels(j) = currentLabel Then
+                keep = True
+                Exit For
+            End If
+        Next j
+
+        If Not keep Then tblTarget.List</t></si><si><t xml:space="preserve">Columns(i).Delete
+SkipDelete:
+    Next i
+
+    Set tblTarget = Nothing
+    Set wsTarget = Nothing
+End Function
+
+
+
+</t></si><si><t>NameSheet = tabName [&] "_Backup" [&] currentDateTime
+    backupNameTable = tableName [&] "_Backup" [&] currentDateTime
+    
+    On Error Resume Next
+    Set wsTables = ThisWorkbook.Sheets(tabName)
+    If Not wsTables Is Nothing Then
+        Set tblTables = wsTabl</t></si><si><t xml:space="preserve">es.ListObjects(tableName)
+        If Not tblTables Is Nothing Then
+            Set NewSheet = ThisWorkbook.Sheets.Add(After:=ThisWorkbook.Sheets(ThisWorkbook.Sheets.count))
+            NewSheet.name = backupNameSheet
+            
+            Set fullRange </t></si><si><t>= tblTables.Range
+            fullRange.Copy
+            NewSheet.Range("A1").PasteSpecial Paste:=xlPasteAll
+            Application.CutCopyMode = False
+            
+            Set newTable = NewSheet.ListObjects(1)
+            newTable.name = backupNameT</t></si><si><t xml:space="preserve">able
+            
+            Call setTechnicalName(NewSheet, backupNameTable)
+            
+            Set createBackup = tblTables
+
+        End If
+    End If
+    On Error GoTo 0
+End Function
+
+' Helper
+</t></si><si><t xml:space="preserve">mnIndex = 0 ' Return 0 if not found
+End Function
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+</t></si><si><t>Referenced Table:srcLastSaved</t></si><si><t>Referenced Table Display and Select Column</t></si><si><t>Kind:srcLastSaved</t></si><si><t>Owning Table:srcLastSaved</t></si><si><t>Referenced Table Display and Select Column:srcLastSaved</t></si><si><t>Property:srcLastSaved</t></si><si><t>Instances Class:srcLastSaved</t></si><si><t>finance::Portfolio.value</t></si><si><t>Class - Display Property:srcLastSaved</t></si><si><t>Property - Owning Class:srcLastSaved</t></si><si><t>Type:srcLastSaved</t></si><si><t>ExcelColumn</t></si><si><t>ExcelTable</t></si><si><t>TypedModelElement</t></si><si><t>Class - Generalization:srcLastSaved</t></si><si><t>Reference - Opposite:srcLastSaved</t></si><si><t>Reference - Display and Select Property:srcLastSaved</t></si><si><t>Function - Owning Property:srcLastSaved</t></si><si><t>Parameter - Owning Function:srcLastSaved</t></si><si><t>Property - Using Property:srcLastSaved</t></si><si><t>Table 2 Ref:srcLastSaved</t></si><si><t>Code</t></si><si><t>Typed Model Elements</t></si><si><t>My XYZ Objects</t></si><si><t>Document Versions</t></si><si><t>belowred::Table1Rows</t></si><si><t>finance::Portfolios</t></si><si><t>finance::Positions</t></si><si><t>finance::Securities</t></si><si><t>belowred::Table2Rows</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved], MATCH([@[Generalization 5]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved], MATCH([@[Generalization 4]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved], MATCH([@[Generalization 3]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved], MATCH([@[Generalization 2]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved], MATCH([@[Generalization 1]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved], MATCH([@[Owning Table Instances Class]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=IFNA(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property Owning Class]],meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0))
+=[@[Owning Table Instances Class]],FALSE)</t></si><si><t>Formula:=IFNA(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property Owning Class]],meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0))
+=[@[Owning Table Instances Class]],FALSE)</t></si><si><t>Formula:=IFNA(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property Owning Class]],meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0))
+=[@[Owning Table Instances Class]],FALSE)</t></si><si><t>Formula:=IFNA(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property Owning Class]],meta_Classifiers[ID],0)),meta_Classifiers[ID],0)),meta_Classifiers[ID],0))
+=[@[Owning Table Instances Class]],FALSE)</t></si><si><t>Formula:=IFNA(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH(
+INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property Owning Class]],meta_Classifiers[ID],0)),meta_Classifiers[ID],0))
+=[@[Owning Table Instances Class]],FALSE)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property Owning Class]],meta_Classifiers[ID],0))=[@[Owning Table Instances Class]],FALSE)</t></si><si><t>Formula:=INDEX(meta_Classifiers[Name],MATCH(INDEX(meta_TypedModelElements[Property - Owning Class:srcLastSaved],MATCH([@Property],meta_TypedModelElements[ID],0)),meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_TypedModelElements[Property - Owning Class:srcLastSaved],MATCH([@Property],meta_TypedModelElements[ID],0))</t></si><si><t>Formula:=INDEX(meta_TypedModelElements[Kind:srcLastSaved],MATCH([@Property],meta_TypedModelElements[ID],0))</t></si><si><t>Formula:=IF([@[Owning Table:srcLastSaved]]="[t Table Porfolios]",INDEX(finance_Portfolios[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Snippets",INDEX(#REF!,[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Snippets",INDEX(#REF!,[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_PackageDocumentation",INDEX(meta_PackageDocumentation[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Snippets",INDEX(#REF!,[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Classifiers",INDEX(meta_Classifiers[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_TypedElements",INDEX(meta_TypedModelElements[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Tables",INDEX(meta_Tables[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Columns",INDEX(meta_Columns[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Rules",INDEX(meta_Rules[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Literals",INDEX(meta_Literals[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Table1Rows",INDEX(belowred_Table1Rows[#Headers],[@Position]),
+IF([@[Owning Table:srcLastSaved]]="_Table2Row",INDEX(belowred_Table2Rows[#Headers],[@Position]),
+"TODO")))))))))))))</t></si><si><t>Formula:=IF(LEFT([@ID],1)="_",RIGHT([@ID],LEN([@ID])-1),IF(TRIM([@Package])="","",TRIM(LOWER([@Package]))[&]"::")[&][@Display])</t></si><si><t>Formula:=IF([@[Name or Type]]="","",[@[Name or Type Camel Case Lower]])[&]IF([@[Kind:srcLastSaved]]="_Function","("[&][@[Function - Parameters Display]][&]")","")</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Type Super Type 6]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Type Super Type 5]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Type Super Type 4]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Type Super Type 3]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Type Super Type 2]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Type Super Type 1]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]][<][>]"_Reference","",
+"= IFNA( IF( TRIM( "[&][@[Reference - Refering Column in Excel]][&]" ) = "[&]CHAR(34)[&]""[&]CHAR(34)[&]",
+"[&]"        "[&]CHAR(34)[&]""[&]CHAR(34)[&]",
+"[&]"    IF( LEFT("[&][@[Reference - Refering Column in Excel]][&]",1)="[&]CHAR(34)[&]"_"[&]CHAR(34)[&]",
+"[&]"        RIGHT("[&][@[Reference - Refering Column in Excel]][&]",LEN("[&][@[Reference - Refering Column in Excel]][&]")-1),
+"[&]"    IF( TRIM( [@Package] )
+"[&]"            [<][>] TRIM( INDEX( "[&][@[Reference - Referenced Excel Table]][&]"[Package], MATCH( "[&][@[Reference - Refering Column in Excel]][&]", "[&][@[Reference - Referenced Excel Table]][&]"[ID],0 ) ) ),
+"[&]"        TRIM( INDEX( "[&][@[Reference - Referenced Excel Table]][&]"[Package], MATCH( "[&][@[Reference - Refering Column in Excel]][&]", "[&][@[Reference - Referenced Excel Table]][&]"[ID], 0 ) ) )
+"[&]"            [&] "[&]CHAR(34)[&]"::"[&]CHAR(34)[&]"
+"[&]"            [&] INDEX( "[&][@[Reference - Referenced Excel Table]][&]"[Display], MATCH( "[&][@[Reference - Refering Column in Excel]][&]", "[&][@[Reference - Referenced Excel Table]][&]"[ID], 0 ) ),
+"[&]"        INDEX( "[&][@[Reference - Referenced Excel Table]][&]"[Display], MATCH( "[&][@[Reference - Refering Column in Excel]][&]", "[&][@[Reference - Referenced Excel Table]][&]"[ID], 0 ) )
+"[&]"    ))), "[&]CHAR(34)[&]""[&]CHAR(34)[&]")"
+)</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]][<][>]"_Reference","",
+"                If referingColumnName = "[&]CHAR(34)[&][@[Name or Type]][&]CHAR(34)[&]" Then
+"[&]"                   referedTableName = "[&]CHAR(34)[&][@[Reference - Referenced Excel Table]][&]CHAR(34)[&]"
+"[&]"                   referedColumnName = "[&]CHAR(34)[&]"Display"[&]CHAR(34)[&]"
+"[&]"                   Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+"[&]"            End If")</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]][<][>]"_Reference","",
+"                If referingColumnName = "[&]CHAR(34)[&][@[Property - Owning Class]][&]" - "[&][@[Name or Type]][&]CHAR(34)[&]" Then
+"[&]"                   referedTableName = "[&]CHAR(34)[&][@[Reference - Referenced Excel Table]][&]CHAR(34)[&]"
+"[&]"                   referedColumnName = "[&]CHAR(34)[&]"Display"[&]CHAR(34)[&]"
+"[&]"                   Call StaticCode.updateIdOnNameChange(cellRef, referingTableName, referingColumnName, referedTableName, referedColumnName)
+"[&]"            End If")</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]]="_Parameter","",IF(AND([@Package]="util",[@[Containing Class]]=0), "public", "method"))</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Super Class 6]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Super Class 5]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Super Class 5]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Super Class 4]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Super Class 4]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Super Class 3]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Super Class 3]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Super Class 2]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Super Class 2]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Super Class 1]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Super Class 1]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Class:src]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=INDEX(meta_Classifiers[Display Qualified],MATCH([@[Class:src]],meta_Classifiers[ID],0))[&]"."</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Base Super Class 6]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Base Super Class 5]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Base Super Class 5]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Base Super Class 4]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Base Super Class 4]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Base Super Class 3]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Base Super Class 3]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Base Super Class 2]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Base Super Class 2]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Base Super Class 1]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Base Super Class 1]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Base Type]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=INDEX(meta_Classifiers[Display Qualified],MATCH([@[Base Type]],meta_Classifiers[ID],0))[&]"."</t></si><si><t>Formula:=INDEX(meta_Classifiers[Kind:srcLastSaved],MATCH([@[Base Type]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 1 Super Class 6]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 1 Super Class 5]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 1 Super Class 5]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 1 Super Class 4]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 1 Super Class 4]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 1 Super Class 3]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 1 Super Class 3]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 1 Super Class 2]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 1 Super Class 2]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 1 Super Class 1]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 1 Super Class 1]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 1 Type]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 1 Type]],meta_Classifiers[ID],0))[&]".",0)</t></si><si><t>Formula:=IF([@[Property 1 Type]]="","",INDEX(meta_Classifiers[Kind:srcLastSaved],MATCH([@[Property 1 Type]],meta_Classifiers[ID],0)))</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 2 Super Class 6]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 2 Super Class 5]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 2 Super Class 5]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 2 Super Class 4]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 2 Super Class 4]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 2 Super Class 3]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 2 Super Class 3]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 2 Super Class 2]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 2 Super Class 2]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 2 Super Class 1]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 2 Super Class 1]],meta_Classifiers[ID],0))[&]".","")</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Property 2 or Cast Type]],meta_Classifiers[ID],0)),0)</t></si><si><t>Formula:=IFNA(INDEX(meta_Classifiers[Display Qualified],MATCH([@[Property 2 or Cast Type]],meta_Classifiers[ID],0))[&]".",0)</t></si><si><t>Formula:=IF([@[Property 2 or Cast Type]]="","",INDEX(meta_Classifiers[Kind:srcLastSaved],MATCH([@[Property 2 or Cast Type]],meta_Classifiers[ID],0)))</t></si><si><t>Porfolio:srcLastSaved</t></si><si><t>Porfolio:src</t></si><si><t>Security:srcLastSaved</t></si><si><t>Security:src</t></si><si><t>Owning Table:src</t></si><si><t>myxyzpackage::MyXYZObjects</t></si><si><t>Referenced Table:src</t></si><si><t>Referenced Table Display and Select Column:src</t></si><si><t>belowred::Table1Rows.table2Ref:srcLastSaved</t></si><si><t>Property:src</t></si><si><t>belowred::table2Ref</t></si><si><t>belowred::stringValue1</t></si><si><t>meta::instancesClass</t></si><si><t>meta::Object.createBranch</t></si><si><t>Property - Owning Class:src</t></si><si><t>Excel Column - Label from Property OLD Formula</t></si><si><t>Excel Column - Label Subtype Prefix</t></si><si><t>Excel Column - Name Prefix</t></si><si><t>Referenced Table Instance Class Name</t></si><si><t>Instances Class:src</t></si><si><t>displayLastSaved</t></si><si><t>Excel Column - Label from Property or Referenced Table</t></si><si><t>Class - Generalization:src</t></si><si><t>Class - Display Property:src</t></si><si><t>Class - Business ID Property:srcLastSaved</t></si><si><t>Reference - Opposite:src</t></si><si><t>Type:src</t></si><si><t>Function - Owning Property:src</t></si><si><t>meta::Object.branchOfTable</t></si><si><t>Reference - Display and Select Property:src</t></si><si><t>Parameter - Owning Function:src</t></si><si><t>meta::Classifiers</t></si><si><t>meta::CodeTemplates</t></si><si><t>meta::Columns</t></si><si><t>meta::DocumentVersions</t></si><si><t>meta::Literals</t></si><si><t>meta::NonCapitalizedTitleWords</t></si><si><t>meta::PackageDocumentation</t></si><si><t>meta::Rules</t></si><si><t>meta::SimpleTestPattern</t></si><si><t>meta::Snippets</t></si><si><t>meta::TablePatterns</t></si><si><t>meta::Tables</t></si><si><t>meta::TypedModelElements</t></si><si><t>_meta::PackageDocumentation</t></si><si><t>_meta::Snippets</t></si><si><t>_meta::Classifiers</t></si><si><t>_meta::TypedModelElements</t></si><si><t>_meta::Tables</t></si><si><t>_meta::Columns</t></si><si><t>_meta::Rules</t></si><si><t>_meta::Literals</t></si><si><t>_meta::DocumentVersions</t></si><si><t>_meta::NonCapitalizedTitleWords</t></si><si><t>_meta::TablePatterns</t></si><si><t>_meta::CodeTemplates</t></si><si><t>_meta::SimpleTestPattern</t></si><si><t>belowred::Table1Rows_ID</t></si><si><t>belowred::Table1Rows_Kind:src</t></si><si><t>belowred::Table1Rows_Kind</t></si><si><t>belowred::Table1Rows_Package</t></si><si><t>belowred::Table1Rows_Sub Package</t></si><si><t>belowred::Table1Rows_Table 2 Ref:srcLastSaved</t></si><si><t>belowred::Table1Rows_Table 2 Ref</t></si><si><t>belowred::Table1Rows_String Value 1</t></si><si><t>belowred::Table1Rows_Test stringToBusiness</t></si><si><t>belowred::Table1Rows_Test CamelCaseUpper</t></si><si><t>belowred::Table1Rows_CORRECTION camelCaseUpper</t></si><si><t>belowred::Table1Rows_Test camelCaseToBusiness</t></si><si><t>belowred::Table1Rows_CORRECTIOON camelCaseToBusiness</t></si><si><t>belowred::Table1Rows_camelCaseLower(s)  = businessToCamelCaseLower(stringToBusiness(s))</t></si><si><t>belowred::Table1Rows_camelCaseUpper(s)  = businessToCamelCaseUpper(stringToBusiness(s)), </t></si><si><t xml:space="preserve">belowred::Table1Rows_camelCaseToBusiness(
+businessToCamelCaseUpper(
+stringToBusiness(X))) = 
+stringToBusiness(X) </t></si><si><t>belowred::Table1Rows_Table 2 Ref STORED</t></si><si><t>belowred::Table1Rows_Test stringToBusiness STORED</t></si><si><t>belowred::Table1Rows_Test CamelCaseUpper STORED</t></si><si><t>belowred::Table1Rows_Test camelCaseToBusiness STORED</t></si><si><t>belowred::Table1Rows_camelCaseLower(s)  = businessToCamelCaseLower(stringToBusiness(s)) STORED</t></si><si><t>belowred::Table1Rows_Test FunctionToBeGenerated STORED</t></si><si><t>belowred::Table1Rows_camelCaseUpper(s)  = businessToCamelCaseUpper(stringToBusiness(s)),  STORED</t></si><si><t>belowred::Table1Rows_camelCaseToBusiness(
+businessToCamelCaseUpper(
+stringToBusiness(X))) = 
+stringToBusiness(X)  STORED</t></si><si><t>belowred::Table1Rows_Testing of Busines to Camel to Business</t></si><si><t>belowred::Table2Rows_ID</t></si><si><t>belowred::Table2Rows_Kind:src</t></si><si><t>belowred::Table2Rows_Kind</t></si><si><t>belowred::Table2Rows_Package</t></si><si><t>belowred::Table2Rows_Sub Package</t></si><si><t>belowred::Table2Rows_T2 Name</t></si><si><t>belowred::Table2Rows_T2 Name:q</t></si><si><t>belowred::Table2Rows_String Value 2</t></si><si><t>belowred::Table2Rows_Table 1 Row</t></si><si><t>belowred::Table2Rows_Test Number</t></si><si><t>finance::Portfolios_ID</t></si><si><t>finance::Portfolios_Value</t></si><si><t>finance::Positions_ID</t></si><si><t>finance::Positions_Amount</t></si><si><t>finance::Positions_Valuation</t></si><si><t>finance::Securities_ID</t></si><si><t>finance::Securities_Trading Symbol</t></si><si><t>finance::Securities_Price</t></si><si><t>_meta::Classifiers_ID</t></si><si><t>_meta::Classifiers_Kind:srcLastSaved</t></si><si><t>_meta::Classifiers_Order</t></si><si><t>_meta::Classifiers_Sub Package</t></si><si><t>_meta::Classifiers_Display Qualified</t></si><si><t>_meta::Classifiers_Display</t></si><si><t>_meta::Classifiers_Name</t></si><si><t>_meta::Classifiers_Class - Abstract</t></si><si><t>_meta::Classifiers_Class - Generalization:srcLastSaved</t></si><si><t>_meta::Classifiers_Class - Display Property:srcLastSaved</t></si><si><t>_meta::CodeTemplates_ID</t></si><si><t>_meta::CodeTemplates_Kind:src</t></si><si><t>_meta::CodeTemplates_Kind</t></si><si><t>_meta::CodeTemplates_Package</t></si><si><t>_meta::CodeTemplates_Sub Package</t></si><si><t>_meta::CodeTemplates_Display:q</t></si><si><t>_meta::CodeTemplates_Display</t></si><si><t>_meta::CodeTemplates_Where Clause</t></si><si><t>_meta::CodeTemplates_Template Begin</t></si><si><t>_meta::CodeTemplates_Matched Patern 1:src</t></si><si><t>_meta::CodeTemplates_Matched Pattern 1</t></si><si><t>_meta::CodeTemplates_Matched Pattern 1 Filter Value 1</t></si><si><t>_meta::CodeTemplates_Matched Pattern 1 Filter Value 2</t></si><si><t>_meta::CodeTemplates_Matched Pattern 1 Template Column</t></si><si><t>_meta::CodeTemplates_Template Middle</t></si><si><t>_meta::CodeTemplates_Matched Pattern 2:src</t></si><si><t>_meta::CodeTemplates_Matched Pattern2</t></si><si><t>_meta::CodeTemplates_Matched Pattern 2 Filter Value 1</t></si><si><t>_meta::CodeTemplates_Matched Pattern 2 Filter Value 2</t></si><si><t>_meta::CodeTemplates_Matched Pattern 2 Template Column</t></si><si><t>_meta::CodeTemplates_Template End</t></si><si><t>_meta::CodeTemplates_Excel Formula - Target Property</t></si><si><t>_meta::CodeTemplates_VBA Code - Target Module</t></si><si><t>_meta::CodeTemplates_Definition</t></si><si><t>_meta::Columns_ID</t></si><si><t>_meta::Columns_Kind:srcLastSaved</t></si><si><t>_meta::Columns_Kind:src</t></si><si><t>_meta::Columns_Kind</t></si><si><t>_meta::Columns_Package</t></si><si><t>_meta::Columns_Sub Package</t></si><si><t>_meta::Columns_Owning Table Excel Name</t></si><si><t>_meta::Columns_Owning Table Instances Class</t></si><si><t>_meta::Columns_Owning Table:srcLastSaved</t></si><si><t>_meta::Columns_Owning Table</t></si><si><t>_meta::Columns_Referenced Table:srcLastSaved</t></si><si><t>_meta::Columns_Referenced Table</t></si><si><t>_meta::Columns_Referenced Table Display and Select Column:srcLastSaved</t></si><si><t>_meta::Columns_Referenced Table Display and Select Column</t></si><si><t>_meta::Columns_Property ID from Column Label</t></si><si><t>_meta::Columns_Property:srcLastSaved</t></si><si><t>_meta::Columns_Property</t></si><si><t>_meta::Columns_Semantics Case</t></si><si><t>_meta::Columns_Generalization 6</t></si><si><t>_meta::Columns_Generalization 5</t></si><si><t>_meta::Columns_Generalization 4</t></si><si><t>_meta::Columns_Generalization 3</t></si><si><t>_meta::Columns_Generalization 2</t></si><si><t>_meta::Columns_Generalization 1</t></si><si><t>_meta::Columns_Property Owning Class is Instance Class or Generalization</t></si><si><t>_meta::Columns_Is From Specialization 6</t></si><si><t>_meta::Columns_Is From Specialization 5</t></si><si><t>_meta::Columns_Is From Specialization 4</t></si><si><t>_meta::Columns_Is From Specialization 3</t></si><si><t>_meta::Columns_Is From Specialization 2</t></si><si><t>_meta::Columns_Is From Specialization 1</t></si><si><t>_meta::Columns_Property Owning Class is Specialization of Instance Class</t></si><si><t>_meta::Columns_Property Owning Class Name</t></si><si><t>_meta::Columns_Property Owning Class</t></si><si><t>_meta::Columns_Property Kind</t></si><si><t>_meta::Columns_Property Name</t></si><si><t>_meta::Columns_Property Changeable</t></si><si><t>_meta::Columns_Position</t></si><si><t>_meta::Columns_Stored Column Position</t></si><si><t>_meta::Columns_Excel Column - Label Actual</t></si><si><t>_meta::Columns_Label:backup:previous</t></si><si><t>_meta::Columns_Display Qualified</t></si><si><t>_meta::Columns_Excel Column - Label Overwrite</t></si><si><t>_meta::Columns_Excel Column - Label</t></si><si><t>_meta::Columns_Excel Column - Explicit Excel Formula</t></si><si><t>_meta::Columns_Excel Column - Excel Formula</t></si><si><t>_meta::DocumentVersions_ID</t></si><si><t>_meta::DocumentVersions_Name</t></si><si><t>_meta::DocumentVersions_Version</t></si><si><t>_meta::DocumentVersions_Date Tag</t></si><si><t>_meta::DocumentVersions_File Name</t></si><si><t>_meta::DocumentVersions_Change Log</t></si><si><t>_meta::DocumentVersions_Branch of Document</t></si><si><t>_meta::DocumentVersions_Create Branch</t></si><si><t>_meta::DocumentVersions_Merge Branch</t></si><si><t>_meta::DocumentVersions_Freeze Version</t></si><si><t>_meta::Literals_ID</t></si><si><t>_meta::Literals_Kind:srcLastSaved</t></si><si><t>_meta::Literals_Kind</t></si><si><t>_meta::Literals_Package</t></si><si><t>_meta::Literals_Sub Package</t></si><si><t>_meta::Literals_Display:q</t></si><si><t>_meta::Literals_Display</t></si><si><t>_meta::Literals_Name</t></si><si><t>_meta::Literals_Parent:src</t></si><si><t>_meta::Literals_Parent</t></si><si><t>_meta::NonCapitalizedTitleWords_ID</t></si><si><t>_meta::NonCapitalizedTitleWords_Word</t></si><si><t>_meta::PackageDocumentation_ID</t></si><si><t>_meta::PackageDocumentation_Sub Package</t></si><si><t>_meta::PackageDocumentation_Package Display</t></si><si><t>_meta::PackageDocumentation_Topic Order</t></si><si><t>_meta::PackageDocumentation_Topic</t></si><si><t>_meta::Rules_ID</t></si><si><t>_meta::Rules_Kind:srcLastSaved</t></si><si><t>_meta::Rules_Kind</t></si><si><t>_meta::Rules_Package</t></si><si><t>_meta::Rules_Sub Package</t></si><si><t>_meta::Rules_Super Class 6:display:q.</t></si><si><t>_meta::Rules_Super Class 6</t></si><si><t>_meta::Rules_Super Class 5:display:q.</t></si><si><t>_meta::Rules_Super Class 5</t></si><si><t>_meta::Rules_Super Class 4:display:q.</t></si><si><t>_meta::Rules_Super Class 4</t></si><si><t>_meta::Rules_Super Class 3:display:q.</t></si><si><t>_meta::Rules_Super Class 3</t></si><si><t>_meta::Rules_Super Class 2:display:q.</t></si><si><t>_meta::Rules_Super Class 2</t></si><si><t>_meta::Rules_Super Class 1:display:q.</t></si><si><t>_meta::Rules_Super Class 1</t></si><si><t>_meta::Rules_Class:display:q.</t></si><si><t>_meta::Rules_Class:src</t></si><si><t>_meta::Rules_Class</t></si><si><t>_meta::Rules_Feature Type</t></si><si><t>_meta::Rules_Feature Base Type Kind</t></si><si><t>_meta::Rules_Feature:src</t></si><si><t>_meta::Rules_Feature</t></si><si><t>_meta::Rules_VBA Function Step 1</t></si><si><t>_meta::Rules_VBA Function Step 2</t></si><si><t>_meta::Rules_VBA Function Step 3</t></si><si><t>_meta::Rules_Do Action Rule Details</t></si><si><t>_meta::Rules_Line</t></si><si><t>_meta::Rules_Part:src</t></si><si><t>_meta::Rules_Part:displayedChoice</t></si><si><t>_meta::Rules_Part:q</t></si><si><t>_meta::Rules_Line As Text</t></si><si><t>_meta::Rules_Part</t></si><si><t>_meta::Rules_Rule Code</t></si><si><t>_meta::Rules_Rule Biz ID Without Line</t></si><si><t>_meta::Rules_Rule Biz ID</t></si><si><t>_meta::Rules_Part:src At Line - 1</t></si><si><t>_meta::Rules_Line-1</t></si><si><t>_meta::Rules_Indent</t></si><si><t>_meta::Rules_Generation</t></si><si><t>_meta::Rules_Operator</t></si><si><t>_meta::Rules_Base Super Class 6:display:q.</t></si><si><t>_meta::Rules_Base Super Class 6</t></si><si><t>_meta::Rules_Base Super Class 5:display:q.</t></si><si><t>_meta::Rules_Base Super Class 5</t></si><si><t>_meta::Rules_Base Super Class 4:display:q.</t></si><si><t>_meta::Rules_Base Super Class 4</t></si><si><t>_meta::Rules_Base Super Class 3:display:q.</t></si><si><t>_meta::Rules_Base Super Class 3</t></si><si><t>_meta::Rules_Base Super Class 2:display:q.</t></si><si><t>_meta::Rules_Base Super Class 2</t></si><si><t>_meta::Rules_Base Super Class 1:display:q.</t></si><si><t>_meta::Rules_Base Super Class 1</t></si><si><t>_meta::Rules_Base Class:display:q.</t></si><si><t>_meta::Rules_Base Type Kind</t></si><si><t>_meta::Rules_Base Type</t></si><si><t>_meta::Rules_Base as Parameter</t></si><si><t>_meta::Rules_Base</t></si><si><t>_meta::Rules_Property 1:src</t></si><si><t>_meta::Rules_Property 1</t></si><si><t>_meta::Rules_Property 1 Super Class 6:display:q.</t></si><si><t>_meta::Rules_Property 1 Super Class 6</t></si><si><t>_meta::Rules_Property 1 Super Class 5:display:q.</t></si><si><t>_meta::Rules_Property 1 Super Class 5</t></si><si><t>_meta::Rules_Property 1 Super Class 4:display:q.</t></si><si><t>_meta::Rules_Property 1 Super Class 4</t></si><si><t>_meta::Rules_Property 1 Super Class 3:display:q.</t></si><si><t>_meta::Rules_Property 1 Super Class 3</t></si><si><t>_meta::Rules_Property 1 Super Class 2:display:q.</t></si><si><t>_meta::Rules_Property 1 Super Class 2</t></si><si><t>_meta::Rules_Property 1 Super Class 1:display:q.</t></si><si><t>_meta::Rules_Property 1 Super Class 1</t></si><si><t>_meta::Rules_Property 1 Class:display:q.</t></si><si><t>_meta::Rules_Property 1 Type Kind</t></si><si><t>_meta::Rules_Property 1 Type</t></si><si><t>_meta::Rules_Property 2:src</t></si><si><t>_meta::Rules_Property 2</t></si><si><t>_meta::Rules_Cast:src</t></si><si><t>_meta::Rules_Cast</t></si><si><t>_meta::Rules_Property 2 Super Class 6:display:q.</t></si><si><t>_meta::Rules_Property 2 Super Class 6</t></si><si><t>_meta::Rules_Property 2 Super Class 5:display:q.</t></si><si><t>_meta::Rules_Property 2 Super Class 5</t></si><si><t>_meta::Rules_Property 2 Super Class 4:display:q.</t></si><si><t>_meta::Rules_Property 2 Super Class 4</t></si><si><t>_meta::Rules_Property 2 Super Class 3:display:q.</t></si><si><t>_meta::Rules_Property 2 Super Class 3</t></si><si><t>_meta::Rules_Property 2 Super Class 2:display:q.</t></si><si><t>_meta::Rules_Property 2 Super Class 2</t></si><si><t>_meta::Rules_Property 2 Super Class 1:display:q.</t></si><si><t>_meta::Rules_Property 2 Super Class 1</t></si><si><t>_meta::Rules_Property 2 Class:display:q.</t></si><si><t>_meta::Rules_Property 2 or Cast Type Kind</t></si><si><t>_meta::Rules_Property 2 or Cast Type</t></si><si><t>_meta::Rules_Property 3:src</t></si><si><t>_meta::Rules_Property 3</t></si><si><t>_meta::Rules_Processor</t></si><si><t>_meta::Rules_Rule</t></si><si><t>_meta::Rules_Manual VBA Code</t></si><si><t>_meta::Rules_VBA Code</t></si><si><t>_meta::Rules_Manual Excel Formula</t></si><si><t>_meta::Rules_Excel Formula</t></si><si><t>_meta::Rules_Constraint Is Invariant</t></si><si><t>_meta::Rules_Update - Name</t></si><si><t>_meta::Rules_Update LHS - Feature:src</t></si><si><t>_meta::Rules_Update LHS - Feature</t></si><si><t>_meta::Rules_Update LHS - Mode</t></si><si><t>_meta::SimpleTestPattern_ID</t></si><si><t>_meta::SimpleTestPattern_Filter1</t></si><si><t>_meta::SimpleTestPattern_Filter2</t></si><si><t>_meta::SimpleTestPattern_Order</t></si><si><t>_meta::SimpleTestPattern_Template</t></si><si><t>_meta::SimpleTestPattern_Other</t></si><si><t>_meta::Snippets_ID</t></si><si><t>_meta::Snippets_Sub Package</t></si><si><t>_meta::Snippets_Snippet</t></si><si><t>_meta::TablePatterns_ID</t></si><si><t>_meta::TablePatterns_Kind:srcLastSaved</t></si><si><t>_meta::TablePatterns_Kind</t></si><si><t>_meta::TablePatterns_Package</t></si><si><t>_meta::TablePatterns_Sub Package</t></si><si><t>_meta::TablePatterns_Display:q</t></si><si><t>_meta::TablePatterns_Display</t></si><si><t>_meta::TablePatterns_Name</t></si><si><t>_meta::TablePatterns_Source Table</t></si><si><t>_meta::TablePatterns_Match Filter Column 1</t></si><si><t>_meta::TablePatterns_Match Filter Column 2</t></si><si><t>_meta::TablePatterns_Match Key Column 1</t></si><si><t>_meta::TablePatterns_Match Key Column 2</t></si><si><t>_meta::TablePatterns_Match Key Column 3</t></si><si><t>_meta::TablePatterns_Match Key Column 4</t></si><si><t>_meta::TablePatterns_Match Key Column 5</t></si><si><t>_meta::TablePatterns_Order Column</t></si><si><t>_meta::TablePatterns_Template Parameter Column 1</t></si><si><t>_meta::TablePatterns_Template Parameter Column 2</t></si><si><t>_meta::TablePatterns_Template Parameter Column 3</t></si><si><t>_meta::TablePatterns_Definition</t></si><si><t>_meta::Tables_ID</t></si><si><t>_meta::Tables_Kind:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Kind</t></si><si><t>_meta::Tables_Sub Package</t></si><si><t>_meta::Tables_Excel Table - Excel Name</t></si><si><t>_meta::Tables_Display Qualified</t></si><si><t>_meta::Tables_Display</t></si><si><t>_meta::Tables_Name</t></si><si><t>_meta::Tables_Instances Class:srcLastSaved</t></si><si><t>_meta::Tables_Instances Class</t></si><si><t>_meta::Tables_Excel Table - Sheet Name</t></si><si><t>_meta::Tables_Excel Table - Explicit Sheet Name</t></si><si><t>_meta::Tables_Branch of Table:src</t></si><si><t>_meta::Tables_Branch of Table</t></si><si><t>_meta::Tables_Create Branch</t></si><si><t>_meta::Tables_Merge Branch</t></si><si><t xml:space="preserve">_meta::Tables_ExceFormula Previous Line </t></si><si><t>_meta::Tables_Excel Formula for Column "Excel Column - Label Actual" of Table Columns</t></si><si><t>_meta::TypedModelElements_ID</t></si><si><t>_meta::TypedModelElements_Kind:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Order</t></si><si><t>_meta::TypedModelElements_Sub Package</t></si><si><t>_meta::TypedModelElements_Property - Owning Class:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Display</t></si><si><t>_meta::TypedModelElements_Name or Type Camel Case Lower</t></si><si><t>_meta::TypedModelElements_Display without Class</t></si><si><t>_meta::TypedModelElements_Name or Type</t></si><si><t>_meta::TypedModelElements_Name</t></si><si><t>_meta::TypedModelElements_Type Super Type 7</t></si><si><t>_meta::TypedModelElements_Type Super Type 6</t></si><si><t>_meta::TypedModelElements_Type Super Type 5</t></si><si><t>_meta::TypedModelElements_Type Super Type 4</t></si><si><t>_meta::TypedModelElements_Type Super Type 3</t></si><si><t>_meta::TypedModelElements_Type Super Type 2</t></si><si><t>_meta::TypedModelElements_Type Super Type 1</t></si><si><t>_meta::TypedModelElements_Type Derived:display</t></si><si><t>_meta::TypedModelElements_Type Derived</t></si><si><t>_meta::TypedModelElements_Type:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Reference - Opposite:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Reference - Opposite</t></si><si><t>_meta::TypedModelElements_Reference - Display and Select Property:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Reference - Display and Select Property</t></si><si><t>_meta::TypedModelElements_Function - Owning Property:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Parameter - Business Key</t></si><si><t>_meta::TypedModelElements_Parameter - Owning Function:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Parameter - Owning Function</t></si><si><t>_meta::TypedModelElements_Property - Using Property:srcLastSaved</t></si><si><t>_meta::TypedModelElements_Property - Using Property</t></si><si><t>_meta::TypedModelElements_Reference - Referenced Excel Table</t></si><si><t>_meta::TypedModelElements_Reference - Refering Column in Excel</t></si><si><t>_meta::TypedModelElements_Reference - Excel Formula for Display</t></si><si><t>_meta::TypedModelElements_Reference - VBA for Id Change in Supertype</t></si><si><t>_meta::TypedModelElements_Referencce - VBA for Id Change in Subtype</t></si><si><t>_meta::TypedModelElements_Reference - Code</t></si><si><t>_meta::TypedModelElements_Feature - VBA Type</t></si><si><t>_meta::TypedModelElements_Feature - Manual VBA Header</t></si><si><t>_meta::TypedModelElements_Feature - VBA Header</t></si><si><t>_meta::TypedModelElements_Feature - VBA</t></si><si><t>_meta::TypedModelElements_Feature - Manual VBA Body</t></si><si><t>_meta::TypedModelElements_Feature - VBA Body</t></si><si><t>_meta::TypedModelElements_Feature - VBA Code</t></si><si><t>_meta::TypedModelElements_Code</t></si><si><t>_meta::TypedModelElements_Description</t></si><si><t>finance::Portfolios_Kind:srcLastSaved</t></si><si><t>finance::Portfolios_Kind:src</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]]="",IF([@Kind]="","",INDEX(meta_Classifiers[ID],MATCH([@Kind],meta_Classifiers[Display Qualified],0))),[@[Kind:srcLastSaved]])</t></si><si><t>finance::Portfolios_Kind</t></si><si><t>finance::Portfolios_Package</t></si><si><t>finance::Portfolios_Owner</t></si><si><t>finance::Positions_Kind:srcLastSaved</t></si><si><t>finance::Positions_Kind:src</t></si><si><t>finance::Positions_Kind</t></si><si><t>finance::Positions_Package</t></si><si><t>finance::Positions_Porfolio:srcLastSaved</t></si><si><t>finance::Positions_Porfolio:src</t></si><si><t>finance::Positions_Portfolio</t></si><si><t>finance::Positions_Security:srcLastSaved</t></si><si><t>finance::Positions_Security:src</t></si><si><t>finance::Positions_Security</t></si><si><t>finance::Securities_Kind:srcLastSaved</t></si><si><t>finance::Securities_Kind:src</t></si><si><t>finance::Securities_Kind</t></si><si><t>finance::Securities_Package</t></si><si><t>_meta::Snippets_Kind:srcLastSaved</t></si><si><t>_meta::Snippets_Kind:src</t></si><si><t>_meta::Snippets_Kind</t></si><si><t>_meta::Snippets_Package</t></si><si><t>_meta::Snippets_Line</t></si><si><t>_meta::PackageDocumentation_Kind:srcLastSaved</t></si><si><t>_meta::PackageDocumentation_Kind:src</t></si><si><t>_meta::PackageDocumentation_Kind</t></si><si><t>_meta::PackageDocumentation_Package</t></si><si><t>_meta::PackageDocumentation_Definition</t></si><si><t>_meta::Tables_Kind:src</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]][<][>]"", [@[Kind:srcLastSaved]],
+   IF([@Kind]="","",
+      INDEX(meta_Classifiers[ID],
+         MATCH([@Kind],meta_Classifiers[Display Qualified],0))))</t></si><si><t>_meta::Tables_Kind</t></si><si><t>_meta::Tables_Package</t></si><si><t>_meta::Tables_Instances Class:src</t></si><si><t>Formula:=IF([@[Instances Class:srcLastSaved]][<][>]"", [@[Instances Class:srcLastSaved]],
+   IF([@[Instances Class]]="","",
+      INDEX(meta_Classifiers[ID],
+         MATCH([@[Instances Class]],meta_Classifiers[Display Qualified],0))))</t></si><si><t>_meta::Columns_Owning Table:src</t></si><si><t>Formula:=IF([@[Owning Table:srcLastSaved]][<][>]"", [@[Owning Table:srcLastSaved]],
+   IF([@[Owning Table]]="","",
+      INDEX(meta_Tables[ID],
+         MATCH([@[Owning Table]],meta_Tables[Display Qualified],0))))</t></si><si><t>_meta::Columns_Referenced Table:src</t></si><si><t>_meta::Columns_Referenced Table Display and Select Column:src</t></si><si><t>Formula:=IF([@[Referenced Table Display and Select Column:srcLastSaved]][<][>]"", [@[Referenced Table Display and Select Column:srcLastSaved]],
+   IF([@[Referenced Table Display and Select Column]]="","",
+      INDEX([ID],
+         MATCH([@[Referenced Table Display and Select Column]],[Display Qualified],0))))</t></si><si><t>_meta::Columns_Changeable</t></si><si><t>Formula:=IF([@[Excel Column - Excel Formula]]="","x","")</t></si><si><t>_meta::Columns_Excel Column - Name Prefix</t></si><si><t>_meta::Columns_Referenced Table Instance Class Name</t></si><si><t>Formula:=IF([@[Referenced Table:src]]="","",INDEX(meta_Tables[Instances Class],MATCH([@[Referenced Table:src]],meta_Tables[ID],0)))</t></si><si><t>_meta::Columns_Property:src</t></si><si><t>Formula:=IF([@[Property:srcLastSaved]][<][>]"", [@[Property:srcLastSaved]],
+   IF([@Property]="","",
+      INDEX(meta_TypedModelElements[ID],
+         MATCH([@Property],meta_TypedModelElements[Display Qualified],0))))</t></si><si><t>_meta::Columns_Excel Column - Label from Property or Referenced Table</t></si><si><t>Formula:=[@[Excel Column - Label Subtype Prefix]][&]
+IF([@[Property Name]][<][>]"",[@[Property Name]],
+    IF([@[Excel Column - Name Prefix]][<][>]"", [@[Excel Column - Name Prefix]][&]" ","")  [&]
+          [@[Referenced Table Instance Class Name]]) [&]
+IF(AND([@[Referenced Table:src]][<][>]"",[@Changeable]="x",[@[Semantics Case]]="displayLastSaved"),"",
+IF(AND([@[Property Kind]]="_Reference",[@[Property Changeable]]="x",[@[Semantics Case]]="displayLastSaved"),"",
+IF(AND([@[Property Kind]]="_Reference",[@[Property Changeable]]="x"),":"[&][@[Semantics Case]],
+IF(AND(OR([@Changeable]="x",[@[Property Changeable]]="x"),[@[Semantics Case]]="src"),"",
+IF(OR([@Changeable]="x",[@[Property Changeable]]="x"),":"[&][@[Semantics Case]],
+IF(AND([@Changeable][<][>]"x",[@[Property Changeable]][<][>]"x",[@[Semantics Case]]="derive"),"",
+IF(AND([@Changeable][<][>]"x",[@[Property Changeable]][<][>]"x"),":"[&][@[Semantics Case]],"TODO")))))))</t></si><si><t>_meta::Columns_Excel Column - Label Subtype Prefix</t></si><si><t>Formula:= IF([@[Property Owning Class is Specialization of Instance Class]],[@[Property Owning Class Name]][&]" - ","")</t></si><si><t>_meta::Columns_Excel Column - Label from Property OLD Formula</t></si><si><t>Formula:=[@[Owning Table]][&]"."[&]IFERROR(camelCaseLower(LEFT([@[Excel Column - Label]],FIND(":",[@[Excel Column - Label]])-1))[&]RIGHT([@[Excel Column - Label]],LEN([@[Excel Column - Label]])-FIND(":",[@[Excel Column - Label]])+1),camelCaseLower([@[Excel Column - Label]]))</t></si><si><t>Formula:=IF(TRIM([@[Excel Column - Label Overwrite]])[<][>]"",[@[Excel Column - Label Overwrite]],[@[Excel Column - Label from Property or Referenced Table]])</t></si><si><t>Formula:=IF([@[Excel Column - Explicit Excel Formula]]="","",[@[Excel Column - Explicit Excel Formula]])</t></si><si><t>_meta::Classifiers_Kind:src</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]][<][>]"", [@[Kind:srcLastSaved]],
+   IF([@Kind]="","",
+      INDEX([ID],
+         MATCH([@Kind],[Display Qualified],0))))</t></si><si><t>_meta::Classifiers_Kind</t></si><si><t>_meta::Classifiers_Package</t></si><si><t>Formula:=camelCaseUpper([@Name])</t></si><si><t>_meta::Classifiers_Class - Generalization:src</t></si><si><t>Formula:=IF([@[Class - Generalization:srcLastSaved]][<][>]"", [@[Class - Generalization:srcLastSaved]],
+   IF([@[Class - Generalization]]="","",
+      INDEX([ID],
+         MATCH([@[Class - Generalization]],[Display Qualified],0))))</t></si><si><t>_meta::Classifiers_Class - Generalization</t></si><si><t>_meta::Classifiers_Definition</t></si><si><t>_meta::Classifiers_Class - Display Property:src</t></si><si><t>Formula:=IF([@[Class - Display Property:srcLastSaved]][<][>]"", [@[Class - Display Property:srcLastSaved]],
+   IF([@[Class - Display Property]]="","",
+      INDEX(meta_TypedModelElements[ID],
+         MATCH([@[Class - Display Property]],meta_TypedModelElements[Display Qualified],0))))</t></si><si><t>_meta::Classifiers_Class - Display Property</t></si><si><t>_meta::Classifiers_Class - Business ID Property:srcLastSaved</t></si><si><t>_meta::Classifiers_Class - Business ID Property:src</t></si><si><t>Formula:=IF([@[Class - Business ID Property:srcLastSaved]][<][>]"", [@[Class - Business ID Property:srcLastSaved]],
+   IF([@[Class - Business ID Property]]="","",
+      INDEX(meta_TypedModelElements[ID],
+         MATCH([@[Class - Business ID Property]],meta_TypedModelElements[Display Qualified],0))))</t></si><si><t>_meta::Classifiers_Class - Business ID Property</t></si><si><t>_meta::TypedModelElements_Kind:src</t></si><si><t>_meta::TypedModelElements_Package</t></si><si><t>_meta::TypedModelElements_Containing Class</t></si><si><t>Formula:=IF([@Kind]="Function",
+INDEX([Property - Owning Class:srcLastSaved],MATCH([@[Function - Owning Property:src]],[ID],0)),
+IF([@Kind]="Parameter", INDEX([Containing Class],MATCH([@[Parameter - Owning Function:src]],[ID],0)),
+[@[Property - Owning Class:src]]))</t></si><si><t>_meta::TypedModelElements_Containing Class:display</t></si><si><t>_meta::TypedModelElements_Property - Owning Class:src</t></si><si><t>Formula:=IF([@[Property - Owning Class:srcLastSaved]][<][>]"", [@[Property - Owning Class:srcLastSaved]],
+   IF([@[Property - Owning Class]]="","",
+      INDEX(meta_Classifiers[ID],
+         MATCH([@[Property - Owning Class]],meta_Classifiers[Display Qualified],0))))</t></si><si><t>_meta::TypedModelElements_Property - Owning Class</t></si><si><t>_meta::TypedModelElements_Display Qualified</t></si><si><t>_meta::TypedModelElements_Function - Parameters Display</t></si><si><t>_meta::TypedModelElements_Function - Parameters in VBA Header</t></si><si><t>Formula:=camelCaseLower([@[Name or Type]])</t></si><si><t>Formula:=INDEX(meta_Classifiers[Class - Generalization:srcLastSaved],MATCH([@[Type:src]],meta_Classifiers[ID],0))</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]][<][>]"_Function",[@Type],INDEX([Type],MATCH([@[Function - Owning Property:src]],[ID],0)))</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]][<][>]"_Function",[@[Type:src]],INDEX([Type:src],MATCH([@[Function - Owning Property:src]],[ID],0)))</t></si><si><t>_meta::TypedModelElements_Type:src</t></si><si><t>Formula:=IF([@[Type:srcLastSaved]][<][>]"", [@[Type:srcLastSaved]],
+   IF([@Type]="","",
+      INDEX(meta_Classifiers[ID],
+         MATCH([@Type],meta_Classifiers[Display Qualified],0))))</t></si><si><t>_meta::TypedModelElements_Type</t></si><si><t>_meta::TypedModelElements_Feature - Arity</t></si><si><t>_meta::TypedModelElements_Property - Changeable</t></si><si><t>_meta::TypedModelElements_Reference - Opposite:src</t></si><si><t>Formula:=IF([@[Reference - Opposite:srcLastSaved]][<][>]"", [@[Reference - Opposite:srcLastSaved]],
+   IF([@[Reference - Opposite]]="","",
+      INDEX([ID],
+         MATCH([@[Reference - Opposite]],[Display Qualified],0))))</t></si><si><t>_meta::TypedModelElements_Reference - Display and Select Property:src</t></si><si><t>Formula:=IF([@[Reference - Display and Select Property:srcLastSaved]][<][>]"", [@[Reference - Display and Select Property:srcLastSaved]],
+   IF([@[Reference - Display and Select Property]]="","",
+      INDEX([ID],
+         MATCH([@[Reference - Display and Select Property]],[Display Qualified],0))))</t></si><si><t>_meta::TypedModelElements_Parameter - Position</t></si><si><t>_meta::TypedModelElements_Function - Owning Property:src</t></si><si><t>Formula:=IF([@[Function - Owning Property:srcLastSaved]][<][>]"", [@[Function - Owning Property:srcLastSaved]],
+   IF([@[Function - Owning Property]]="","",
+      INDEX([ID],
+         MATCH([@[Function - Owning Property]],[Display Qualified],0))))</t></si><si><t>_meta::TypedModelElements_Function - Owning Property</t></si><si><t>_meta::TypedModelElements_Parameter - Owning Function:src</t></si><si><t>Formula:=IF([@[Parameter - Owning Function:srcLastSaved]][<][>]"", [@[Parameter - Owning Function:srcLastSaved]],
+   IF([@[Parameter - Owning Function]]="","",
+      INDEX([ID],
+         MATCH([@[Parameter - Owning Function]],[Display Qualified],0))))</t></si><si><t>Formula:=IF([@[Kind:srcLastSaved]][<][>]"_Reference","",
+IFNA(INDEX(#REF!,MATCH([@[Type:src]],meta_Tables[Instances Class:src],0)),
+IFNA(INDEX(#REF!,MATCH([@[Type Super Type 1]],meta_Tables[Instances Class:src],0)),
+IFNA(INDEX(#REF!,MATCH([@[Type Super Type 2]],meta_Tables[Instances Class:src],0)),
+IFNA(INDEX(#REF!,MATCH([@[Type Super Type 3]],meta_Tables[Instances Class:src],0)),
+IFNA(INDEX(#REF!,MATCH([@[Type Super Type 4]],meta_Tables[Instances Class:src],0)),
+IFNA(INDEX(#REF!,MATCH([@[Type Super Type 5]],meta_Tables[Instances Class:src],0)),
+IFNA(INDEX(#REF!,MATCH([@[Type Super Type 6]],meta_Tables[Instances Class:src],0)),"")))))))
+)</t></si><si><t>Formula:=IF([@[Property 1:src]]="","",INDEX(meta_TypedModelElements[Type:src],MATCH([@[Property 1:src]],meta_TypedModelElements[ID],0)))</t></si><si><t>Formula:=IF([@[Cast:src]][<][>]"",[@[Cast:src]],IF([@[Property 2:src]]="","",INDEX(meta_TypedModelElements[Type:src],MATCH([@[Property 2:src]],meta_TypedModelElements[ID],0))))</t></si><si><t>Formula:=IF([@[Owning Table:src]]="","",INDEX(meta_Classifiers[Package],MATCH([@[Owning Table Instances Class]],meta_Classifiers[ID],0)))</t></si><si><t>Formula:=INDEX(meta_Tables[Excel Table - Excel Name],MATCH([@[Owning Table:src]],meta_Tables[ID],0))</t></si><si><t>Formula:=INDEX(meta_Tables[Instances Class:src],MATCH([@[Owning Table:src]],meta_Tables[ID],0))</t></si><si><t>belowred::Table2Row</t></si><si><t>belowred::Table1Row</t></si><si><t>Type Name</t></si><si><t>Formula:= IF([@[Kind:src]]="_Parameter",
+  INDEX([Display Qualified],MATCH([@[Parameter - Owning Function:src]],[ID],0))[&]"."[&][@[Display without Class]],
+IF(TRIM([@Package])="","",TRIM(LOWER([@Package]))[&]"::")[&][@Display])</t></si><si><t>Formula:=IF([@[Kind:src]]="_Function",INDEX([Name or Type],MATCH([@[Function - Owning Property:src]],[ID],0)),IF(TRIM([@Name])="",[@[Type Name]],[@Name]))</t></si><si><t>_meta::TypedModelElements_Type Name</t></si><si><t>Formula:=IF([@[Type:src]]="","",INDEX(meta_Classifiers[Name],MATCH([@[Type:src]],meta_Classifiers[ID],0)))</t></si><si><t>myxyzpackage::MyXYZ_Objects_ID</t></si><si><t>myxyzpackage::MyXYZ_Objects</t></si><si><t>myxyzpackage::MyXYZ_Objects_Kind:src</t></si><si><t>myxyzpackage::MyXYZ_Objects_Kind</t></si><si><t>myxyzpackage::MyXYZ_Objects_Package</t></si><si><t>myxyzpackage::MyXYZ_Objects_Sub Package</t></si><si><t>myxyzpackage::MyXYZ_Objects_Display:q</t></si><si><t>myxyzpackage::MyXYZ_Objects_Display</t></si><si><t>myxyzpackage::MyXYZ_Objects_My XYZ Column</t></si><si><t>myxyzpackage::MyXYZ_Objects_Definition</t></si><si><t>___meta_ColumnsRowTemplate</t></si><si><t>___meta_TablesRowTemplate</t></si><si><t>__Placeholder</t></si><si><t>Formula:=IFERROR(LEFT([@[Excel Table - Excel Name]],FIND("_",[@[Excel Table - Excel Name]])-1),"")</t></si><si><t>Test 1</t></si><si><t>Test 2</t></si><si><t>test::NewTable</t></si><si><t>test_NewTable</t></si><si><t>New Table</t></si><si><t>test::NewTable_ID</t></si><si><t>test::NewTable_Test 1</t></si><si><t>test::NewTable_Test 2</t></si><si><t>Formula:=IF([@[Referenced Table:srcLastSaved]][<][>]"", [@[Referenced Table:srcLastSaved]],
+   IF([@[Referenced Table]]="","",
+      INDEX(meta_Tables[ID],
+         MATCH([@[Referenced Table]],meta_Tables[Display Qualified],0))))</t></si><si><t>Excel Column - Validation Formula</t></si><si><t>ValidationFormula:=INDIRECT("meta_Classifiers[Display Qualified]")</t></si><si><t>ValidationFormula:=INDIRECT("meta_Tables[Display Qualified]")</t></si><si><t>ValidationFormula:=INDIRECT("meta_Columns[Display Qualified]")</t></si><si><t>ValidationFormula:=INDIRECT("meta_TypedModelElements[Display Qualified]")</t></si><si><t>_meta::Columns_Excel Column - Validation Formula</t></si><si><t>ValidationFormula:=INDIRECT("belowred_Table2Rows[T2 Name:q]")</t></si><si><t>ValidationFormula:=DynamicDropDownList</t></si></sst>
\ No newline at end of file
```
